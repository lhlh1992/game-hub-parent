# 聊天服务边界分析

> 本文档分析聊天服务在项目中的角色定位、使用场景、业务边界，以及与其他服务和前端的交互方式。

---

## 一、Chat 服务在项目中的角色定位

### 1.1 服务定位

**chat-service** 是平台中的**社交域核心服务**，负责所有与"消息通信"相关的功能。

**在整体架构中的位置**：
- **业务域**：社交域（与游戏域、用户域、运营域并列）
- **核心价值**：提供用户之间的实时沟通能力，增强平台社交属性
- **服务性质**：业务服务（非基础设施服务）

### 1.2 与其他服务的关系

```
平台架构
├── 接入层：gateway（路由、鉴权）
├── 用户域：system-service（用户管理、权限）
├── 游戏域：game-service（游戏逻辑、房间管理）
├── 社交域：chat-service（聊天通信）← 本文档重点
└── 数据域：PostgreSQL、Redis、Kafka（基础设施）
```

**chat-service 的定位**：
- 独立于游戏逻辑（不处理游戏状态）
- 独立于用户管理（不管理用户注册/登录）
- 但需要**查询**用户信息（昵称、头像）
- 但需要**感知**房间生命周期（房间创建/删除时自动创建/清理聊天会话）

---

## 二、聊天功能使用场景

### 2.1 对局房间内聊天（Room Chat）

**使用位置**：
- 前端：`GameRoomPage.jsx` - 游戏房间页面
- 触发时机：玩家进入游戏房间后

**特点**：
- 房间内所有玩家可见（包括观战者）
- 需要知道房间 ID 和房间成员列表
- 消息仅在该房间内可见，不对外暴露

**房间生命周期感知策略**：

**必须感知的事件**：
1. **房间删除** → 自动清理房间聊天会话
   - **原因**：房间删除后，聊天会话应该被清理，避免资源泄漏
   - **实现**：通过 Kafka 事件 `RoomDeletedEvent` 感知

2. **玩家加入房间** → 更新会话成员列表（用于权限控制）
   - **原因**：只有房间成员才能发送/接收消息，需要同步成员列表
   - **实现**：通过 Kafka 事件 `RoomMemberJoinedEvent` 感知，或通过查询 game-service 获取

3. **玩家离开房间** → 更新会话成员列表
   - **原因**：离开房间后，不应该再接收该房间的消息
   - **实现**：通过 Kafka 事件 `RoomMemberLeftEvent` 感知

**可选感知的事件**：
1. **房间创建** → 可以提前创建房间聊天会话，也可以按需创建
   - **方案 A（提前创建）**：房间创建时自动创建聊天会话
     - **优点**：玩家进入房间后立即能看到聊天界面和历史消息
     - **缺点**：如果房间创建后没人进入，会浪费资源
   - **方案 B（按需创建）**：第一次发送消息时创建聊天会话
     - **优点**：节省资源，只创建实际使用的会话
     - **缺点**：玩家进入房间后，如果还没人发消息，看不到聊天界面
   - **建议**：采用**按需创建**（方案 B），因为：
     - 房间创建后不一定有人使用聊天功能
     - 第一次发送消息时创建，用户体验影响不大
     - 节省资源，更符合"按需分配"的原则

**业务价值**：
- 玩家在对局中实时交流（如"好棋"、"加油"等）
- 增强游戏社交体验

### 2.2 私聊（Private Chat）

**使用位置**：
- 前端：未来可能新增"私聊"页面或组件
- 触发时机：用户主动发起私聊

**特点**：
- 点对点通信，仅双方可见
- 需要知道对方用户 ID
- 支持历史消息查询
- 支持未读消息计数（每个私聊会话独立计数）
- 消息持久化存储（长期保存）

**业务价值**：
- 玩家之间私下交流
- 支持好友之间的深度社交

### 2.3 大厅广播（Lobby Broadcast）

**使用位置**：
- 前端：`GlobalChat.jsx` - 所有页面都有
- 触发时机：用户登录后自动订阅

**特点**：
- 全局频道，所有在线用户可见
- 不依赖房间或游戏
- 独立于游戏逻辑
- 消息对所有在线用户广播
- 支持历史消息查询（近期消息）

**业务价值**：
- 平台级社交，增强用户粘性
- 玩家可以讨论游戏、寻找队友等

**注意**：大厅广播是"聊天功能"，不是"系统通知"（系统通知见下文）

### 2.4 系统通知（System Notification）

**使用位置**：
- 前端：可能显示在通知中心、弹窗等
- 触发时机：系统主动推送

**特点**：
- 系统主动发送，用户被动接收
- 内容类型：系统公告、活动通知、对局结果通知等
- 通常不需要用户回复
- 支持未读计数（系统通知总数）
- 可能需要持久化（重要通知需要保留）

**业务边界讨论**：
- **是否属于 chat-service？**
  - **支持观点**：系统通知也是"消息"，可以复用 chat-service 的消息推送能力
  - **反对观点**：系统通知是"运营域"功能，应该由独立的 notification-service 负责
- **建议**：系统通知可以**先放在 chat-service**（复用消息推送能力），未来如果通知功能复杂化（如推送、邮件、短信等），再拆分为独立的 notification-service

**本文档暂定**：系统通知属于 chat-service 的职责范围，但作为独立的功能模块

---

## 三、业务边界分析

### 3.1 如果都放在 system-service 会如何？

#### 方案：将聊天功能集成到 system-service

**架构**：
```
system-service
├── 用户管理模块（已有）
│   ├── 用户 CRUD
│   ├── 用户档案
│   └── 权限管理
└── 聊天模块（新增）
    ├── 消息收发
    ├── 会话管理
    ├── WebSocket 连接管理
    └── 消息持久化
```

#### 问题分析

**1. 职责混乱**
- system-service 既管"用户管理"又管"聊天通信"，边界不清
- 用户管理和聊天通信是**不同的业务域**：
  - 用户管理：数据管理、权限控制、后台操作
  - 聊天通信：实时通信、消息推送、社交互动

**2. 扩展需求不同**
- **用户管理**：
  - 扩展需求：数据持久化、权限精细化、后台管理
  - 技术特点：CRUD 操作、数据库查询、权限校验
- **聊天通信**：
  - 扩展需求：高并发 WebSocket、消息推送、实时性
  - 技术特点：WebSocket 连接管理、消息广播、缓存优化

**3. 耦合度高**
- 聊天功能与用户管理耦合，难以独立演进
- 如果未来需要：
  - 聊天服务独立扩展（聊天压力大）
  - 聊天服务独立部署（多区域部署）
  - 聊天服务技术升级（如引入消息队列）
  都会受到 system-service 的限制

**4. 故障影响范围大**
- 如果聊天功能异常，可能影响 system-service 的稳定性
- 如果 system-service 异常，聊天功能也会受影响

**5. 不符合微服务原则**
- 微服务原则：**单一职责**、**独立部署**、**独立扩展**
- 将聊天功能放在 system-service 违反了"单一职责"原则

#### 结论

**将聊天功能放在 system-service 不可行**，原因：
- ❌ 职责混乱，边界不清
- ❌ 扩展需求不同，难以兼顾
- ❌ 耦合度高，难以独立演进
- ❌ 故障影响范围大
- ❌ 不符合微服务原则

**必须独立 chat-service**

---

## 四、Chat 服务与前端交互

### 4.1 交互方式

#### 方式 1：WebSocket STOMP（实时消息）

**用途**：
- 发送消息（大厅、房间、私聊）
- 接收实时消息推送
- 订阅/取消订阅会话

**连接方式**：
- 前端通过 Gateway 连接：`ws://gateway:8080/chat-service/ws?access_token={token}`
- Gateway 路由到 chat-service

**消息流程**：
```
前端发送消息
  ↓ WebSocket STOMP (/app/chat.*)
chat-service 接收
  ↓ 处理（权限校验、敏感词过滤等）
  ↓ 广播到订阅者 (/topic/chat.*)
前端接收消息推送
```

#### 方式 2：REST API（历史消息、会话管理）

**用途**：
- 查询历史消息（大厅、房间、私聊）
- 查询会话列表
- 查询未读消息计数
- 标记消息已读

**接口路径**：
- 基础路径：`/api/chat`
- 通过 Gateway 路由到 chat-service

**请求流程**：
```
前端发起 HTTP 请求
  ↓ REST API (/api/chat/**)
Gateway 路由
  ↓ 转发到 chat-service
chat-service 处理
  ↓ 返回数据
前端接收响应
```

### 4.2 前端使用场景映射

| 前端场景 | 交互方式 | 说明 |
|---------|---------|------|
| 大厅聊天发送消息 | WebSocket STOMP | `/app/chat.lobby.send` |
| 大厅聊天接收消息 | WebSocket STOMP | 订阅 `/topic/chat.lobby` |
| 大厅聊天历史消息 | REST API | `GET /api/chat/lobby/messages` |
| 房间聊天发送消息 | WebSocket STOMP | `/app/chat.room.send` |
| 房间聊天接收消息 | WebSocket STOMP | 订阅 `/topic/chat.room.{roomId}` |
| 房间聊天历史消息 | REST API | `GET /api/chat/rooms/{roomId}/messages` |
| 私聊发送消息 | WebSocket STOMP | `/app/chat.private.send` |
| 私聊接收消息 | WebSocket STOMP | 订阅 `/topic/chat.private.{userId1}.{userId2}` |
| 私聊历史消息 | REST API | `GET /api/chat/private/{otherUserId}/messages` |
| 查询未读消息数 | REST API | `GET /api/chat/unread/count` |
| 系统通知接收 | WebSocket STOMP | 订阅 `/topic/chat.system.{userId}` |

---

## 五、Chat 服务与其他服务交互

### 5.1 与 system-service 交互

**交互方式**：同步调用（HTTP/Feign Client）+ 熔断降级

**用途**：
1. **查询用户信息**
   - 获取用户昵称、头像（用于消息显示）
   - 获取用户在线状态（用于显示"在线/离线"）
2. **查询用户权限**
   - 检查用户是否被禁言（用于消息发送权限校验）
   - 检查用户是否有管理员权限（用于禁言操作）

**交互特点**：
- **低耦合**：通过服务名调用（支持 K8s DNS），不硬编码 IP
- **容错处理**：添加熔断降级，system-service 不可用时返回默认值
- **性能优化**：缓存用户信息（Redis，TTL 5分钟），减少调用频率

**交互时机**：
- 用户发送消息时 → 查询用户信息（昵称、头像）
- 消息广播时 → 查询接收者在线状态
- 权限校验时 → 查询用户是否被禁言

### 5.2 与 game-service 交互

**交互方式**：Kafka 事件（异步解耦）+ 可选同步查询（Feign Client）

#### 方式 1：Kafka 事件（推荐，低耦合）

**用途**：
- **房间删除事件** → chat-service 自动清理房间聊天会话（必须）
- **房间成员加入事件** → chat-service 更新会话成员列表（必须）
- **房间成员离开事件** → chat-service 更新会话成员列表（必须）
- **房间创建事件** → chat-service 可选创建房间聊天会话（可选，建议按需创建）

**说明**：
- 房间聊天会话采用**按需创建**策略：第一次发送消息时创建，而不是房间创建时创建
- 这样可以节省资源，只创建实际使用的会话
- 但必须感知房间删除和成员变化，用于资源清理和权限控制

**交互特点**：
- **完全解耦**：game-service 发布事件，chat-service 订阅事件
- **异步处理**：不阻塞 game-service 的主流程
- **故障隔离**：chat-service 故障不影响 game-service

**交互时机**：
- game-service 创建房间时 → 发布 `RoomCreatedEvent`
- game-service 删除房间时 → 发布 `RoomDeletedEvent`
- game-service 玩家加入房间时 → 发布 `RoomMemberJoinedEvent`
- game-service 玩家离开房间时 → 发布 `RoomMemberLeftEvent`

#### 方式 2：同步查询（可选，用于实时校验）

**用途**：
- 查询房间成员列表（用于房间聊天权限校验）

**交互特点**：
- **低耦合**：通过服务名调用，添加熔断降级
- **性能优化**：缓存房间成员（Redis，TTL 30秒）

**交互时机**：
- 用户发送房间消息时 → 校验用户是否在房间内（可选，通常通过 Kafka 事件已同步）

### 5.3 与 gateway 交互

**交互方式**：WebSocket 路由

**用途**：
- Gateway 将前端的 WebSocket 连接路由到 chat-service

**路由规则**：
```
前端连接：ws://gateway:8080/chat-service/ws?access_token={token}
Gateway 路由：转发到 chat-service:8083/ws
```

**交互特点**：
- **透明路由**：Gateway 只负责路由，不处理业务逻辑
- **统一鉴权**：Gateway 验证 JWT，chat-service 接收已验证的用户身份

---

## 六、Chat 服务功能与职责细分

### 6.1 核心功能

#### 1. 消息收发
- **发送消息**：接收用户发送的消息（文本、图片、文件等）
- **广播消息**：将消息广播到订阅者（大厅、房间、私聊）
- **消息格式化**：统一消息格式（包含发送者信息、时间戳等）
- **消息验证**：验证消息内容（长度、类型等）

#### 2. 会话管理
- **创建会话**：自动创建聊天会话（大厅、房间、私聊）
- **查询会话**：查询用户参与的会话列表
- **管理成员**：管理会话成员（加入、离开、踢出）
- **会话生命周期**：管理会话的创建、更新、删除

#### 3. 消息持久化
- **近期消息存储**：Redis 存储（7天内的消息，用于快速加载）
- **历史消息归档**：PostgreSQL 存储（长期保存，用于历史查询）
- **消息检索**：支持全文搜索（未来功能）

#### 4. 权限控制
- **系统禁言**：管理员可以禁言用户（禁止发送消息）
  - **业务边界**：禁言功能属于 chat-service 的职责
  - **原因**：禁言是针对"聊天功能"的权限控制，与聊天业务紧密相关
  - **实现方式**：chat-service 维护禁言状态（Redis），发送消息时校验
- **敏感词过滤**：过滤敏感词汇（可选功能）
- **发送频率限制**：防止刷屏（如每分钟最多30条消息）

#### 5. 实时通知
- **新消息通知**：实时推送新消息到订阅者
- **未读消息计数**：
  - **私聊未读计数**：每个私聊会话独立计数（玩家与玩家私聊的留言计数）
  - **系统通知未读计数**：系统通知总数计数
  - **房间聊天**：通常不需要未读计数（实时显示）
  - **大厅聊天**：通常不需要未读计数（实时显示）
- **在线状态同步**：同步用户在线/离线状态（用于显示）

### 6.2 细分职责

#### 职责 1：私聊内容持久化存储
- **职责**：长期保存私聊消息，支持历史查询
- **存储策略**：
  - Redis：近期消息（7天）
  - PostgreSQL：历史消息（长期保存）
- **查询能力**：支持按时间范围、关键词查询

#### 职责 2：玩家与玩家私聊的留言计数
- **职责**：为每个私聊会话维护未读消息数
- **实现方式**：
  - 用户 A 发送消息给用户 B → 用户 B 的未读数 +1
  - 用户 B 查看消息 → 未读数清零
  - 用户 B 标记已读 → 未读数清零
- **存储位置**：Redis（实时计数）+ PostgreSQL（持久化）

#### 职责 3：系统通知的留言计数
- **职责**：维护用户未读的系统通知总数
- **实现方式**：
  - 系统发送通知 → 所有用户的未读数 +1
  - 用户查看通知 → 未读数清零
- **存储位置**：Redis（实时计数）+ PostgreSQL（持久化）

#### 职责 4：系统禁言
- **职责**：管理用户的禁言状态，禁止被禁言用户发送消息
- **实现方式**：
  - 管理员通过 system-service 或 chat-service 的 API 设置禁言
  - chat-service 维护禁言状态（Redis）
  - 发送消息时校验禁言状态
- **业务边界**：禁言功能属于 chat-service，因为它是针对"聊天功能"的权限控制

---

## 七、好友系统的归属讨论

### 7.1 好友系统的功能

根据数据库设计，好友系统包括：
- **好友关系管理**：添加好友、删除好友、拉黑
- **好友申请**：发送申请、接受/拒绝申请
- **好友列表查询**：查询用户的好友列表
- **好友分组**：好友分组管理

### 7.2 归属分析

#### 方案 A：放在 chat-service

**支持观点**：
- 好友系统是"社交域"功能，与聊天功能相关
- 私聊通常发生在好友之间
- 可以复用 chat-service 的基础设施

**反对观点**：
- 好友系统是"关系管理"，不是"消息通信"
- 好友系统可以独立演进（如好友推荐、好友动态等）
- 如果放在 chat-service，chat-service 职责过重

#### 方案 B：放在 system-service

**支持观点**：
- 好友关系是"用户数据"，属于用户域
- system-service 已有用户管理，可以统一管理用户相关数据
- 好友系统不需要实时通信能力

**反对观点**：
- system-service 职责是"用户管理"（注册、登录、权限），不是"社交关系"
- 好友系统是"社交域"功能，放在"用户域"不合适

#### 方案 C：独立 friend-service（推荐）

**支持观点**：
- 好友系统是独立的业务域（社交关系管理）
- 可以独立演进（好友推荐、好友动态、好友分组等）
- 符合微服务"单一职责"原则
- 符合蓝图规划（蓝图中有独立的 friend-service）

**实现方式**：
- 独立服务，负责好友关系的 CRUD
- chat-service 调用 friend-service 查询好友关系（用于私聊权限校验等）

### 7.3 建议

**好友系统应该独立为 friend-service**，原因：
- ✅ 职责清晰：好友关系管理是独立的业务域
- ✅ 独立演进：可以独立扩展（好友推荐、动态等）
- ✅ 符合蓝图：蓝图规划中就是独立服务
- ✅ 低耦合：chat-service 通过服务调用获取好友关系，不直接管理

**chat-service 与 friend-service 的关系**：
- chat-service **不管理**好友关系
- chat-service **可以查询**好友关系（通过 friend-service 的 API）
- 私聊功能可以**利用**好友关系（如"仅好友可私聊"的权限控制）

---

## 八、总结

### 8.1 Chat 服务的角色定位

- **业务域**：社交域核心服务
- **核心价值**：提供用户之间的实时沟通能力
- **服务性质**：业务服务（非基础设施服务）

### 8.2 使用场景

1. **对局房间内聊天**：房间内玩家实时交流
2. **私聊**：玩家之间点对点通信
3. **大厅广播**：全局频道，所有在线用户可见
4. **系统通知**：系统主动推送的通知（暂定属于 chat-service）

### 8.3 业务边界

- ✅ **负责**：消息收发、会话管理、消息持久化、权限控制（禁言）、实时通知、未读计数
- ❌ **不负责**：用户管理、房间管理、游戏逻辑、好友关系管理

### 8.4 为什么不能放在 system-service

- ❌ 职责混乱，边界不清
- ❌ 扩展需求不同，难以兼顾
- ❌ 耦合度高，难以独立演进
- ❌ 故障影响范围大
- ❌ 不符合微服务原则

### 8.5 交互方式

- **与前端**：WebSocket STOMP（实时）+ REST API（历史消息）
- **与 system-service**：同步调用（查询用户信息、权限）
- **与 game-service**：Kafka 事件（异步，房间生命周期）+ 可选同步查询（房间成员）
- **与 gateway**：WebSocket 路由

### 8.6 功能细分

- 私聊内容持久化存储
- 玩家与玩家私聊的留言计数
- 系统通知的留言计数
- 系统禁言（属于 chat-service 职责）

### 8.7 好友系统归属

- **建议**：独立为 friend-service
- **chat-service 与 friend-service**：chat-service 可以查询好友关系，但不管理好友关系
