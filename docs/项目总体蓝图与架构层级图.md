# 🎯 Game Hub 项目总体蓝图与架构层级图

> 文档目的：提供项目的最终目标形态、服务与功能蓝图，并结合现有代码给出可落地的架构层级视图（包含各服务核心类职责），便于后续统一规划与扩展。

---

## 1. 愿景与定位

- **产品定位**：国际化实时对战“小游戏平台”，涵盖棋牌、休闲竞技、益智对抗等多品类游戏，并提供统一的社交/运营能力中心。
- **核心价值**：
  - 玩家：一站式大厅、匹配、聊天室、个人成长体系、跨端无缝体验，能在多种小游戏间自由切换。
  - 运营：精细化用户管理、权限配置、在线会话监控、活动与内容投放，支持多游戏联动运营。
  - 技术：云原生微服务、统一身份鉴权、可观测性、快速接入“任意类型小游戏引擎”。

---

## 2. 目标业务蓝图（终态）

| 层级 | 服务 / 能力 | 关键职责 | 主要技术/协议 |
|------|-------------|----------|---------------|
| 体验层 | Web / Mobile BFF、前端 SPA | 游戏大厅、个人中心、后台控制台、观战、IM 面板 | React/Vue、WebSocket、REST |
| 接入层 | `gateway-service` | JWT 验证、WS 协商、路由、跨域、限流 | Spring Cloud Gateway, OAuth2 Resource Server |
| 身份域 | Keycloak / `auth-service` | 注册、登录、单点登录、社交登录、角色管理 | Keycloak, OpenID Connect |
| 会话域 | `session-common`, `session-kafka-notifier` | 记录在线会话、互踢通知、WS Session 映射 | Redis, Kafka |
| 游戏域 | `game-lobby-service`（规划）、`game-service-core`、`game-engine-<game>`（五子棋/象棋/卡牌/休闲竞技等） | 匹配/房间、规则裁定、倒计时、AI、战绩、玩法编排 | Spring Boot, STOMP, Redis, PostgreSQL |
| 社交域 | `chat-service`（规划） | 大厅/房间聊天、私聊、频道、消息持久化、禁言 | WebSocket, Kafka, Redis, MongoDB |
| 用户域 | `system-service` + `user-profile-service`（规划） | 用户档案、偏好、权限、后台操作、活动配置 | Spring Boot, PostgreSQL |
| 运营域 | `admin-console`, `analytics-service`（规划） | 菜单配置、实时在线、告警、BI 报表 | Grafana, ClickHouse/Elastic |
| 数据域 | `rating-service`, `record-service`, `assets-service` | Elo 评分、对局复盘、历史记录、资源存储 | PostgreSQL, MinIO/S3 |
| 基础设施 | Observability、CI/CD、配置中心、密钥管理 | 日志/Tracing/指标、自动化流水线、配置治理、密钥存储 | Prometheus, Grafana, OpenTelemetry, Jaeger, Loki, GitHub Actions, Vault/K8s Secret |

终态交互（简化）：
1. 玩家在前端完成 Keycloak 登录 → Gateway 验证 JWT → 注入用户上下文。
2. Lobby 根据玩家选择或匹配策略创建房间 → 路由至对应 `game-engine-<game>`（五子棋、休闲射击、卡牌等）→ 通过统一 WS Hub 推送状态。
3. Chat Service 复用房间、频道 ID，提供大厅/房间/私聊消息，对接不同游戏内的聊天组件。
4. System/Admin 服务实时查看在线会话（Session 服务 + Gateway 事件），对多游戏统一运营。
5. 所有事件通过 Kafka 广播到战绩、积分、BI 等订阅者，实现解耦扩展。

---

## 3. 功能地图与阶段成果

- **玩家旅程**：注册/登录 → 大厅浏览 → 匹配/建房 → 游戏内对战 + 房间聊天 → 结束后查看战绩/录像 → 个人主页（战绩、勋章、好友）。
- **社交旅程**：好友/关注 → 私聊/群聊 → 频道/战队 → 赛事聊天 → 房间内语音/文字扩展。
- **运营旅程**：后台登录 → 菜单/权限管理 → 查看在线会话/手动踢线 → 活动配置/公告 → 数据报表。

### 3.1 当前已完成功能

**前端（game-hub-web）**：
- ✅ React SPA 应用（Vite + React 19.2 + React Router 7.9）
- ✅ 首页（HomePage）：游戏推荐、进行中游戏提示
- ✅ 游戏大厅（LobbyPage）：创建房间、加入房间、房间列表、进入房间
- ✅ 游戏房间（GameRoomPage）：五子棋对局界面、实时通信、倒计时显示
- ✅ 会话监控页面（SessionMonitorPage）：调试用，查看在线会话
- ✅ Keycloak 认证集成：登录、登出、Token 刷新、路由保护
- ✅ WebSocket 实时通信：SockJS + STOMP，支持断线重连
- ✅ 进行中游戏追踪：OngoingGameContext，支持"继续游戏"功能

**后端服务**：
- ✅ **gateway**：JWT 验证、WebSocket 转发、OAuth2 客户端、会话管理、踢线功能、Token 黑名单
- ✅ **system-service**：用户管理（CRUD）、PostgreSQL 持久化、Keycloak 事件监听、会话监控 API、用户同步
- ✅ **game-service**：五子棋完整功能（PVP/PVE）、WebSocket 实时对局、倒计时系统、AI 引擎、房间管理、CAS 并发控制

**基础设施**：
- ✅ Redis：房间状态、游戏状态、会话管理、倒计时状态
- ✅ PostgreSQL：system-service 用户数据持久化（sys_user、sys_user_profile、sys_role、sys_permission 等）
- ✅ Kafka：会话事件发布/订阅（session-kafka-notifier）
- ✅ Docker Compose：本地开发环境配置（Keycloak、PostgreSQL、Redis、Kafka、各服务）

**认证与鉴权**：
- ✅ Keycloak 单点登录：OAuth2/OIDC 标准协议
- ✅ Gateway JWT 验证：统一入口鉴权
- ✅ WebSocket 认证：通过 URL 参数传递 token，后端验证
- ✅ 会话管理：登录会话注册、WebSocket 会话映射、多端互踢

### 3.2 未完成功能（规划中）

**服务**：
- ❌ **chat-service**：聊天服务（规划中），当前前端有 GlobalChat 组件但未接入后端
- ❌ **game-lobby-service**：匹配服务（规划中），当前 Lobby 功能内聚在 game-service
- ❌ **rating-service**：战绩服务（规划中），当前战绩只存在 Redis，未持久化
- ❌ **record-service**：对局记录服务（规划中），未实现复盘功能

**功能**：
- ❌ **匹配功能**：前端有占位 UI，后端未实现匹配算法
- ❌ **聊天功能**：前端有 GlobalChat 组件，后端未实现聊天服务
- ❌ **战绩持久化**：当前只存在 Redis，未写入 PostgreSQL
- ❌ **后台管理界面**：只有会话监控页面，缺少菜单/权限配置界面
- ❌ **可观测性**：Prometheus/Grafana 未接入，缺少指标监控
- ❌ **K8s 部署**：只有 Docker Compose，未配置 Kubernetes

**下一步优先项**：聊天室 MVP、匹配服务、战绩持久化、后台菜单/权限管理、可观测性接入。

---

## 4. 部署与数据流

### 4.1 当前部署状态

**开发环境（Docker Compose）**：
- ✅ **Keycloak**：身份认证服务（端口 8180）
- ✅ **PostgreSQL**：数据库（system-service 用户数据、Keycloak 数据）
- ✅ **Redis**：缓存与状态存储（房间、游戏状态、会话）
- ✅ **Kafka**：事件总线（会话事件）
- ✅ **gateway**：API 网关（端口 8080）
- ✅ **game-service**：游戏服务（端口 8081）
- ✅ **system-service**：用户服务（端口 8082）
- ✅ **game-hub-web**：前端应用（Vite dev server，端口 5173）

**生产环境**：
- ❌ Kubernetes 部署：未配置
- ❌ 可观测性：Prometheus/Grafana 未接入
- ❌ CI/CD：未配置自动化流水线

### 4.2 数据存储现状

**Redis**（已使用）：
- 房间元信息（RoomMeta）
- 游戏状态（GameStateRecord）
- 座位绑定（SeatsBinding）
- 倒计时状态（CountdownState）
- 会话注册表（SessionRegistry）
- 用户信息缓存（UserProfile）

**PostgreSQL**（已使用）：
- system-service：用户表（sys_user）、用户扩展表（sys_user_profile）、角色表（sys_role）、权限表（sys_permission）等
- Keycloak：认证相关表（由 Keycloak 自动管理）

**Kafka**（已使用）：
- 会话事件（SessionInvalidatedEvent）：登录、登出、踢线等事件

**未使用**：
- ❌ MongoDB：聊天历史（规划中）
- ❌ MinIO/S3：头像、棋谱文件（规划中）
- ❌ PostgreSQL 战绩表：对局记录、排行榜（规划中）

### 4.3 数据流规划（未来规划）

- **环境演进**：Dev（Docker Compose）→ Stage（K8s 多副本）→ Prod（跨区容灾）
- **数据持久化**：
  - PostgreSQL：用户、权限、战绩、聊天历史冷数据（或拓展 MongoDB）
  - MinIO/S3：头像、棋谱文件、活动素材
- **可观测性**：全链路 Trace、业务指标（活跃房间、WS 连接、消息吞吐）、安全审计（关键管理员操作）

---

## 5. 现有代码架构层级视图

### 5.1 模块总览

```
game-hub-parent/
├── apps/                  ← 后端服务
│   ├── gateway/           ← API & WS 接入层（JWT 验证、路由、会话管理）
│   ├── game-service/      ← 五子棋 + 通用倒计时（房间管理、游戏逻辑、WebSocket）
│   ├── system-service/    ← 用户服务（用户管理、权限、PostgreSQL 持久化）
│   └── pom.xml
├── libs/                  ← 共享库
│   ├── session-common/    ← 会话模型 + 注册表（Redis 实现）
│   ├── session-kafka-notifier/ ← 会话事件发布/订阅（Kafka）
│   └── web-common/        ← Web 通用组件（统一 API 响应格式、JWT 用户信息提取、Feign 鉴权）
├── docs/                  ← 架构/部署/数据库文档
├── docker-compose.yml     ← 本地开发环境（Keycloak、PostgreSQL、Redis、Kafka）
└── pom.xml

game-hub-web/              ← 前端应用（独立项目）
├── src/
│   ├── pages/             ← 页面组件（HomePage、LobbyPage、GameRoomPage 等）
│   ├── components/        ← 组件（Header、GlobalChat、ProtectedRoute 等）
│   ├── contexts/          ← React Context（AuthContext、OngoingGameContext）
│   ├── hooks/             ← 自定义 Hooks（useGomokuGame、useAuth 等）
│   └── services/          ← 服务层（api、ws、auth）
├── package.json
└── vite.config.js
```

**说明**：
- **后端**：三个核心服务（gateway、game-service、system-service）+ 三个共享库（session-common、session-kafka-notifier、web-common）
- **前端**：独立的 React SPA 应用（game-hub-web），通过 Gateway 访问后端 API
- **部署**：Docker Compose 支持本地开发，K8s 部署待配置

---

### 5.2 `apps/game-service` 架构与职责

#### 5.2.1 服务定位与包结构

**服务定位**：承载“所有棋类的规则与对局执行”。对外暴露游戏域 API/WS；不承载用户/权限/菜单/聊天等系统域能力。

**包结构**（当前实现）：
- `games/gomoku/`：五子棋（规则判定、AI、对局状态、WS 控制器、TurnClockCoordinator）
  - `interfaces/`：接口层（HTTP REST、WebSocket STOMP）
    - `http/`：HTTP REST 接口（`GomokuRestController`、`RoomListController`、`GomokuDebugController`）
    - `http/dto/`：HTTP 接口 DTO（`RoomListResponse`、`RoomSummary`）
    - `ws/`：WebSocket STOMP 接口（`GomokuWsController`、`GomokuResumeController`）
    - `ws/dto/`：WebSocket 消息 DTO（`GomokuMessages`、`ResumeMessages`）
  - `service/`：服务层（核心业务逻辑）
  - `domain/`：领域层（模型、规则、AI、仓储接口）
  - `application/`：应用编排层（倒计时协调器 `TurnClockCoordinator`）
  - `infrastructure/redis/`：Redis 实现（仓储实现、键规范）
- `clock/`：通用倒计时引擎（业务无关的 `CountdownScheduler` 与实现）
- `application/`：应用层（跨游戏通用服务，如用户目录服务 `UserDirectoryService`）
- `infrastructure/`：基础设施层
  - `client/`：外部服务客户端（`system/SystemUserClient`）
  - `redis/`：全局 Redis 基础设施（连接配置、工具类）
  - `scheduler/`：调度器配置（`AiSchedulerConfig`）
- `platform/`：平台层
  - `config/`：平台配置（Spring Security、OAuth2 Resource Server）
  - `ongoing/`：进行中游戏追踪（`OngoingGameTracker`、`OngoingGameInfo`）
  - `transport/`：传输层工具（`Envelope`、`MeController`、`OngoingGameController`）
  - `ws/`：WebSocket 配置与广播工具

**关键设计原则**：
- **倒计时**：作为通用引擎库，被各游戏的 `TurnClockCoordinator` 复用，不独立成服务。
- **AI**：按游戏内聚，各自放在 `games/{game}/domain/ai`；仅当需要独立扩缩容或特定算力（GPU）时再外拆。
- **鉴权**：严格依赖网关传入的用户身份（userId/roles），`game-service` 内以 userId 执行入场/坐席/落子授权；`seatKey` 仅用于刷新/恢复的辅助凭证。

#### 5.2.2 关键交互流程

**进入房间**：
- Gateway → game-service，携带用户身份（JWT 中的 userId）
- game-service 校验房主/成员/观战权限（通过 `resolveAndBindSide()` 分配座位）
- 如果提供 `seatKey`，通过 `bindBySeatKey()` 恢复座位绑定

**对局开始**：
- 当前实现：玩家通过 HTTP 创建房间，或通过 WebSocket 发送 `startGame` 消息
- 未来规划：Lobby 分配/创建房间 → game-service 初始化棋盘与倒计时锚点
- 初始化：创建空棋盘（`GameStateRecord`）、设置房间状态为 `WAITING`、初始化座位绑定

**落子流程**：
- WebSocket 消息 `/app/gomoku.place` → `GomokuWsController.place()`
- 鉴权：从 JWT 提取 `userId`，通过 `resolveAndBindSide()` 绑定座位
- 规则校验：验证房间状态（必须是 `PLAYING`）、回合（必须是当前执子方）、坐标合法性、禁手（RENJU 规则）
- 执行落子：`GomokuState.apply()` 更新棋盘
- 胜负判定：`GomokuJudge.outcomeAfterMove()` 判断是否结束
- CAS 保存：使用 `expectedStep`（棋子数量）和 `expectedTurn`（当前执子方）作为期望值，通过 Redis WATCH/MULTI/EXEC 原子更新
- 广播：同时发送 `STATE`（增量更新）和 `SNAPSHOT`（全量快照）事件到 `/topic/room.{roomId}`
- 同步倒计时：`TurnClockCoordinator.syncFromState()` 启动/续上倒计时

**PVE AI 落子**：
- 玩家落子后，如果轮到 AI，延迟 1-1.5 秒执行（使用 `aiScheduler` 线程池）
- 调用 `GomokuAI.bestMove()` 获取建议
- 执行 AI 落子（复用 `place()` 方法）
- **注意**：当前代码中 AI 落子的 CAS 条件使用硬编码 `Board.WHITE`（第429行），存在风险，应使用 `now.current()` 作为 `expectedTurn`

**终局与战绩**：
- 当前实现：game-service 更新比分（`incrSeriesOnFinish()`），重置准备状态，切换房间状态为 `WAITING`
- 未来规划：game-service 产生“对局结束事件”，由 Rating/Record 异步计算与存档

**聊天**：
- 当前实现：前端本地聊天（未接入后端）
- 未来规划：由 Chat 管理房间频道；game-service 仅作为事件源（如进入/退出/终局）

#### 5.2.3 数据与存储

**Redis 键空间设计**（五子棋）：
- **房间元信息**：`gomoku:room:{roomId}`（HASH，TTL 48小时）
- **游戏状态**：`gomoku:room:{roomId}:game:{gameId}:state`（HASH，TTL 48小时）
- **回合锚点**：`gomoku:room:{roomId}:turn`（HASH，TTL 动态，根据 deadline）
- **座位绑定**：`gomoku:room:{roomId}:seats`（HASH，TTL 48小时）
- **座位密钥**：`gomoku:room:{roomId}:seatKey:{seatKey}`（String，TTL 48小时）
- **用户信息缓存**：`gomoku:room:{roomId}:users`（HASH，TTL 30分钟）
- **系列赛统计**：`gomoku:room:{roomId}:series`（HASH，TTL 48小时）
- **房间索引**：`gomoku:rooms:index`（ZSET，score 为 createdAt，TTL 48小时）
- **用户进行中游戏**：`gomoku:user:{userId}:ongoing`（String，TTL 48小时）

**通用倒计时键空间**：
- **倒计时状态**：`countdown:{key}`（String，TTL 24小时）
- **倒计时 holder 锁**：`countdown:holder:{key}`（String，TTL 10秒，SETNX）

**序列化**：
- 当前实现：使用 JDK 序列化（`RedisTemplate` 默认）
- 计划：统一使用 JSON 序列化（跨版本/跨语言友好），显式管理 TTL 与清理

**幂等与一致性**：
- **对局状态更新**：使用 CAS（WATCH/MULTI/EXEC）保证期望步数/轮到方匹配；避免并发覆盖
- **倒计时超时**：使用分布式 holder 锁（SETNX+TTL），避免多节点重复执行超时回调

#### 5.2.4 一致性与并发策略

**对局写入（CAS 机制）**：
- 实现：使用 Redis WATCH/MULTI/EXEC 保证期望步数/轮到方匹配
- 期望值：`expectedStep`（当前棋子数量）、`expectedTurn`（当前执子方 'X'/'O'）
- 原子操作：同时更新 `GameStateRecord` 和 `TurnAnchor`（下一回合截止时间）
- 冲突处理：如果 EXEC 返回 null（事务冲突），视为更新失败，前端可重试

**倒计时并发控制**：
- **停止计时**：`stop()` 时删除状态键（`countdown:{key}`）与 holder 锁（`countdown:holder:{key}`），避免重启误恢复
- **恢复扫描**：当前实现使用 `redis.keys("countdown:*")`（第134行），存在阻塞风险，需要改用 SCAN 游标遍历
- **holder 锁**：TTL 10秒，回调完成后清理/幂等，避免多节点重复执行超时回调

**AI 执行并发控制**：
- **本地防抖**：使用 `ConcurrentHashMap<String, ScheduledFuture<?>> pendingAi`，同一房间只保留一个待执行的 AI 任务
- **分布式互斥**：当前实现缺少房间级分布式锁，多节点部署可能重复执行，需要实现 Redis SETNX（`ai:lock:{roomId}` + TTL）
- **CAS 条件**：当前实现 AI 落子使用硬编码 `Board.WHITE`（第429行），应使用 `now.current()` 作为 `expectedTurn`

#### 5.2.5 命名与约定

**Redis 键前缀**：
- 游戏域：`gomoku:`（五子棋相关键）
- 通用域：`countdown:`（倒计时引擎使用）
- 统一管理：通过 `RedisKeys` 类集中管理，避免字符串散落

**WebSocket 主题约定**：
- 房间广播：`/topic/room.{roomId}`（所有房间内玩家订阅）
- 点对点消息：
  - `/user/queue/gomoku.seat`：座位密钥（seatKey）推送
  - `/user/queue/gomoku.full`：完整同步（FullSync），用于刷新重入
  - `/user/queue/gomoku.kicked`：被踢事件

**代码注释规范**：
- 类/方法：Javadoc 注释
- 代码块：前行注释说明关键逻辑
- 内联注释：少量必要注释，避免过度注释

#### 5.2.6 类职责列表

| 包 / 类 | 功能定位 |
|---------|----------|
| `GameServiceApplication` | Spring Boot 启动入口，扫描全部游戏/平台组件。 |
| `clock.ClockAutoConfig` | 自动装配倒计时调度相关 Bean。 |
| `clock.ClockSchedulerConfig` | 配置调度线程池与任务属性。 |
| `clock.scheduler.CountdownScheduler` | 倒计时调度接口定义。 |
| `clock.scheduler.CountdownSchedulerImpl` | 倒计时实现，驱动房间计时。 |
| `application.user.UserDirectoryService` | 用户目录服务（游戏域调用用户域的统一入口，通过 Feign Client 调用 system-service）。 |
| `application.user.UserProfileView` | 用户档案视图 DTO。 |
| `common.WebExceptionAdvice` | 全局异常处理器，统一 HTTP 响应体。 |
| `engine.core.AiAdvisor` | AI 走法建议器，协调 Engine 模式。 |
| `engine.core.Command` | 引擎命令抽象（落子、撤销等）。 |
| `engine.core.EngineMode` | 引擎运行模式枚举（PVP/PVE）。 |
| `engine.core.GameState` | 通用对局状态载体。 |
| `games.gomoku.application.TurnClockCoordinator` | 处理五子棋轮次与倒计时协同。 |
| `games.gomoku.domain.ai.Evaluator` | 棋盘评分计算。 |
| `games.gomoku.domain.ai.GomokuAI` | 根据评估策略给出 AI 行动。 |
| `games.gomoku.domain.dto.AiIntent` | AI 请求/响应 DTO。 |
| `games.gomoku.domain.dto.GameStateRecord` | 保存/恢复棋局状态的数据对象。 |
| `games.gomoku.domain.dto.RoomMeta` | 房间元信息（配置、模式、双方）。 |
| `games.gomoku.domain.dto.RoomMetaConverter` | DTO 与实体/缓存之间转换。 |
| `games.gomoku.domain.dto.SeatsBinding` | 用户与座位绑定关系。 |
| `games.gomoku.domain.dto.TurnAnchor` | 记录当前轮次锚点。 |
| `games.gomoku.domain.enums.Mode` | 对局模式（PVP/PVE）。 |
| `games.gomoku.domain.enums.RoomPhase` | 房间阶段（等待、对战、结算）。 |
| `games.gomoku.domain.enums.Rule` | 规则集（自由、禁手等）。 |
| `games.gomoku.domain.model.Board` | 棋盘数据结构。 |
| `games.gomoku.domain.model.Game` | 聚合根，管理整局状态。 |
| `games.gomoku.domain.model.GomokuSnapshot` | 棋局快照。 |
| `games.gomoku.domain.model.GomokuState` | 当前棋局状态对象。 |
| `games.gomoku.domain.model.Move` | 单次落子记录。 |
| `games.gomoku.domain.model.Room` | 五子棋房间实体。 |
| `games.gomoku.domain.model.RoomView` | 房间视图（用于列表展示）。 |
| `games.gomoku.domain.model.SeriesView` | 连珠检测视图。 |
| `games.gomoku.domain.repository.AiIntentRepository` | AI 意图存取接口。 |
| `games.gomoku.domain.repository.GameStateRepository` | 棋局状态存储接口（支持 CAS）。 |
| `games.gomoku.domain.repository.RoomRepository` | 房间持久化接口。 |
| `games.gomoku.domain.repository.TurnRepository` | 轮次数据接口。 |
| `games.gomoku.domain.rule.GomokuJudge` | 胜负判定器（标准规则）。 |
| `games.gomoku.domain.rule.GomokuJudgeRenju` | 连珠规则判定实现。 |
| `games.gomoku.domain.rule.Outcome` | 对局结果枚举。 |
| `games.gomoku.infrastructure.redis.RedisKeys` | Redis Key 约定集合（统一管理键前缀）。 |
| `games.gomoku.infrastructure.redis.repo.RedisAiIntentRepository` | AI 意图 Redis 实现。 |
| `games.gomoku.infrastructure.redis.repo.RedisGameStateRepository` | 棋局状态 Redis 实现（支持 CAS）。 |
| `games.gomoku.infrastructure.redis.repo.RedisRoomRepository` | 房间 Redis 实现。 |
| `games.gomoku.infrastructure.redis.repo.RedisTurnRepository` | 轮次 Redis 实现。 |
| `games.gomoku.interfaces.http.GomokuDebugController` | 调试接口（开发用）。 |
| `games.gomoku.interfaces.http.GomokuRestController` | HTTP 接口（创建房间、同步状态等）。 |
| `games.gomoku.interfaces.http.RoomListController` | 房间列表接口（查询房间列表）。 |
| `games.gomoku.interfaces.ws.dto.GomokuMessages` | WS 消息载体（对局广播）。 |
| `games.gomoku.interfaces.ws.dto.ResumeMessages` | 断线重连消息体。 |
| `games.gomoku.interfaces.ws.GomokuResumeController` | 负责重连流程的 STOMP 端点。 |
| `games.gomoku.interfaces.ws.GomokuWsController` | 主 WS/STOMP 控制器（落子、房间事件）。 |
| `games.gomoku.service.GomokuService` | Service 接口。 |
| `games.gomoku.service.impl.GomokuServiceImpl` | 五子棋领域服务实现。 |
| `infrastructure.client.system.SystemUserClient` | System 服务客户端（Feign Client，调用 system-service 获取用户信息）。 |
| `infrastructure.redis.RedisConfig` | Redis 连接配置。 |
| `infrastructure.redis.RedisOps` | Redis 操作封装（CAS 等）。 |
| `infrastructure.scheduler.AiSchedulerConfig` | AI 任务调度器配置。 |
| `platform.config.SecurityConfig` | Spring Security / OAuth2 资源服务配置。 |
| `platform.ongoing.OngoingGameInfo` | 进行中游戏信息 DTO。 |
| `platform.ongoing.OngoingGameTracker` | 进行中游戏追踪器（记录/查询用户正在进行中的游戏）。 |
| `platform.transport.Envelope` | WebSocket 消息封包工具。 |
| `platform.transport.MeController` | "/me" 自检接口，返回当前用户信息。 |
| `platform.transport.OngoingGameController` | 进行中游戏接口（查询用户进行中的游戏）。 |
| `platform.ws.SessionInvalidatedListener` | 监听会话失效事件，通知 WS。 |
| `platform.ws.WebSocketAuthChannelInterceptor` | STOMP 鉴权拦截器，注入用户信息。 |
| `platform.ws.WebSocketDisconnectHelper` | 处理连接断开、清理状态。 |
| `platform.ws.WebSocketSessionManager` | 管理用户与 WS Session 映射。 |
| `platform.ws.WebSocketStompConfig` | 注册 STOMP 端点与消息代理。 |

---

### 5.3 `apps/gateway` 类职责

| 类 | 功能定位 |
|----|----------|
| `GatewayApplication` | 接入层启动入口。 |
| `config.SecurityConfig` | Spring Security、OAuth2 Resource Server 设置。 |
| `config.JwtDecoderConfig` | 配置 JWT 解码与公钥缓存。 |
| `config.OAuth2ClientConfig` | 管理调用 Keycloak 时的 Client 凭据。 |
| `config.KeycloakAdminProperties` | 读取 Keycloak 管理端配置。 |
| `config.KeycloakAdminConfig` | 构建 Keycloak Admin Client Bean。 |
| `controller.TokenController` | 暴露 Token 生成/刷新等辅助接口。 |
| `controller.SessionStateVerificationController` | 提供会话状态校验、互踢等接口。 |
| `filter.WebSocketTokenFilter` | WS 握手阶段校验 JWT 并注入 Header。 |
| `handler.LoginSessionKickHandler` | 接收后台“踢线”命令并下发。 |
| `service.JwtBlacklistService` | 维护已吊销 Token 列表。 |
| `service.KeycloakSsoLogoutService` | 调用 Keycloak 进行 SSO 登出。 |

---

### 5.4 `apps/system-service` 类职责

| 类 / 包 | 功能定位 |
|---------|----------|
| `SystemServiceApplication` | 后台服务启动入口。 |
| `common.Result` | 统一 API 响应封装。 |
| `config.KeycloakConfig` | Keycloak Admin Client 配置。 |
| `config.RestTemplateConfig` | 提供带鉴权的 `RestTemplate`。 |
| `config.SecurityConfig` | 后台接口鉴权（Spring Security）。 |
| `controller.AuthController` | 登录、刷新 Token、游客注册。 |
| `controller.internal.KeycloakEventController` | 接受 Keycloak 事件回调。 |
| `controller.SessionMonitorController` | 会话监控控制器（用于开发和调试，查看在线用户列表）。 |
| `controller.user.UserController` | 用户 CRUD、状态管理。 |
| `dto.keycloak.KeycloakEventPayload` | Keycloak 事件载体。 |
| `dto.request.CreateUserRequest` | 创建用户请求体。 |
| `dto.request.LoginRequest` | 登录请求体。 |
| `dto.request.UpdateUserRequest` | 更新用户请求体。 |
| `dto.response.TokenResponse` | 登录/刷新返回体。 |
| `dto.response.UserInfo` | 用户信息响应 DTO。 |
| `dto.response.UserSessionSnapshotWithUserInfo` | 带用户信息的会话快照（用于会话监控）。 |
| `entity.permission.SysPermission` | 系统权限实体。 |
| `entity.role.SysRole` | 角色实体。 |
| `entity.role.SysRolePermission` | 角色-权限关联。 |
| `entity.role.SysRolePermissionId` | 复合主键。 |
| `entity.role.SysUserRole` | 用户-角色关联。 |
| `entity.role.SysUserRoleId` | 复合主键。 |
| `entity.user.SysUser` | 系统用户实体。 |
| `entity.user.SysUserProfile` | 用户扩展资料。 |
| `exception.BusinessException` | 业务异常定义。 |
| `exception.GlobalExceptionHandler` | 全局异常拦截。 |
| `repository.permission.SysPermissionRepository` | 权限仓储。 |
| `repository.role.SysRoleRepository` | 角色仓储。 |
| `repository.role.SysRolePermissionRepository` | 角色-权限仓储。 |
| `repository.role.SysUserRoleRepository` | 用户-角色仓储。 |
| `repository.user.SysUserRepository` | 用户仓储。 |
| `repository.user.SysUserProfileRepository` | 用户档案仓储。 |
| `service.keycloak.KeycloakEventService` | 处理来自 Keycloak 的事件接口。 |
| `service.keycloak.impl.KeycloakEventServiceImpl` | 事件实现，落库/触发业务。 |
| `service.user.UserService` | 用户用例接口。 |
| `service.user.impl.UserServiceImpl` | 用户服务实现。 |

（`controller.role`、`service.role`、`service.security` 包当前为空，预留扩展。）

---

### 5.5 `libs/session-common`

| 类 | 功能定位 |
|----|----------|
| `SessionCommonAutoConfiguration` | Starter 自动装配入口。 |
| `SessionRedisConfig` | RedisTemplate & 序列化配置。 |
| `SessionRegistry` | 统一的会话注册表，记录在线状态。 |
| `event.SessionInvalidatedEvent` | 会话失效事件定义。 |
| `model.LoginSessionInfo` | 登录态信息。 |
| `model.SessionStatus` | 会话状态枚举。 |
| `model.UserSessionSnapshot` | 用户在线快照。 |
| `model.WebSocketSessionInfo` | WS Session 描述。 |

### 5.6 `libs/session-kafka-notifier`

| 类 | 功能定位 |
|----|----------|
| `config.SessionKafkaConfig` | Kafka Topic/Producer/Consumer 配置。 |
| `config.SessionKafkaNotifierAutoConfiguration` | Starter 自动装配。 |
| `listener.SessionEventConsumer` | 消费 Kafka 会话事件。 |
| `listener.SessionEventListener` | 监听 Spring 事件并转 Kafka。 |
| `publisher.SessionEventPublisher` | 封装事件发布。 |

### 5.7 `libs/web-common`

| 类 | 功能定位 |
|----|----------|
| `ApiResponse` | 统一 API 响应格式（record 类型，支持 success/error/badRequest/unauthorized/forbidden/notFound/conflict/serverError）。 |
| `CurrentUserHelper` | 当前用户信息提取工具类（从 JWT token 中提取 userId、username、nickname、email、角色等）。 |
| `CurrentUserInfo` | 当前用户信息 DTO（record 类型，包含 userId、username、nickname、email、realmRoles、clientRoles）。 |
| `feign.FeignAuthAutoConfiguration` | Feign 客户端鉴权自动配置（自动从当前请求提取 JWT Token 并添加到 Feign 请求 Header）。 |

**使用场景**：
- `ApiResponse`：game-service 和 system-service 的所有 HTTP 接口统一使用此格式返回
- `CurrentUserHelper`：从 `@AuthenticationPrincipal Jwt jwt` 参数中提取用户信息，避免重复代码
- `FeignAuthAutoConfiguration`：game-service 调用 system-service 时自动传递 JWT Token

### 5.7 后端技术路线（微服务与基础设施）


- **服务间同步通信**
  - **协议**：HTTP/JSON（REST 风格），由 `gateway` 统一接入鉴权与路由。
  - **客户端**：优先采用 **Spring Cloud OpenFeign** 或 WebClient（当前已有 `RestTemplate`，后续可平滑迁移到 Feign）。
  - **调用方式**：
    - `game-service` → `system-service`：通过 Feign Client / HTTP Client 调用 `/api/users/**` 等接口获取 `UserInfo`、管理后台用户。
    - 调用地址通过配置项注入，例如 `system-service.url`，支持本地（`http://localhost:8082`）、Docker Compose（`http://system-service:8082`）、K8s（`http://system-service`）三套环境切换。

- **服务发现与部署形态**
  - **不引入 Nacos / Eureka** 作为注册中心，服务发现交给运行平台：
    - 本地开发：各服务在 IDE 中以不同端口运行（`localhost:8080/8081/8082`），通过配置指定互调地址。
    - Docker Compose：利用容器内置 DNS（Service Name），如 `http://game-service:8081`、`http://system-service:8082`。
    - Kubernetes：使用 **K8s Service + DNS**，各服务通过 `http://game-service`、`http://system-service` 等 Service 名互相调用。
  - 这样代码层只依赖环境配置，不绑定任何特定的注册中心，实现更云原生的形态。

- **熔断 / 降级 / 重试**
  - 对标国内的 Sentinel，这里选用 **Resilience4j** 作为核心容错库。
  - 集成方式：通过 **Spring Cloud Circuit Breaker + Resilience4j**，在 Feign Client 或 Service 方法上使用注解（如 `@CircuitBreaker`、`@Retry`）实现：
    - 下游服务不可用时快速失败 + 友好降级（返回兜底用户信息 / 标记为“服务忙”）。
    - 对部分幂等读操作启用有限次重试，提升稳定性。
  - 熔断策略与阈值集中在配置中管理，便于线上调优。

- **配置中心与动态刷新**
  - **12-Factor 原则**：遵循 12-Factor App 理念，配置通过环境变量注入，不硬编码在代码中。
  - **配置管理方案**：
    - **开发/测试环境**：使用 **Spring Cloud Config Server + Git 仓库** 作为集中配置源，所有服务的 `application-*.yml` 统一存放在配置仓库，按 `应用名 + profile` 组织。
    - **生产环境（K8s）**：使用 **K8s ConfigMap/Secret** 管理配置，密钥等敏感信息存储在 Secret 中，普通配置存储在 ConfigMap 中。
    - **密钥管理（未来）**：接入 **Vault** 或使用 K8s Secret，替代 Nacos 存储敏感配置，提升安全性。
  - **动态刷新**：通过 **Spring Cloud Bus + Kafka** 实现配置变更广播：
    - 更新 Git 配置并刷新 Config Server 后，发送 Bus 事件，触发各服务 `/actuator/bus-refresh`。
    - 标记了 `@RefreshScope` 的 Bean（如下游服务 URL、开关位、限流配置等）可在不停机的情况下热更新。

- **异步事件与解耦**
  - 消息中间件：**Kafka** 已作为统一事件总线（Session 事件、未来的对局事件、积分变更等）。
  - 设计原则：
    - 同步调用用于“强一致 + 立即返回”的场景（创建房间、查询用户档案）。
    - 异步事件用于“可延迟的后置逻辑”（对局结束写战绩、更新积分/等级、发送通知）。
  - 通过 `session-kafka-notifier` 等 Starter，将会话/游戏事件转为 Kafka 消息，供后续统计/BI 服务订阅。

- **安全与鉴权**
  - 统一使用 **Keycloak + Spring Security OAuth2 Resource Server**：
    - `gateway` 校验 JWT、注入用户上下文，对下游服务做统一保护。
    - 后端服务（`game-service`、`system-service`）作为 Resource Server，解析来自 Gateway 的 JWT / Token Relay。

- **对象存储**
  - **MinIO (S3 兼容)**：用于存储头像、棋谱回放、活动素材等文件。
  - **优势**：S3 协议通用，可平滑迁移到 AWS S3、阿里云 OSS 等云存储服务。
  - **当前状态**：❌ 未实现，规划中。

- **CI/CD**
  - **GitHub Actions**：云原生构建与部署，展示国际化工程能力。
  - **流程**：代码提交 → 自动构建 Docker 镜像 → 推送到 Registry → 部署到环境（Docker Compose / K8s）。
  - **当前状态**：❌ 未实现，规划中。

- **总体风格与选型哲学**
  - **核心技术栈**：**Spring Boot + Spring Cloud Gateway + OpenFeign + Resilience4j + Spring Cloud Config + Kafka + Keycloak + PostgreSQL + Redis + K8s**。
  - **选型原则**：
    - 🧩 **标准优先**：遵循国际标准（OAuth2, OIDC, OpenTelemetry, K8s, S3），便于在海外面试场景中对齐预期。
    - 🚫 **去中心化依赖**：不依赖 Nacos / Apollo / Sentinel 等中心化组件，使用 K8s Service DNS + ConfigMap/Secret + 事件总线。
    - 🔄 **可替换**：Keycloak 可换成 Sa-Token / Spring Auth Server；Gateway 可换 Kong/Envoy；Config 可换 Nacos（但优先使用 K8s ConfigMap）。
    - 🌍 **云原生兼容**：全部组件可在 Kubernetes、Docker Compose 下运行。
    - 💡 **业务独立**：game-service 核心逻辑尽量不依赖基础设施，保持纯逻辑与可重用性。

---

## 6. 下一步改进计划

> 说明：本章节仅列出待完成的技术改进项，已完成的功能请参考"3.1 当前已完成功能"章节。

### 6.1 game-service 改进项

1. **修复与加固（P0）**：
   - ❌ **倒计时恢复改用 SCAN**：当前使用 `redis.keys()`（`CountdownSchedulerImpl.restoreAllActive()` 第134行），存在阻塞风险，需要改用 SCAN 游标遍历
   - ❌ **holder 锁 TTL 可配置**：当前硬编码 10 秒（`CountdownSchedulerImpl.tryAcquireHolder()` 第236行），需要外置化配置
   - ❌ **AI 执行分布式互斥**：当前只有本地防抖（`pendingAi` ConcurrentHashMap），缺少房间级分布式锁，多节点部署可能重复执行，需要实现 Redis SETNX（`ai:lock:{roomId}` + TTL）
   - ❌ **AI CAS 的 expectedTurn 修正**：当前硬编码 `Board.WHITE`（`GomokuWsController.runAiTurn()` 第429行），应使用 `now.current()` 作为 expectedTurn

2. **抽象通用房间模块（P1）**：
   - owner/成员/观战者+权限点
   - 与 Lobby 对接清晰（当前 Lobby 功能内聚在 game-service，未来可拆分）

3. **事件驱动（P1）**：
   - 对局开始/结束事件 → Rating/Record、Chat、通知等
   - 当前实现：game-service 直接更新比分，未来改为发布事件

4. **新棋类接入（P2）**：
   - 按包结构复用规则、AI、Coordinator 与通用倒计时
   - 在 `games/` 下创建新游戏目录（如 `games/chess/`），按相同结构组织代码

### 6.2 平台级改进项

1. **链路验收（P0）**：
   - **目标**：补齐部署/配置文档与自动化脚本，确保新人一键拉起即可复现
   - **当前状态**：✅ Keycloak→Gateway→game-service→Session 事件链路已打通，但缺少完整的部署文档

2. **聊天室 MVP（P0）**：
   - **目标**：抽象消息模型，落地大厅聊天 & 房间聊天（含消息持久化、禁言、WS 广播）；未来频道/私聊都在此基础上扩展
   - **当前状态**：❌ 前端有 GlobalChat 组件，但未接入后端

3. **后台治理（P1）**：
   - **目标**：补齐菜单/权限配置界面、审计日志，为运营提供最小闭环
   - **当前状态**：✅ 会话监控 API 已实现（`/internal/sessions`），✅ 踢线功能已实现，❌ 缺少菜单/权限配置界面

4. **服务拆分（P1）**：
   - **目标**：Lobby/Engine 分离，并沉淀 `game-engine-template`（房间、匹配、结算接口约定）以便快速孵化新小游戏
   - **当前状态**：Lobby 功能内聚在 game-service，匹配功能未实现

5. **数据持久化（P1）**：
   - **目标**：对局与聊天历史写入 PostgreSQL/MongoDB，开放战绩/排行榜/回放，为玩家档案与成长体系提供数据基座
   - **当前状态**：✅ system-service 用户数据已持久化到 PostgreSQL，❌ 对局记录未持久化

6. **可观测性与部署（P1）**：
   - **目标**：Docker Compose → K8s，多环境配置治理，Prometheus/Grafana + OpenTelemetry + Jaeger，形成统一监控告警
   - **观测体系**：
     - **指标监控（Prometheus）**：业务指标（`active_rooms` 活跃房间数、`active_clocks` 运行倒计时数、`timeouts_total` 超时判负次数、`reconnects_total` 断线重连次数、`ai_think_time_avg` AI 平均思考时长、`ws_connections_active` WebSocket 连接数）和系统指标（CPU、内存、GC 等）。
     - **链路追踪（Jaeger）**：全链路 Trace，追踪请求从 Gateway → game-service → Redis 的完整路径。
     - **日志聚合（Loki + Grafana）**：统一日志格式，便于排查和分析。
     - **可视化（Grafana）**：指标 Dashboard、告警规则、业务报表。
   - **当前状态**：✅ Docker Compose 已配置，❌ K8s 未配置，❌ Prometheus/Grafana 未接入，❌ OpenTelemetry/Jaeger 未接入

7. **扩展服务（P2）**：
   - **目标**：Chat 进阶（频道、私聊、战队）、Matchmaking、Rating、Analytics 及多游戏运营工具，支持活动、赛事与 BI
   - **当前状态**：❌ 未实现

---

## 7. 单人迭代路线（Demo 优先）

> 目标：先交付一个“可演示”的版本（登录→大厅→五子棋对战→基础后台），再循序渐进扩展，避免一次性铺开被拖垮。

### Phase A：可演示版本（1 人 · 2~3 周）
- **打通链路**：✅ 已完成 Keycloak 配置、Gateway/游戏服务启动脚本，`docker-compose up` 可访问大厅并完成一局五子棋。
- **极简大厅/对局体验**：✅ 已完成
  - ✅ 大厅支持创建房间（PVP/PVE）、房间列表、加入房间、通过房间 ID 进入
  - ✅ 对局页面：15x15 棋盘、实时落子、倒计时、准备/开始游戏、认输、离开房间
- **极简后台**：✅ 部分完成
  - ✅ 会话监控 API（`/internal/sessions`）：查看在线用户列表
  - ✅ 踢线功能：Gateway 提供踢线接口，支持强制下线
  - ❌ 后台管理界面：只有前端会话监控页面（SessionMonitorPage），缺少菜单/权限配置界面
- **展示素材**：✅ 可演示完整流程（登录→建房→加入→对战→后台踢线）

### Phase B：社交支撑（1 人 · 3~4 周）
- **聊天室 MVP**：❌ 未实现
  - **当前状态**：前端有 GlobalChat 组件，但未接入后端
  - **下一步**：实现公共大厅 + 房间聊天，消息先存 Redis（队列 + 近期历史），带禁言/屏蔽接口
- **玩家中心雏形**：❌ 未实现
  - **当前状态**：ProfilePage 为占位页面
  - **下一步**：`/me` 展示战绩/最近房间（先写 Mock/Redis 统计），为后续成长体系做入口

### Phase C：平台化演进（按需排期）
- **Lobby/Engine 拆分**：❌ 未实现
  - **当前状态**：Lobby 功能内聚在 game-service，匹配功能未实现
  - **下一步**：抽离匹配/房间服务，产出 `game-engine-template`，为第二款小游戏埋下钩子
- **战绩 & 数据**：❌ 未实现
  - **当前状态**：战绩只存在 Redis，未持久化
  - **下一步**：补 PostgreSQL schema，落地对局记录、排行榜 API
- **可观测性/部署**：❌ 未实现
  - **当前状态**：只有 Docker Compose，未配置 K8s，未接入 Prometheus/Grafana
  - **下一步**：加入 Prometheus/Grafana，完善 CI/CD（GitHub Actions + Docker Registry），再考虑更多游戏、频道聊天、运营工具

> 若时间紧张，可在 Phase A 结束后先对外展示，后续按 Phase B/C 的优先级逐条拉取，保持每一步都有可交付结果。

> 通过以上蓝图与现状映射，可以确保“系统级架子”先行，社交与游戏能力在统一平台下演进，避免重复造轮子与后期大规模重构。


