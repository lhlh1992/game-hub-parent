# Game Hub 项目风险清单与示例

> **文档范围**：覆盖整个 `game-hub-parent` 项目的风险识别，包括 Gateway、Game-service、System-service、Chat-service、前端、基础设施及跨服务风险。

---

## 一、Gateway 服务风险

### 1.1 JWT 黑名单性能瓶颈
- **风险等级**：🟡 **一般**（高并发触发）
- **触发条件**：**2000+ QPS** 时开始出现性能瓶颈
- **风险**：每次请求都要查询 Redis 黑名单，高并发下成为性能瓶颈。
- **现状评估**：当前配置（16 个 Redis 连接，本地 Redis）在 **500 QPS 以内完全够用**，连接池使用率约 1.25%，延迟 < 1ms。**2000+ QPS 时建议优化**。
- **示例**：2000+ QPS 时，每秒 4000+ 次 Redis 查询，可能导致 Redis 连接池排队或响应延迟。
- **改进**（仅在 QPS > 2000 时考虑）：
  - 使用本地缓存（Caffeine）缓存黑名单，定期刷新。
  - 或使用布隆过滤器（Bloom Filter）快速过滤，减少 Redis 查询。

### 1.2 会话状态检查性能问题
- **风险等级**：🟡 **一般**（高并发触发）
- **触发条件**：**2000+ QPS** 时开始出现性能瓶颈
- **风险**：JWT 验证时同步查询 `SessionRegistry`，阻塞请求处理。
- **现状评估**：与黑名单查询类似，**500 QPS 以内性能足够**。**2000+ QPS 时建议优化**。
- **示例**：2000+ QPS 时，`checkSessionStatus()` 在 JWT 解码器中同步查询 Redis，延迟累积。
- **改进**（仅在 QPS > 2000 时考虑）：
  - 异步查询会话状态，或使用响应式编程优化。
  - 或将会话状态信息编码到 JWT Claims 中，减少查询。

### 1.3 WebSocket 认证 Token 传递安全
- **风险等级**：🟠 **严重**（安全风险，随时触发）
- **触发条件**：**随时触发**（日志记录、抓包等场景）
- **风险**：WebSocket 握手时通过 URL 参数传递 token，可能被日志记录或泄露。
- **示例**：`WebSocketTokenFilter` 从 URL 参数提取 `access_token`，访问日志可能记录完整 URL。
- **改进**：
  - 使用 WebSocket 子协议传递 token。
  - 或使用一次性握手 token，握手后立即失效。

### 1.4 Keycloak 连接失败降级策略缺失
- **风险等级**：🔴 **致命**（基础设施故障触发）
- **触发条件**：**Keycloak 宕机或网络中断**时触发
- **风险**：Keycloak 不可用时，Gateway 无法验证 JWT，导致所有请求被拒绝。
- **示例**：Keycloak 宕机或网络中断，`issuer-uri` 无法访问，JWT 验证失败。
- **改进**：
  - 实现 JWT 公钥缓存，Keycloak 不可用时使用缓存公钥验证。
  - 或实现降级策略，允许配置的"紧急白名单"通过。

### 1.5 路由配置硬编码
- **风险等级**：🟢 **轻微**（运维优化项）
- **触发条件**：**需要动态调整路由时**触发
- **风险**：路由规则硬编码在 `application.yml`，无法动态调整。
- **示例**：需要灰度发布或 A/B 测试时，必须重启服务修改配置。
- **改进**：
  - 使用 Spring Cloud Config 或 Nacos 动态配置路由。
  - 或实现路由规则 API，支持动态更新。

---

## 二、Game-service 服务风险

### 2.1 多节点一致性与互斥
- **风险等级**：🟠 **严重**（多节点 + 并发触发）
- **触发条件**：**多实例部署 + 同一房间并发操作**时触发
- **风险**：同一房间的关键动作（AI 落子、玩家落子应用）在多台实例上并发执行，出现"双落子"或状态竞争。
- **示例**：两台节点都判断"轮到 AI"，各自本地调度 AI 任务并执行 → 两次 AI 落子同时发生，最终只一方成功持久化，另一方内存短暂不一致。
- **改进**：
  - AI 执行前加房间级分布式短锁（SETNX `ai:lock:{roomId}` + TTL）。
  - 或者对同一房间做"单房间单节点路由"。
  - place 失败（CAS 冲突）后立即回读 Redis 刷新内存。

### 2.2 倒计时恢复误触发
- **风险等级**：🟡 **一般**（服务重启触发）
- **触发条件**：**服务重启时**触发（已修复，风险降低）
- **风险**：停止计时后若未清理 Redis 键，重启恢复会把已停任务当作活跃任务恢复。
- **示例**：上一盘停止计时但 Redis 仍有 `countdown:{key}`，服务重启后 `restoreAllActive` 重新调度。
- **现状**：`stop()` 已增加删除 `stateKey/holderKey`，风险已降低。

### 2.3 恢复扫描使用 KEYS
- **风险等级**：🟡 **一般**（数据量触发）
- **触发条件**：**Redis 键空间 > 10万** 时开始阻塞
- **风险**：`redis.keys("countdown:*")` 在生产上阻塞、不可扩展。
- **示例**：键空间大时 KEYS 会卡住 Redis，影响全局读写。
- **改进**：改用 SCAN 游标遍历或维护活跃集合。

### 2.4 AI 分支 CAS 条件硬编码
- **风险等级**：🟠 **严重**（逻辑错误，随时触发）
- **触发条件**：**AI 执黑棋时**触发（逻辑错误）
- **风险**：AI 持久化使用固定 `expectedTurn=WHITE`，与实际回合不符时 CAS 失败，导致前端状态滞后。
- **示例**：AI 实为黑棋回合，但 CAS 期望写白方 → updateAtomically 返回失败，广播和存储出现不一致。
- **改进**：使用 `now.current()` 作为 expectedTurn。

### 2.5 回合锚点缺少 TTL/清理
- **风险等级**：🟡 **一般**（数据残留触发）
- **触发条件**：**游戏结束后未清理**时触发
- **风险**：`turnKey` 无 TTL 时可能残留旧锚点，快照或恢复读取混淆。
- **示例**：终局后未清理 `gomoku:turn:{roomId}`，新局或恢复读取到旧的截止时间。
- **改进**：设置合理 TTL，或在终局/重开/stop 时显式删除。

### 2.6 内存与 Redis 短暂不一致窗口
- **风险等级**：🟠 **严重**（多节点 + 并发触发）
- **触发条件**：**多实例部署 + 同一房间并发落子**时触发
- **风险**：流程为"内存 Room 先变更 → Redis CAS"，并发下另一节点也变更内存 → 一方 CAS 失败，但内存已被改写。
- **示例**：两个节点几乎同时 place，失败方需主动回读 Redis，否则后续逻辑用到脏内存。
- **改进**：place 后 CAS 失败立即强制回读刷新；或将关键变更下沉为 Redis/Lua 原子操作。

### 2.7 用户鉴权遗留问题
- **风险等级**：🟢 **轻微**（已基本实现，仅遗留命名问题）
- **触发条件**：**seatKey 泄露且被恶意使用**时可能触发（风险已降低）
- **现状**：座位绑定已使用 `userId`（从 Gateway JWT 中提取），主要鉴权基于 userId。
- **遗留问题**：
  - `SeatsBinding` 字段名仍为 `seatXSessionId`/`seatOSessionId`（历史命名，实际存储 userId）。
  - `seatKey` 仍存在，主要用于刷新重连恢复，理论上泄露后可能被误用。
- **改进**（可选优化）：
  - 重命名 `SeatsBinding` 字段为 `seatXUserId`/`seatOUserId`，提高代码可读性。
  - 或完全移除 `seatKey`，改用基于 userId 的恢复机制。

### 2.8 WebSocket 广播顺序与幂等
- **风险等级**：🟡 **一般**（并发触发）
- **触发条件**：**并发广播**时触发
- **风险**：并发广播 STATE/SNAPSHOT 时序被打乱或重复。
- **示例**：客户端先收到旧 STATE 后收到新 SNAPSHOT，短暂错乱。
- **改进**：在服务端保证广播顺序；客户端按 `gameId/step` 幂等覆盖展示。

### 2.9 配置与阈值可调性
- **风险等级**：🟢 **轻微**（运维优化项）
- **触发条件**：**需要按环境调优时**触发
- **风险**：holder 锁 TTL、AI 延迟、倒计时 TTL 等写死，难以按环境调优。
- **改进**：外置化配置，可按环境/场景覆盖。

---

## 三、System-service 服务风险

### 3.1 Keycloak 事件处理失败
- **风险等级**：🔴 **致命**（事件处理失败触发）
- **触发条件**：**Keycloak 事件回调时数据库异常或网络中断**时触发
- **风险**：Keycloak 事件回调失败时，用户注册信息未同步到系统数据库。
- **示例**：`KeycloakEventController` 接收注册事件，但 `KeycloakEventServiceImpl` 处理失败（数据库异常、网络中断），用户无法登录系统。
- **改进**：
  - 实现事件重试机制（Kafka 或本地队列）。
  - 或定期同步 Keycloak 用户到系统数据库。

### 3.2 用户同步一致性
- **风险等级**：🟠 **严重**（数据不一致，随时触发）
- **触发条件**：**Keycloak 与系统数据库手动操作不一致**时触发
- **风险**：Keycloak 与系统数据库用户信息不一致，导致登录失败或权限错误。
- **示例**：Keycloak 中用户已删除，但系统数据库中仍存在，或反之。
- **改进**：
  - 实现双向同步机制。
  - 或使用 Keycloak 作为唯一数据源，系统数据库仅做缓存。

### 3.3 Keycloak Admin API 调用失败
- **风险等级**：🟠 **严重**（API 调用失败触发）
- **触发条件**：**调用 Keycloak Admin API 时网络异常或 Keycloak 不可用**时触发
- **风险**：调用 Keycloak Admin API 创建/更新用户时失败，但系统数据库已更新，导致数据不一致。
- **示例**：`UserServiceImpl.createUser()` 先更新系统数据库，再调用 Keycloak API 失败，回滚困难。
- **改进**：
  - 使用 Saga 模式或补偿事务。
  - 或先调用 Keycloak，成功后再更新系统数据库。

### 3.4 数据库事务边界不清晰
- **风险等级**：🟠 **严重**（事务失败触发）
- **触发条件**：**复杂业务操作部分失败**时触发
- **风险**：复杂业务操作（创建用户+分配角色+初始化权限）事务边界不清晰，部分失败导致数据不一致。
- **示例**：创建用户成功，分配角色失败，用户处于中间状态。
- **改进**：
  - 明确事务边界，使用 `@Transactional` 标注。
  - 或使用领域事件，异步处理非关键操作。

### 3.5 软删除数据残留
- **风险等级**：🟡 **一般**（数据量触发）
- **触发条件**：**已删除数据 > 10万条** 时开始影响性能
- **风险**：使用软删除（`deleted_at`）时，数据长期残留，影响查询性能和存储空间。
- **示例**：大量已删除用户记录占用数据库空间，查询时需要过滤 `deleted_at IS NULL`。
- **改进**：
  - 定期清理软删除数据（归档或物理删除）。
  - 或使用分区表，将已删除数据迁移到归档分区。

---

## 四、Chat-service 服务风险

### 4.1 消息持久化失败
- **风险等级**：🟠 **严重**（数据丢失，随时触发）
- **触发条件**：**PostgreSQL 写入失败或 Redis 写入失败**时触发
- **风险**：消息发送成功但持久化失败，导致历史消息丢失。
- **示例**：
  - 房间消息：`ChatHistoryService.appendRoomMessage()` 写入 Redis 失败，消息无法恢复。
  - 私聊消息：`ChatSessionServiceImpl.savePrivateMessage()` 写入 PostgreSQL 失败，消息无法恢复。
- **现状评估**：
  - 房间消息只写入 Redis（无事务保证），Redis 写入失败时消息丢失。
  - 私聊消息写入 PostgreSQL（有事务保证），但 Redis 缓存写入失败时可能不一致。
- **改进**：
  - 实现消息持久化重试机制。
  - 或使用事务保证 Redis 和 PostgreSQL 的一致性（房间消息也需要持久化到 PostgreSQL）。

### 4.2 系统通知推送失败
- **风险等级**：🟢 **轻微**（已缓解）
- **触发条件**：**system-service 调用 chat-service 推送通知失败**时触发
- **风险**：system-service 通过 Feign 调用 chat-service 推送通知失败，用户无法收到实时通知。
- **示例**：`ChatNotifyClient.push()` 调用失败（网络异常、服务不可用），通知已落库但未实时推送。
- **现状评估**：✅ 已实现降级策略（`ChatNotifyClientFallback`），推送失败仅记录日志，不影响主事务。通知已落库，用户可离线查看。风险已缓解。
- **改进**：
  - ✅ 当前实现已足够（降级策略 + 通知落库），无需额外改进。
  - 或实现通知推送重试机制（Kafka 队列）。

### 4.3 用户信息缓存不一致
- **风险等级**：🟢 **轻微**（已解决）
- **触发条件**：**用户信息更新但缓存未刷新**时触发
- **风险**：chat-service 使用 Redis 缓存用户信息，用户信息更新后缓存未刷新，显示旧信息。
- **示例**：用户更新昵称，system-service 刷新了缓存，但 chat-service 的缓存未刷新，聊天消息显示旧昵称。
- **现状评估**：✅ chat-service 和 system-service 使用相同的 Redis（database 0）和缓存 Key 格式（`user:profile:{keycloakUserId}`），system-service 更新缓存后 chat-service 可立即看到，风险已解决。
- **改进**：
  - ✅ 当前实现已足够（共享缓存），无需额外改进。
  - 或实现缓存失效通知机制（Kafka 事件）。

### 4.4 WebSocket 连接数限制
- **风险等级**：🟡 **一般**（连接数触发）
- **触发条件**：**单机 WebSocket 连接数 > 50000** 时开始受限
- **风险**：单机 WebSocket 连接数有限，无法支持大规模并发。
- **示例**：单机最多支持 65535 个连接，超过后新连接失败。
- **现状评估**：chat-service 和 game-service 都使用 WebSocket，连接数限制是共享的。
- **改进**：
  - 使用负载均衡，分散连接。
  - 或使用 WebSocket 集群，通过 Redis 共享会话。

### 4.5 私聊消息幂等性
- **风险等级**：🟢 **轻微**（已解决）
- **触发条件**：**客户端重复发送或网络重传**时触发
- **风险**：客户端重复发送消息，导致消息重复存储。
- **现状评估**：✅ 已实现基于 `clientOpId` 的幂等性检查（`ChatSessionServiceImpl.savePrivateMessage()` 第100-105行），重复消息会被过滤，抛出 `IllegalStateException`。
- **改进**：
  - ✅ 当前实现已足够（幂等性检查），无需额外改进。

### 4.6 消息历史查询性能
- **风险等级**：🟡 **一般**（数据量触发）
- **触发条件**：**历史消息 > 10万条** 时开始影响性能
- **风险**：查询大量历史消息时，数据库查询性能下降。
- **示例**：私聊历史查询 `limit=1000`，数据库需要扫描大量数据。
- **改进**：
  - 使用分页查询，限制单次查询数量。
  - 或使用 Redis 缓存近期消息，减少数据库查询。

### 4.7 房间事件订阅失败
- **风险等级**：🟢 **轻微**（功能降级，Kafka 异常触发）
- **触发条件**：**Kafka 不可用或订阅失败**时触发
- **风险**：chat-service 订阅 game-service 的房间事件失败，无法自动创建/删除房间聊天会话。
- **示例**：Kafka 不可用，`RoomEventConsumer` 无法接收房间事件，房间聊天功能降级（需手动创建会话）。
- **改进**：
  - 实现房间事件订阅重试机制。
  - 或提供手动创建房间会话的 API。

### 4.8 私聊好友关系验证降级安全风险
- **风险等级**：🟠 **严重**（安全风险，system-service 不可用触发）
- **触发条件**：**system-service 不可用或好友关系验证失败**时触发
- **风险**：私聊消息发送时验证好友关系失败，降级策略允许发送（`SystemUserClientFallback.isFriend()` 返回 `ApiResponse.success(true)`），可能导致非好友之间可以发送私聊消息。
- **示例**：system-service 不可用，`ChatMessagingServiceImpl.sendPrivateMessage()` 调用 `systemUserClient.isFriend()` 失败，降级为允许发送，非好友用户可以发送私聊消息。
- **现状评估**：当前实现为了可用性，在 system-service 不可用时允许发送（`SystemUserClientFallback.isFriend()` 第27行返回 `ApiResponse.success(true)`，代码注释：生产环境建议改为 `return ApiResponse.success(false)`，确保安全性）。
- **改进**：
  - 生产环境将降级策略改为 `return ApiResponse.success(false)`，确保安全性。
  - 或实现本地缓存好友关系，system-service 不可用时使用缓存验证。

---

## 五、前端（game-hub-web）风险

> **注意**：前端风险章节编号从 5.1 开始，与 chat-service 风险章节（四）区分。

### 5.1 Token 刷新失败处理
- **风险等级**：🟡 **一般**（网络异常触发）
- **触发条件**：**Token 过期时网络异常或 Gateway 不可用**时触发
- **风险**：Token 过期时自动刷新失败，用户被强制登出，体验差。
- **示例**：`authService.ensureAuthenticated()` 刷新 token 失败，用户正在游戏中被迫登出。
- **改进**：
  - 实现重试机制，多次失败后再登出。
  - 或使用 WebSocket 心跳检测，提前刷新 token。

### 5.2 WebSocket 重连状态丢失
- **风险等级**：🟡 **一般**（网络中断触发）
- **触发条件**：**WebSocket 断线重连**时触发
- **风险**：WebSocket 断线重连后，游戏状态未同步，用户看到错误状态。
- **示例**：网络中断后重连，`GomokuResumeController` 返回的 `FullSync` 数据不完整。
- **改进**：
  - 重连时强制请求完整状态快照。
  - 或维护本地状态缓存，重连后对比差异。

### 5.3 并发请求竞态条件
- **风险等级**：🟡 **一般**（用户快速操作触发）
- **触发条件**：**用户快速连续操作**时触发
- **风险**：多个 API 请求并发执行，响应顺序不确定，导致状态错乱。
- **示例**：创建房间和加入房间同时发起，可能创建失败但加入成功，或反之。
- **改进**：
  - 使用请求队列，串行化关键操作。
  - 或使用乐观锁，客户端处理冲突。

### 5.4 内存泄漏
- **风险等级**：🟡 **一般**（长时间运行触发）
- **触发条件**：**长时间运行或频繁切换页面**时触发
- **风险**：WebSocket 订阅、定时器、事件监听器未清理，导致内存泄漏。
- **示例**：`useGomokuGame` Hook 中订阅 WebSocket，组件卸载时未取消订阅。
- **改进**：
  - 使用 `useEffect` 清理函数，确保资源释放。
  - 或使用 React 18+ 的 `useSyncExternalStore` 管理外部状态。

---

## 六、基础设施风险

> **注意**：基础设施风险章节编号从 6.1 开始，与前端风险章节（五）区分。

### 6.1 Redis 单点故障
- **风险等级**：🔴 **致命**（基础设施故障触发）
- **触发条件**：**Redis 宕机**时触发
- **风险**：Redis 单点故障导致所有服务不可用（会话、游戏状态、倒计时）。
- **示例**：Redis 宕机，Gateway 无法验证会话，Game-service 无法读取游戏状态。
- **改进**：
  - 使用 Redis Sentinel 或 Cluster 实现高可用。
  - 或实现降级策略，关键数据写入数据库。

### 6.2 PostgreSQL 数据一致性
- **风险等级**：🟠 **严重**（主从延迟触发）
- **触发条件**：**主从延迟 > 1秒** 时触发
- **风险**：数据库主从延迟或事务隔离级别不当，导致数据不一致。
- **示例**：主库写入用户，从库未同步，查询从库时用户不存在。
- **改进**：
  - 关键操作强制读主库。
  - 或使用分布式事务（Seata）保证一致性。

### 6.3 Kafka 消息丢失
- **风险等级**：🟠 **严重**（消息丢失触发）
- **触发条件**：**Kafka 未配置持久化或副本**时触发
- **风险**：Kafka 消息丢失导致会话事件未通知下游服务。
- **示例**：用户登出事件丢失，其他服务仍认为用户在线。
- **改进**：
  - 配置 Kafka 持久化和副本。
  - 或实现消息确认机制，确保消息送达。

### 6.4 Keycloak 可用性
- **风险等级**：🔴 **致命**（基础设施故障触发）
- **触发条件**：**Keycloak 宕机或网络中断**时触发
- **风险**：Keycloak 不可用导致所有用户无法登录。
- **示例**：Keycloak 宕机或网络中断，Gateway 无法验证 JWT。
- **改进**：
  - 实现 Keycloak 集群。
  - 或使用 JWT 公钥缓存，短期不可用时使用缓存验证。

### 6.5 Docker Compose 单机部署限制
- **风险等级**：🟡 **一般**（资源耗尽触发）
- **触发条件**：**单机资源耗尽或需要水平扩展**时触发
- **风险**：当前使用 Docker Compose 单机部署，无法水平扩展。
- **示例**：单机资源耗尽，无法通过增加节点扩容。
- **改进**：
  - 迁移到 Kubernetes，支持水平扩展。
  - 或使用 Docker Swarm 实现多节点部署。

---

## 七、跨服务风险

> **注意**：跨服务风险章节编号从 7.1 开始，与基础设施风险章节（六）区分。

### 7.1 服务间调用失败
- **风险等级**：🟢 **轻微**（已缓解）
- **触发条件**：**下游服务不可用或网络异常**时触发
- **风险**：服务间调用失败，导致功能降级或失败。
- **示例**：
  - Game-service 调用 System-service 失败，用户信息获取失败。
  - System-service 调用 Chat-service 推送通知失败，通知已落库但未实时推送。
  - Chat-service 调用 System-service 获取用户信息失败，使用缓存数据。
- **现状评估**：
  - ✅ Game-service → System-service：已实现 Resilience4j 熔断（`SystemUserClient`），使用缓存降级。
  - ✅ System-service → Chat-service：已实现降级策略（`ChatNotifyClientFallback`），推送失败不影响主事务，通知已落库。
  - ✅ Chat-service → System-service：已实现 Resilience4j 熔断（`SystemUserClient`），使用缓存降级。
  - **风险已缓解**：所有服务间调用都已实现熔断/降级策略。
- **改进**：
  - ✅ 当前实现已足够（熔断 + 降级），无需额外改进。
  - 或实现更细粒度的重试策略。

### 7.2 事件丢失或重复
- **风险等级**：🟠 **严重**（Kafka 异常触发）
- **触发条件**：**Kafka 消息丢失或重复消费**时触发
- **风险**：Kafka 事件丢失或重复消费，导致数据不一致。
- **示例**：会话失效事件丢失，Gateway 未清理会话，用户仍可访问。
- **改进**：
  - 生产端开启幂等生产（`enable.idempotence=true`）+ `acks=all`，确保不会因重试产生重复消息；
  - 消费端为每个事件设计唯一 `eventId`（如 `userId + loginSessionId + timestamp`），在 Redis/数据库中记录已处理事件，实现幂等消费（重复事件直接跳过）；
  - 对纯幂等操作（如断开 WebSocket 连接）可以继续依赖业务幂等，但为未来可能挂载的非幂等逻辑（记战绩/发奖等）预留事件去重机制；
  - 或使用事件溯源，通过事件重建状态。

### 7.3 幂等性设计不统一（HTTP / WebSocket / Kafka）
- **风险等级**：🟡 **一般**（网络抖动 / 重试触发）
- **触发条件**：**HTTP/WS 请求超时重试、浏览器刷新/多 Tab、多设备同时操作、Kafka 重试/重平衡**时触发
- **风险**：
  - 不同层面的幂等策略零散分布（CAS、`clientOpId`、Kafka 幂等生产），缺少统一设计，在高并发或多实例部署下，容易出现：
    - HTTP 接口重复创建资源（重复房间、重复好友申请）；
    - WS 指令（ready/start/kick 等）在断线重连后重复执行，导致状态抖动；
    - Kafka 事件在重试/重平衡后被重复消费，未来挂载非幂等逻辑时存在重复执行风险。
- **现状评估**：
  - **状态幂等（Game / Redis）**：落子依赖 Redis CAS（`expectedStep + expectedTurn`），可以防止同一步棋被多次应用；
  - **请求幂等（HTTP / WS）**：私聊消息通过 `clientOpId` 实现幂等，其他创建/变更类接口目前主要依赖状态校验和前端防抖，缺少统一的 `idempotency-key` 方案；
  - **消息幂等（Kafka）**：生产端已开启幂等生产和 `acks=all`，消费端主要依赖“断开 WS 操作本身幂等”，未对事件做显式去重。
- **改进**：
  - 在 **Gateway Filter / Spring 拦截器** 中统一读取前端传入的 `X-Idempotency-Key` / `requestId`，使用 Redis `SETNX` 记录已处理请求，实现创建房间、好友申请等接口的请求级幂等（重复请求直接返回第一次的处理结果或拒绝）；
  - 为关键 WS 指令（ready/start/restart/kick/resign 等）扩展 payload，加入 `clientOpId`，在后端按 `clientOpId` 做去重，避免断线重连或重发导致状态抖动；
  - 为 Kafka 事件引入统一的 `eventId` 字段，并在消费端用 Redis SET/数据库表记录已处理事件，实现真正的消费端幂等，配合生产端幂等生产形成闭环；
  - 在文档中统一梳理三类幂等（状态幂等 / 请求幂等 / 消息幂等）的边界与实现方式，指导后续新接口/新事件的设计。

### 7.4 数据一致性
- **风险等级**：🟠 **严重**（数据不一致，随时触发）
- **触发条件**：**跨服务数据手动操作不一致**时触发
- **风险**：跨服务数据不一致，如 Keycloak 用户与系统数据库用户不一致。
- **示例**：Keycloak 中用户已删除，但系统数据库中仍存在。
- **改进**：
  - 使用 Saga 模式或分布式事务。
  - 或定期同步，保证最终一致性。

### 7.5 服务版本兼容性
- **风险等级**：🟠 **严重**（版本升级触发）
- **触发条件**：**服务版本升级时接口不兼容**时触发
- **风险**：服务版本升级导致接口不兼容，调用失败。
- **示例**：Game-service 升级后接口变更，Gateway 仍使用旧接口调用。
- **改进**：
  - 使用 API 版本控制（`/v1/`, `/v2/`）。
  - 或使用契约测试（Pact）保证接口兼容性。

---

## 八、可观测性与运维风险

> **注意**：可观测性与运维风险章节编号从 8.1 开始，与跨服务风险章节（七）区分。

### 8.1 可观测性不足
- **风险等级**：🟡 **一般**（问题排查困难，随时触发）
- **触发条件**：**线上问题需要排查时**触发
- **风险**：缺少核心指标与链路追踪，线上问题难定位。
- **示例**：无法快速定位"AI 双执行""倒计时误判"的节点与时刻。
- **改进**：接入指标（在线/房间/WS/失败率/延迟）、日志规范、TraceId、告警。

### 8.2 日志规范缺失
- **风险等级**：🟡 **一般**（问题排查困难，随时触发）
- **触发条件**：**需要追踪请求链路时**触发
- **风险**：日志格式不统一，缺少 TraceId，难以追踪请求链路。
- **示例**：多个服务日志混杂，无法关联同一请求的日志。
- **改进**：
  - 统一日志格式（JSON），包含 TraceId、SpanId。
  - 或使用 OpenTelemetry 实现分布式追踪。

### 8.3 告警机制缺失
- **风险等级**：🟡 **一般**（问题发现延迟，随时触发）
- **触发条件**：**服务异常但无告警**时触发
- **风险**：服务异常时无告警，问题发现延迟。
- **示例**：Redis 连接池耗尽，但无告警，用户请求失败后才发现。
- **改进**：
  - 接入 Prometheus + AlertManager。
  - 或使用云监控服务（如阿里云、AWS CloudWatch）。

### 8.4 配置管理混乱
- **风险等级**：🟢 **轻微**（运维优化项）
- **触发条件**：**配置错误或环境不一致**时触发
- **风险**：配置分散在多个文件，环境差异大，容易出错。
- **示例**：开发环境配置与生产环境不一致，导致生产环境问题。
- **改进**：
  - 使用 Spring Cloud Config 或 Nacos 统一配置管理。
  - 或使用环境变量，通过 CI/CD 注入。

---

## 九、安全风险

> **注意**：安全风险章节编号从 9.1 开始，与可观测性与运维风险章节（八）区分。

### 9.1 JWT Token 泄露
- **风险等级**：🔴 **致命**（安全漏洞，随时触发）
- **触发条件**：**Token 被日志记录或抓包**时触发
- **风险**：JWT Token 泄露（日志、抓包），攻击者可冒充用户。
- **示例**：Token 写入日志文件，被恶意访问。
- **改进**：
  - 避免在日志中记录完整 Token。
  - 或使用短期 Token + Refresh Token，降低泄露影响。

### 9.2 SQL 注入
- **风险等级**：🔴 **致命**（安全漏洞，随时触发）
- **触发条件**：**使用字符串拼接 SQL 且用户输入未过滤**时触发
- **风险**：使用字符串拼接 SQL，存在 SQL 注入风险。
- **示例**：`@Query` 注解中使用字符串拼接，未使用参数化查询。
- **改进**：
  - 使用 JPA 方法查询或参数化查询。
  - 或使用 MyBatis，避免字符串拼接。

### 9.3 跨站脚本攻击（XSS）
- **风险等级**：🟠 **严重**（安全风险，用户输入触发）
- **触发条件**：**用户输入恶意脚本且前端未转义**时触发
- **风险**：前端未对用户输入进行转义，存在 XSS 风险。
- **示例**：聊天消息中包含恶意脚本，其他用户查看时执行。
- **改进**：
  - 使用 React 自动转义，或使用 DOMPurify 清理 HTML。
  - 或使用 Content Security Policy（CSP）限制脚本执行。

### 9.4 跨站请求伪造（CSRF）
- **风险等级**：🟠 **严重**（安全风险，恶意网站触发）
- **触发条件**：**恶意网站伪造请求**时触发
- **风险**：缺少 CSRF 防护，攻击者可伪造请求。
- **示例**：用户登录后，恶意网站发起请求，执行用户操作。
- **改进**：
  - 使用 CSRF Token 或 SameSite Cookie。
  - 或使用 OAuth2 标准流程，减少 CSRF 风险。

---

## 十、性能风险

> **注意**：性能风险章节编号从 10.1 开始，与安全风险章节（九）区分。

### 10.1 数据库连接池耗尽
- **风险等级**：🟠 **严重**（高并发触发）
- **触发条件**：**并发请求数 > 连接池大小 × 10** 时触发
- **风险**：高并发下数据库连接池耗尽，请求失败。
- **示例**：1000 并发请求，连接池大小 20，大量请求等待连接。
- **改进**：
  - 调整连接池大小，或使用连接池监控。
  - 或使用数据库读写分离，减少主库压力。

### 10.2 Redis 内存溢出
- **风险等级**：🟡 **一般**（数据量触发）
- **触发条件**：**Redis 内存使用 > 80%** 时触发淘汰策略
- **风险**：Redis 内存使用过高，触发淘汰策略，影响性能。chat-service 和 game-service 都使用 Redis，内存压力叠加。
- **示例**：大量游戏状态、会话数据、聊天消息历史占用内存，Redis 内存不足。
- **改进**：
  - 设置合理的 TTL，及时清理过期数据。
  - 或使用 Redis Cluster，分片存储。
  - 或使用不同的 Redis database 隔离不同服务的数据。

### 10.3 WebSocket 连接数限制
- **风险等级**：🟡 **一般**（连接数触发）
- **触发条件**：**单机 WebSocket 连接数 > 50000** 时开始受限
- **风险**：单机 WebSocket 连接数有限，无法支持大规模并发。chat-service 和 game-service 都使用 WebSocket，连接数限制是共享的。
- **示例**：单机最多支持 65535 个连接，超过后新连接失败。
- **改进**：
  - 使用负载均衡，分散连接。
  - 或使用 WebSocket 集群，通过 Redis 共享会话。

---

## 十一、风险等级统计

### 风险等级分布

| 等级 | 数量 | 风险项 |
|------|------|--------|
| 🔴 **致命** | 6 | 1.4 Keycloak 连接失败降级策略缺失<br>3.1 Keycloak 事件处理失败<br>6.1 Redis 单点故障<br>6.4 Keycloak 可用性<br>9.1 JWT Token 泄露<br>9.2 SQL 注入 |
| 🟠 **严重** | 16 | 1.3 WebSocket 认证 Token 传递安全<br>2.1 多节点一致性与互斥<br>2.4 AI 分支 CAS 条件硬编码<br>2.6 内存与 Redis 短暂不一致窗口<br>3.2 用户同步一致性<br>3.3 Keycloak Admin API 调用失败<br>3.4 数据库事务边界不清晰<br>4.1 消息持久化失败<br>4.8 私聊好友关系验证降级安全风险<br>6.2 PostgreSQL 数据一致性（主从延迟）<br>6.3 Kafka 消息丢失<br>7.2 事件丢失或重复<br>7.3 数据一致性<br>7.4 服务版本兼容性<br>9.3 跨站脚本攻击（XSS）<br>9.4 跨站请求伪造（CSRF）<br>10.1 数据库连接池耗尽 |
| 🟡 **一般** | 16 | 1.1 JWT 黑名单性能瓶颈（2000+ QPS）<br>1.2 会话状态检查性能问题（2000+ QPS）<br>2.2 倒计时恢复误触发（服务重启）<br>2.3 恢复扫描使用 KEYS（键空间 > 10万）<br>2.5 回合锚点缺少 TTL/清理<br>2.8 WebSocket 广播顺序与幂等<br>3.5 软删除数据残留（数据量 > 10万）<br>4.4 WebSocket 连接数限制（连接数 > 50000）<br>4.6 消息历史查询性能（数据量 > 10万）<br>5.1 Token 刷新失败处理<br>5.2 WebSocket 重连状态丢失<br>5.3 并发请求竞态条件<br>5.4 内存泄漏（长时间运行）<br>6.5 Docker Compose 单机部署限制<br>8.1 可观测性不足<br>8.2 日志规范缺失<br>8.3 告警机制缺失<br>10.2 Redis 内存溢出（内存 > 80%）<br>10.3 WebSocket 连接数限制（连接数 > 50000，chat-service 和 game-service 共享） |
| 🟢 **轻微** | 9 | 1.5 路由配置硬编码<br>2.7 用户鉴权遗留问题（已基本实现）<br>2.9 配置与阈值可调性<br>4.2 系统通知推送失败（已缓解）<br>4.3 用户信息缓存不一致（已解决）<br>4.5 私聊消息幂等性（已解决）<br>4.7 房间事件订阅失败<br>7.1 服务间调用失败（已缓解）<br>8.4 配置管理混乱 |

### 触发条件统计

| 触发条件 | 数量 | 说明 |
|---------|------|------|
| **高并发触发** | 4 | 1.1、1.2、10.1、10.3 |
| **多节点触发** | 2 | 2.1、2.6 |
| **数据量触发** | 4 | 2.3、3.5、4.6、10.2 |
| **基础设施故障** | 3 | 1.4、6.1、6.4 |
| **安全漏洞** | 6 | 1.3、4.8、9.1、9.2、9.3、9.4 |
| **服务不可用触发** | 3 | 4.2、4.8、7.1 |
| **随时触发** | 15+ | 其他逻辑错误、数据不一致等 |

---

## 十二、建议优先级

### P0（ 致命风险）
1. **🔴 致命**：**System-service**：Keycloak 事件处理失败重试机制（3.1）。
2. **🔴 致命**：**Gateway**：Keycloak 连接失败降级策略（1.4）。
3. **🔴 致命**：**安全**：SQL 注入防护（8.2），JWT Token 泄露防护（8.1）。
4. **🟠 严重**：**Game-service**：AI 执行房间级分布式锁；AI CAS 使用 `now.current()`（2.1、2.4）。

### P1（严重风险）
1. **🔴 致命**：**基础设施**：Redis 高可用（Sentinel 或 Cluster）（6.1）。
2. **🔴 致命**：**基础设施**：Keycloak 集群或公钥缓存（6.4）。
3. **🟠 严重**：**Game-service**：place CAS 失败后强制回读刷新内存；或评估 Lua 原子化（2.6）。
4. **🟠 严重**：**System-service**：Keycloak Admin API 调用失败补偿机制（3.3）。
5. **🟠 严重**：**Chat-service**：私聊好友关系验证降级安全风险（4.8）- 生产环境将降级策略改为拒绝发送。
6. **🟡 一般**：**Game-service**：倒计时恢复改 SCAN；turnKey TTL/清理补齐（2.3、2.5）。

### P2（计划处理）
1. **🟠 严重**：**跨服务**：事件丢失或重复处理（7.2）。
2. **🟠 严重**：**跨服务**：数据一致性保证（7.3）。
3. **🟠 严重**：**Chat-service**：消息持久化失败（4.1）- 房间消息持久化到 PostgreSQL，实现事务保证。
4. **🟡 一般**：**Gateway**：JWT 黑名单性能优化（仅在 QPS > 2000 时考虑，500 QPS 以内无需优化）（1.1）。
5. **🟡 一般**：**可观测性**：指标/日志/TraceId/告警接入；序列化统一为 JSON（8.1、8.2、8.3）。
6. **🟢 轻微**：**跨服务**：服务间调用熔断、重试、降级（Resilience4j）（7.1）- ✅ 已实现，风险已缓解。
7. **🟢 轻微**：**Game-service**：重命名 `SeatsBinding` 字段（`seatXSessionId` → `seatXUserId`），提高代码可读性（2.7）。

### P3（长期规划）
1. **🟡 一般**：**基础设施**：迁移到 Kubernetes，支持水平扩展（6.5）。
2. **🟡 一般**：**性能**：数据库读写分离，Redis Cluster（10.1、10.2）。
3. **🟢 轻微**：**配置**：统一配置管理（Spring Cloud Config 或 Nacos）（1.5、2.9、8.4）。

---

## 十三、风险跟踪

计划以下方式跟踪风险：
- **风险登记表**：记录每个风险的 ID、描述、影响、优先级、负责人、状态。
- **定期评审**：每月评审风险清单，更新状态和优先级。
- **问题追踪**：使用 Jira、GitHub Issues 等工具跟踪风险改进进度。

---

## 十四、多实例部署风险总览（摘要）

> **详细版请参考**：`docs/zh/1.0版本多实例部署影响分析.md`。本节只做高层摘要，列出核心问题类型，具体到每个功能点的影响与改造方案，请以多实例分析文档为准。

当前 1.0 版本在多实例部署下的核心风险，可以归纳为以下四类：

1. **房间亲和缺失**  
   - 同一房间的 HTTP / WebSocket 请求在负载均衡下可能被路由到不同实例，而业务代码默认假设“同一房间长期落在同一个实例”。  
   - 影响：AI 延迟落子、倒计时恢复等房间级逻辑可能在多个实例上各自执行一遍，导致重复执行或状态抖动。  
   - 典型改造方向：在 Gateway 按 `roomId` 做一致性哈希 / 亲和路由。

2. **多实例内存状态不共享**  
   - 关键状态（如 `rooms`、`pendingAi`、本地缓存、定时任务持有的状态）存放在各自实例的 JVM 内存中，没有统一落到 Redis 或通过事件同步。  
   - 影响：同一房间在不同实例内存中的 Room / 倒计时 / AI 状态可能不一致，产生“脏内存”、重复任务或漏执行。  
   - 典型改造方向：状态下沉到 Redis + CAS / 分布式锁，内存只作为缓存，必要时加版本号或强制回读。

3. **幂等与重试策略不统一（HTTP / WS / Kafka）**  
   - 只在少数点上实现了幂等（如落子 CAS、私聊 `clientOpId`），整体上 HTTP / WebSocket / Kafka 的幂等设计不统一。  
   - 影响：在网络抖动、超时重试、多 Tab / 多设备、Kafka 重试/重平衡等场景下，可能出现重复创建房间/好友、WS 指令重复执行、Kafka 事件重复消费后未来挂载的非幂等逻辑（记战绩、发奖励）被多次执行。  
   - 典型改造方向：统一三层幂等——**状态幂等（Redis CAS）**、**请求幂等（`X-Idempotency-Key` + Redis SETNX）**、**消息幂等（`eventId` + Redis 去重）**。

4. **WebSocket 广播仅限单实例（SimpleBroker 限制）**  
   - game-service 与 chat-service 都使用 `enableSimpleBroker("/topic", "/queue")`，SimpleBroker 只在单实例内维护订阅与广播。  
   - 影响：同一个 `/topic/...` 目的地，在多实例下会变成“每个实例一个小岛”：  
     - 大厅 `/topic/chat.lobby` 实际上是“每个实例一个小大厅”；  
     - 对局 `/topic/room.{roomId}`、房间操作、倒计时 TICK/TIMEOUT，如果房间成员连接到不同实例，彼此无法看到对方的消息或状态更新。  
   - 典型改造方向：将 STOMP 广播从内存 SimpleBroker 升级为外部消息代理（RabbitMQ StompRelay / Redis PubSub 等），或在外部 broker 方案未就绪前，临时配合房间亲和降低影响范围。

> **使用建议**：面向架构评审/面试时，可先用本节四类问题做高层说明，再引用 `1.0版本多实例部署影响分析.md` 展开到“具体功能点 + 代码位置 + 升级方案”，两份文档互相配合使用。

---

> **文档维护**：本文档应随项目演进持续更新，新增风险及时补充，已解决风险标记为"已解决"并记录解决方案。
