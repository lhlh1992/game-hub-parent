## 倒计时时钟功能说明

这是我设计的倒计时系统，主要目标是：
- 把倒计时调度从具体业务里解耦出来，做成可复用的通用引擎
- 业务层（比如五子棋）只需要关心：什么时候启动/停止、每秒怎么展示、到期了怎么处理

---

## 一、分层与职责

### 1.1 通用调度引擎（infrastructure layer）

包路径：`com.gamehub.gameservice.clock.scheduler`

接口是 `CountdownScheduler`，实现在 `CountdownSchedulerImpl`。

这个引擎的职责：
  - 管理 key 的倒计时：`startOrResume`、`stop`、`restoreAllActive`
  - 每秒触发 `TickListener#onTick(key, owner, deadlineMs, left)`
  - 到期触发 `TimeoutHandler#onTimeout(key, owner, version)`
- 把状态持久化到 Redis（`countdown:{key}`），用 SETNX 实现 holder 锁（`countdown:holder:{key}`）保证分布式下只有一个节点处理超时
- 用注入的 `ScheduledThreadPoolExecutor` 做周期调度

它不做任何业务逻辑（比如广播、判负这些），这些交给上层协调器处理。

关键代码：
```java
// CountdownScheduler 接口定义
public interface CountdownScheduler {
    interface TickListener {
        void onTick(String key, String owner, long deadlineEpochMs, long remainingSeconds);
    }
    
    interface TimeoutHandler {
        void onTimeout(String key, String owner, String version);
    }
    
    void setTickListener(TickListener listener);
    void startOrResume(String key, String owner, long deadlineEpochMs, String version, TimeoutHandler onTimeout);
    void stop(String key);
    int restoreAllActive(TimeoutHandler onTimeout);
}
```

**实现细节**（`CountdownSchedulerImpl`）：
```java
// 启动或续上倒计时
@Override
public void startOrResume(String key, String owner, long deadlineEpochMs, String version, TimeoutHandler onTimeout) {
    stop(key);  // 防止重复任务：先取消老任务
    CountdownState state = new CountdownState(key, owner, version, deadlineEpochMs);
    saveState(state);  // 持久化到 Redis（便于恢复）
    
    long remainMs = state.deadlineEpochMs - System.currentTimeMillis();
    if (remainMs <= 0) {
        // 已到期：直接尝试做超时
        if (tryAcquireHolder(key)) {
            safeTimeout(onTimeout, state);
        }
        return;
    }
    
    fireTick(state);  // 立即首帧 TICK，提升前端体验
    ScheduledFuture<?> fut = scheduler.scheduleAtFixedRate(
            () -> tickTask(state, onTimeout), 1, 1, TimeUnit.SECONDS);
    activeTasks.put(key, fut);
}

// 停止倒计时（清理 Redis 状态与 holder 锁）
@Override
public void stop(String key) {
    ScheduledFuture<?> f = activeTasks.remove(key);
    if (f != null) f.cancel(false);
    // 同步清理 Redis 中的状态与 holder 锁，避免重启时被误恢复
    try {
        redis.delete(stateKey(key));
        redis.delete(holderKey(key));
    } catch (Exception ignore) {}
}

// 恢复所有活跃倒计时（使用 redis.keys()，存在阻塞风险）
@Override
public int restoreAllActive(TimeoutHandler onTimeout) {
    Set<String> keys = redis.keys(stateKey("*"));  // ⚠️ 注意：应改用 SCAN
    // ... 遍历恢复逻辑
}
```

### 1.2 业务协调层（application layer）

包路径：`com.gamehub.gameservice.games.gomoku.application`

类名：`TurnClockCoordinator`

这个协调器负责：
- 从 `GomokuState` 计算出通用参数，然后驱动调度引擎：
  - key = `"gomoku:"+roomId`
  - owner = 当前轮到的一方（`"X"` 或 `"O"`）
  - version = 当前盘的 `gameId`
  - deadlineMs = 当前时间 + 单回合秒数
- 监听调度引擎的 `tick` 回调，转成房间内的 `TICK` 事件并广播
- 监听调度引擎的 `timeout` 回调，调用 `gomokuService.resign` 判负，然后广播 `TIMEOUT/STATE/SNAPSHOT`
- 处理 PVE 模式下 `aiTimed=false` 的不计时规则，以及终局时停止计时

关键代码：
```java
@Component
@Lazy
@RequiredArgsConstructor
public class TurnClockCoordinator {
    private final CountdownScheduler scheduler;
    private final @Lazy GomokuService gomokuService;
    private final SimpMessagingTemplate messaging;
    private final GameStateRepository gameStateRepository;
    
    @Value("${gomoku.turn.seconds:30}")
    private int turnSeconds;
    
    @Value("${gomoku.turn.aiTimed:false}")
    private boolean aiTimed;
    
    // 应用启动时注册 TICK 监听并恢复活跃任务
    @EventListener(ApplicationReadyEvent.class)
    public void onReady() {
        // 注册每秒 TICK 的转发：把引擎回调转成房间内的 TICK 消息
        scheduler.setTickListener((key, owner, deadlineMs, left) -> {
            String roomId = extractRoomId(key);
            BroadcastEvent tick = new BroadcastEvent();
            tick.setRoomId(roomId);
            tick.setType("TICK");
            tick.setPayload(Map.of(
                    "left", (int) left,
                    "side", owner,
                    "deadlineEpochMs", deadlineMs
            ));
            messaging.convertAndSend(topic(roomId), tick);
        });
        
        // 恢复所有未过期的倒计时
        int restored = scheduler.restoreAllActive((key, owner, version) -> handleTimeout(key, owner));
        log.info("协调器启动完成：已恢复活跃倒计时任务 {} 个", restored);
    }
    
    // 根据最新对局状态驱动倒计时
    public void syncFromState(String roomId, GomokuState state) {
        // 终局：停止计时
        if (state.over()) { stop(roomId); return; }
        
        RoomPhase phase = gomokuService.getRoomPhase(roomId);
        if (phase != RoomPhase.PLAYING) {
            stop(roomId);
            return;
        }
        
        boolean isPve = gomokuService.getMode(roomId) == Mode.PVE;
        char ai = gomokuService.getAiPiece(roomId);
        char sideToMove = state.current();
        boolean aiTurn = isPve && (sideToMove == ai);
        
        // PVE 且不计 AI → 停止计时
        if (aiTurn && !aiTimed) { stop(roomId); return; }
        
        // 启动/恢复倒计时
        String key = key(roomId);
        String owner = String.valueOf(sideToMove);
        String version = gomokuService.getGameId(roomId);
        long deadline = System.currentTimeMillis() + turnSeconds * 1000L;
        scheduler.startOrResume(key, owner, deadline, version,
                (k, o, v) -> handleTimeout(k, o));
    }
    
    // 处理回合超时：判负并广播
    private void handleTimeout(String key, String owner) {
        String roomId = extractRoomId(key);
        char side = owner.charAt(0);
        
        GomokuState before = gomokuService.getState(roomId);
        GomokuState after = gomokuService.resign(roomId, side);  // 权威判负
        
        // 保存状态到 Redis（CAS）
        GameStateRecord rec = buildRecord(after, roomId, gameId, expectedStep + 1);
        gameStateRepository.updateAtomically(roomId, gameId, expectedStep, expectedTurn, rec, 0L);
        
        // 广播 TIMEOUT、STATE、SNAPSHOT
        // ...
    }
    
    public void stop(String roomId) {
        scheduler.stop(key(roomId));
    }
    
    private String key(String roomId) { return "gomoku:" + roomId; }
    private String extractRoomId(String key) {
        return key.startsWith("gomoku:") ? key.substring("gomoku:".length()) : key;
    }
    private String topic(String roomId) { return "/topic/room." + roomId; }
}
```

### 1.3 接口层（controller layer）

包路径：`com.gamehub.gameservice.games.gomoku.interfaces.ws`

类名：`GomokuWsController`

这个控制器负责：
- 处理落子/重开/认输等 WebSocket 请求，广播 `STATE/SNAPSHOT`
- 每次广播 `STATE` 后，调用 `TurnClockCoordinator#syncFromState(roomId, state)` 来对齐回合计时
  - 在重开/认输前调用 `coordinator.stop(roomId)` 终止旧回合计时

关键代码：
```java
@Controller
@RequiredArgsConstructor
public class GomokuWsController {
    private final TurnClockCoordinator coordinator;
    
    // 落子后同步倒计时
    private void sendState(String roomId, GomokuState state) {
        // ... 广播 STATE 和 SNAPSHOT
        coordinator.syncFromState(roomId, state);  // 对齐回合计时
    }
    
    // 重开/认输前停止计时
    @MessageMapping("/gomoku.restart")
    public void restart(/* ... */) {
        coordinator.stop(roomId);  // 终止旧回合计时
        // ... 重开逻辑
    }
}
```

---

## 二、关键数据

### 2.1 Redis 存储结构

状态持久化（由 `CountdownSchedulerImpl` 写入 Redis）：
- 键：`countdown:{key}`（比如 `countdown:gomoku:room-123`）
- 值：`CountdownState` 对象（JDK 序列化）
  ```java
  public static class CountdownState implements Serializable {
      public String key;           // 业务键（如 "gomoku:room-123"）
      public String owner;         // 被计时的一方（"X"/"O"）
      public String version;       // 回合版本（gameId，用于幂等/保护）
      public long deadlineEpochMs; // 绝对截止时间（毫秒）
  }
  ```
- TTL：24 小时

Holder 锁（分布式互斥）：
- 键：`countdown:holder:{key}`（比如 `countdown:holder:gomoku:room-123`）
- 值：节点 ID（`nodeId`）
- TTL：10 秒（目前硬编码，后续应该外置化配置）
- 实现：Redis SETNX（`setIfAbsent`）

关键代码：
```java
// CountdownSchedulerImpl
private String stateKey(String key) { return "countdown:" + key; }
private String holderKey(String key) { return "countdown:holder:" + key; }

private void saveState(CountdownState st) {
    redis.opsForValue().set(stateKey(st.key), st, Duration.ofSeconds(24 * 60 * 60));
}

private boolean tryAcquireHolder(String key) {
    String lockKey = holderKey(key);
    Boolean ok = redis.opsForValue().setIfAbsent(lockKey, nodeId, Duration.ofSeconds(10));
    return Boolean.TRUE.equals(ok);
}
```

---

## 三、生命周期与恢复

### 3.1 应用启动流程

触发时机：`@EventListener(ApplicationReadyEvent.class)`

关键代码：
```java
// TurnClockCoordinator.onReady()
@EventListener(ApplicationReadyEvent.class)
public void onReady() {
    // 1. 注册 TICK 监听器
    scheduler.setTickListener((key, owner, deadlineMs, left) -> {
        String roomId = extractRoomId(key);
        BroadcastEvent tick = new BroadcastEvent();
        tick.setType("TICK");
        tick.setPayload(Map.of("left", (int) left, "side", owner, "deadlineEpochMs", deadlineMs));
        messaging.convertAndSend("/topic/room." + roomId, tick);
    });
    
    // 2. 恢复所有未过期的倒计时
    int restored = scheduler.restoreAllActive((key, owner, version) -> handleTimeout(key, owner));
    log.info("协调器启动完成：已恢复活跃倒计时任务 {} 个", restored);
}
```

恢复逻辑（`CountdownSchedulerImpl.restoreAllActive()`）：
```java
@Override
public int restoreAllActive(TimeoutHandler onTimeout) {
    // 扫描所有持久化倒计时
    Set<String> keys = redis.keys(stateKey("*"));  // ⚠️ 注意：应改用 SCAN
    // 无可恢复任务
    if (keys == null || keys.isEmpty()) return 0;
    // 计数器
    int restored = 0;
    int expiredCleaned = 0;      // 被清理的已过期数量
    int expiredHandled = 0;      // 触发了超时处理的数量
    // 遍历每个持久化键
    for (String redisKey : keys) {
        // 加载状态
        CountdownState st = loadStateByRedisKey(redisKey);
        // 容错：被并发删除
        if (st == null) continue;
        // 剩余毫秒
        long remainMs = st.deadlineEpochMs - System.currentTimeMillis();
        // 已过期：清理并尝试超时
        if (remainMs <= 0) {
            // 清理陈旧状态
            redis.delete(redisKey);
            expiredCleaned++;
            // holder 才执行超时
            if (tryAcquireHolder(st.key)) { 
                safeTimeout(onTimeout, st); 
                expiredHandled++; 
            }
            // 不再恢复调度
            continue;
        }
        // 恢复后立即推一帧 TICK
        fireTick(st);
        // 启动周期调度
        ScheduledFuture<?> fut = scheduler.scheduleAtFixedRate(
                () -> tickTask(st, onTimeout), 1, 1, java.util.concurrent.TimeUnit.SECONDS);
        // 记录任务
        activeTasks.put(st.key, fut);
        restored++;
    }
    // 记录启动恢复的总体结果日志
    log.info("Countdown restoreAllActive done: restored={}, expiredCleaned={}, expiredHandled={}",
            restored, expiredCleaned, expiredHandled);
    // 返回恢复数量
    return restored;
}
```

---

## 四、线程模型

### 4.1 线程池配置

配置类：`clock.ClockSchedulerConfig`

关键代码：
```java
@Configuration
public class ClockSchedulerConfig {
    @Value("${scheduler.clock.corePoolSize:2}")
    private int corePoolSize;
    
    @Bean(name = "turnClockScheduler")
    public ScheduledThreadPoolExecutor turnClockScheduler() {
        ThreadFactory tf = new ThreadFactory() {
            private final AtomicInteger seq = new AtomicInteger(1);
            @Override
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, "countdown-" + seq.getAndIncrement());
                t.setDaemon(true);  // 守护线程
                return t;
            }
        };
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(
                corePoolSize, tf, new ThreadPoolExecutor.DiscardPolicy());
        executor.setRemoveOnCancelPolicy(true);  // 清理已取消任务
        return executor;
    }
}
```

线程模型：
- 线程池：`ScheduledThreadPoolExecutor`（默认核心线程数 2）
- 线程命名：`countdown-1`、`countdown-2`、...
- 守护线程：是（JVM 退出时自动结束）
- 调度频率：每秒一次（`scheduleAtFixedRate(..., 1, 1, TimeUnit.SECONDS)`）
- 任务存储：`ConcurrentMap<String, ScheduledFuture<?>> activeTasks`（key -> 任务句柄）

---

## 五、主要调用链

### 5.1 落子后同步倒计时

完整调用链：
```
前端落子 → WebSocket /app/gomoku.place
  ↓
GomokuWsController.place()
  ↓
GomokuService.place() → 执行落子、CAS 保存
  ↓
GomokuWsController.sendState(roomId, state)
  ↓
广播 STATE 和 SNAPSHOT 事件
  ↓
TurnClockCoordinator.syncFromState(roomId, state)
  ↓
判断条件：
  - 若终局：coordinator.stop(roomId)
  - 若 PVE 且 aiTimed=false 且轮到 AI：coordinator.stop(roomId)
  - 否则：scheduler.startOrResume(key, owner, deadline, version, timeoutHandler)
```

关键代码：
```java
// GomokuWsController.sendState()
private void sendState(String roomId, GomokuState state) {
    // 广播 STATE
    BroadcastEvent stateEvt = new BroadcastEvent();
    stateEvt.setType("STATE");
    stateEvt.setPayload(new StatePayload(state, series));
    messaging.convertAndSend("/topic/room." + roomId, stateEvt);
    
    // 广播 SNAPSHOT
    // ...
    
    // 同步倒计时
    coordinator.syncFromState(roomId, state);
}

// TurnClockCoordinator.syncFromState()
public void syncFromState(String roomId, GomokuState state) {
    if (state.over()) { stop(roomId); return; }
    
    RoomPhase phase = gomokuService.getRoomPhase(roomId);
    if (phase != RoomPhase.PLAYING) {
        stop(roomId);
        return;
    }
    
    boolean isPve = gomokuService.getMode(roomId) == Mode.PVE;
    char ai = gomokuService.getAiPiece(roomId);
    char sideToMove = state.current();
    boolean aiTurn = isPve && (sideToMove == ai);
    
    if (aiTurn && !aiTimed) { stop(roomId); return; }
    
    String key = "gomoku:" + roomId;
    String owner = String.valueOf(sideToMove);
    String version = gomokuService.getGameId(roomId);
    long deadline = System.currentTimeMillis() + turnSeconds * 1000L;
    scheduler.startOrResume(key, owner, deadline, version,
            (k, o, v) -> handleTimeout(k, o));
}
```

### 5.2 每秒 TICK 流程

调用链：
```
ScheduledThreadPoolExecutor 每秒触发
  ↓
CountdownSchedulerImpl.tickTask(state, onTimeout)
  ↓
从 Redis 读取最新状态
  ↓
计算剩余时间
  ↓
如果已到期：
  - tryAcquireHolder(key) → 获取分布式锁
  - stop(key) → 停止调度
  - safeTimeout(onTimeout, state) → 触发超时回调
否则：
  - fireTick(state) → 触发 TICK 回调
  ↓
TurnClockCoordinator 的 TickListener
  ↓
组装 TICK 事件并广播到 /topic/room.{roomId}
```

关键代码：
```java
// CountdownSchedulerImpl.tickTask()
private void tickTask(CountdownState state, TimeoutHandler onTimeout) {
    CountdownState latest = loadState(state.key);  // 以 Redis 为准
    if (latest == null) {
        stop(state.key);  // 状态不存在 → 被停/删
        return;
    }
    
    long remainMs = latest.deadlineEpochMs - System.currentTimeMillis();
    if (remainMs <= 0) {
        // 到期：抢占 holder 锁后触发超时
        if (tryAcquireHolder(state.key)) {
            stop(state.key);
            safeTimeout(onTimeout, latest);
        }
        return;
    }
    
    fireTick(latest);  // 正常 TICK 回调
}

// TurnClockCoordinator 的 TickListener（在 onReady() 中注册）
scheduler.setTickListener((key, owner, deadlineMs, left) -> {
    String roomId = extractRoomId(key);
    BroadcastEvent tick = new BroadcastEvent();
    tick.setType("TICK");
    tick.setPayload(Map.of("left", (int) left, "side", owner, "deadlineEpochMs", deadlineMs));
    messaging.convertAndSend("/topic/room." + roomId, tick);
});
```

### 5.3 超时处理流程

调用链：
```
倒计时到期
  ↓
CountdownSchedulerImpl.tickTask() 检测到 remainMs <= 0
  ↓
tryAcquireHolder(key) → 获取分布式锁（SETNX）
  ↓
safeTimeout(onTimeout, latest) → 触发超时回调
  ↓
TurnClockCoordinator.handleTimeout(key, owner)
  ↓
gomokuService.resign(roomId, side) → 权威判负
  ↓
gameStateRepository.updateAtomically(...) → CAS 保存状态
  ↓
广播 TIMEOUT、STATE、SNAPSHOT 事件
```

关键代码：
```java
// TurnClockCoordinator.handleTimeout()
private void handleTimeout(String key, String owner) {
    log.info("回合超时处理");
    String roomId = extractRoomId(key);
    // 所属棋色（处理 owner 可能为 null 或空的情况）
    char side = (owner == null || owner.isEmpty()) ? 0 : owner.charAt(0);
    
    // 获取超时前的状态，用于 CAS 保存
    GomokuState before = gomokuService.getState(roomId);
    final String gameId = gomokuService.getGameId(roomId);
    int expectedStep = computeExpectedStep(before.board());
    char expectedTurn = before.current();
    
    // 权威判负
    GomokuState after = gomokuService.resign(roomId, side);
    
    // 保存超时后的状态到 Redis（用 try-catch 包裹，避免失败影响后续广播）
    GameStateRecord rec = buildRecord(after, roomId, gameId, expectedStep + 1);
    try {
        gameStateRepository.updateAtomically(roomId, gameId, expectedStep, expectedTurn, rec, 0L);
    } catch (Exception e) {
        log.warn("保存超时状态到Redis失败: {}", e.getMessage());
    }
    
    // 广播 TIMEOUT
    BroadcastEvent timeout = new BroadcastEvent();
    timeout.setRoomId(roomId);
    timeout.setType("TIMEOUT");
    timeout.setPayload(java.util.Map.of("side", owner));
    messaging.convertAndSend(topic(roomId), timeout);
    
    // 取系列视图
    var sv = gomokuService.getSeries(roomId);
    // 广播 STATE
    BroadcastEvent stateEvt = new BroadcastEvent();
    stateEvt.setRoomId(roomId);
    stateEvt.setType("STATE");
    stateEvt.setPayload(new StatePayload(after, sv));
    messaging.convertAndSend(topic(roomId), stateEvt);
    
    // 广播 SNAPSHOT
    Object snap = gomokuService.snapshot(roomId);
    BroadcastEvent snapEvt = new BroadcastEvent();
    snapEvt.setRoomId(roomId);
    snapEvt.setType("SNAPSHOT");
    snapEvt.setPayload(snap);
    messaging.convertAndSend(topic(roomId), snapEvt);
}
```

---

## 六、组件清单

### 6.1 配置层

`clock.ClockSchedulerConfig`：
- 提供 `turnClockScheduler` 线程池 Bean
- 配置核心线程数（`scheduler.clock.corePoolSize`，默认 2）
- 线程命名：`countdown-N`
- 守护线程：是

`clock.ClockAutoConfig`：
- 提供 `CountdownScheduler` Bean
- 注入 Redis 与线程池到 `CountdownSchedulerImpl`

关键代码：
```java
// ClockAutoConfig
@Bean
public CountdownScheduler countdownScheduler(
        RedisTemplate<String, Object> redisTemplate,
        @Qualifier("turnClockScheduler") ScheduledThreadPoolExecutor turnClockScheduler) {
    return new CountdownSchedulerImpl(redisTemplate, turnClockScheduler);
}
```

### 6.2 引擎层

`clock.scheduler.CountdownScheduler`：接口定义
`clock.scheduler.CountdownSchedulerImpl`：实现类

### 6.3 协调层

`games.gomoku.application.TurnClockCoordinator`：应用编排层，把通用引擎和五子棋业务规则对接起来

### 6.4 接口层

`games.gomoku.interfaces.ws.GomokuWsController`：WebSocket 控制器，调用协调器

---

## 七、约束与边界

### 7.1 引擎约束

- 引擎只以绝对时间 `deadlineEpochMs` 驱动，tick/timeout 的业务含义交给协调器定义
- 版本 `version` 只是透传，传给 `onTimeout` 供业务做幂等/保护用，引擎不解析
- Redis 键空间可以按需调整命名，目前用的是 `countdown:` 前缀

### 7.2 协调器约束

- 不管理线程池和 Redis，这些由引擎负责
- 不处理落子等输入请求，这些由 WebSocket 控制器负责
- 唯一职责就是把"何时计时、如何通知、到期如何处理"这些五子棋业务规则，编排到通用引擎的回调和调用里

---

## 八、已知问题与改进计划

### 8.1 恢复扫描使用 KEYS

问题：`CountdownSchedulerImpl.restoreAllActive()` 第 134 行用了 `redis.keys(stateKey("*"))`，有阻塞风险。

影响：键空间大的时候 KEYS 会卡住 Redis，影响全局读写。

改进计划：改用 SCAN 游标遍历。

当前代码：
```java
Set<String> keys = redis.keys(stateKey("*"));  // ⚠️ 阻塞风险
```

计划改进：
```java
// 使用 SCAN 游标遍历
String cursor = "0";
int restored = 0;
do {
    ScanOptions options = ScanOptions.scanOptions()
            .match(stateKey("*"))
            .count(100)
            .build();
    Cursor<String> scan = redis.scan(options);
    // ... 处理扫描结果
} while (!cursor.equals("0"));
```

### 8.2 Holder 锁 TTL 硬编码

问题：`CountdownSchedulerImpl.tryAcquireHolder()` 第 236 行硬编码了 10 秒。

影响：没法根据业务需求调整。

改进计划：外置化配置（比如 `countdown.holder.ttl.seconds`）。

当前代码：
```java
Boolean ok = redis.opsForValue().setIfAbsent(lockKey, nodeId, Duration.ofSeconds(10));  // ⚠️ 硬编码
```

### 8.3 序列化方式

问题：目前用的是 JDK 序列化（`RedisTemplate` 默认）。

影响：跨版本/跨语言不友好。

改进计划：统一改用 JSON 序列化。

---

## 九、常见问题

### Q1: 为什么引擎和协调器都要发 `TICK`？

A：只有协调器发（引擎只回调），协调器负责把回调转成 WebSocket 广播。

代码说明：
```java
// 引擎只回调，不广播
private void fireTick(CountdownState state) {
    TickListener l = tickListener;
    if (l == null) return;
    long left = Math.max(0, (state.deadlineEpochMs - System.currentTimeMillis()) / 1000);
    l.onTick(state.key, state.owner, state.deadlineEpochMs, left);  // 只回调
}

// 协调器负责广播
scheduler.setTickListener((key, owner, deadlineMs, left) -> {
    // ... 组装 TICK 事件
    messaging.convertAndSend("/topic/room." + roomId, tick);  // 协调器广播
});
```

### Q2: 重启后会不会判罚重复？

A：到期由 holder 锁保证只执行一次；tick 广播允许多节点同时发，不影响权威性。

代码说明：
```java
// 到期时通过 holder 锁保证只执行一次
if (remainMs <= 0) {
    if (tryAcquireHolder(state.key)) {  // SETNX 分布式锁
        stop(state.key);
        safeTimeout(onTimeout, latest);  // 只有获得锁的节点执行
    }
    return;
}
```

### Q3: 为什么 `stop()` 要清理 Redis 状态？

A：避免重启时被误恢复。如果 `stop()` 时不清理 Redis 状态，服务重启后 `restoreAllActive()` 会把已停止的倒计时重新恢复。

代码说明：
```java
@Override
public void stop(String key) {
    activeTasks.remove(key);
    // 同步清理 Redis 中的状态与 holder 锁，避免重启时被误恢复
    redis.delete(stateKey(key));
    redis.delete(holderKey(key));
}
```

---

## 十、完整代码文件清单

### 10.1 通用调度引擎

- 接口：`clock/scheduler/CountdownScheduler.java`
- 实现：`clock/scheduler/CountdownSchedulerImpl.java`
- 配置：`clock/ClockSchedulerConfig.java`（线程池配置）
- 装配：`clock/ClockAutoConfig.java`（Bean 装配）

### 10.2 业务协调层

- 协调器：`games/gomoku/application/TurnClockCoordinator.java`

### 10.3 接口层

- 控制器：`games/gomoku/interfaces/ws/GomokuWsController.java`

---

## 十一、配置项

### 11.1 线程池配置

```yaml
scheduler:
  clock:
    corePoolSize: 2  # 倒计时调度线程池核心线程数（默认 2）
```

### 11.2 五子棋倒计时配置

```yaml
gomoku:
  turn:
    seconds: 30      # 单回合时长（秒，默认 30）
    aiTimed: false   # 是否给 AI 计时（PVE 时，默认 false）
```

### 11.3 实例标识配置

```yaml
instance:
  id: ${spring.application.name}-${random.value}  # 节点 ID（用于 holder 锁）
```

---

## 十二、Redis 键空间设计

### 12.1 倒计时状态

- 键模式：`countdown:{key}`
- 示例：`countdown:gomoku:room-123`
- 值类型：`CountdownState`（JDK 序列化）
- TTL：24 小时

### 12.2 Holder 锁

- 键模式：`countdown:holder:{key}`
- 示例：`countdown:holder:gomoku:room-123`
- 值类型：String（节点 ID）
- TTL：10 秒（硬编码）

---

## 十三、WebSocket 事件

### 13.1 TICK 事件

主题：`/topic/room.{roomId}`

事件格式：
```json
{
  "roomId": "room-123",
  "type": "TICK",
  "payload": {
    "left": 25,
    "side": "X",
    "deadlineEpochMs": 1703123456789
  }
}
```

### 13.2 TIMEOUT 事件

主题：`/topic/room.{roomId}`

事件格式：
```json
{
  "roomId": "room-123",
  "type": "TIMEOUT",
  "payload": {
    "side": "X"
  }
}
```

---

## 十四、设计原则总结

我设计这个系统时遵循的原则：

1. **通用引擎与业务解耦**：引擎不关心业务逻辑，只负责调度和持久化
2. **协调器负责业务编排**：把业务规则（何时计时、如何通知、到期处理）编排到引擎回调里
3. **分布式安全**：用 holder 锁保证超时处理只执行一次
4. **重启恢复**：通过 Redis 持久化状态，支持服务重启后恢复未过期的倒计时
5. **立即反馈**：启动倒计时时立即发送首帧 TICK，提升前端体验
