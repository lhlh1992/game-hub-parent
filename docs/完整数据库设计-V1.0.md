# 数据库设计 - 多人在线棋牌室完整版

> 基于 RBAC 权限系统，扩展游戏、社交、用户成长、匹配等业务模块，适用于多人在线棋牌室平台。  
> **设计原则**：微服务架构下，不使用外键约束，通过应用层保证数据一致性；保留唯一索引保证唯一性；状态机终态封口；幂等键统一规范。

---

## 一、总体设计

### 1.1 架构定位
- **Keycloak**：用户认证（用户名、密码）
- **系统数据库**：业务数据（用户、角色、权限、游戏、社交、成长、匹配）
- **关联字段**：`keycloak_user_id`（UUID，对应 JWT 中 `sub`）

### 1.2 模块划分
```
系统模块
 ├── RBAC权限系统（用户、角色、权限、菜单、部门、日志）
 ├── 游戏模块（游戏类型、房间、对局、对局详情）
 ├── 社交模块（好友、好友申请、聊天会话、聊天消息）
 ├── 用户成长模块（积分、等级、积分变更记录）
 └── 匹配模块（匹配队列、匹配记录）
```

---

## 二、数据库初始化

### 2.1 创建数据库

```sql
-- 创建数据库（需要超级用户权限）
-- 统一基线：UTF8 + en_US.UTF-8 + UTC（跨平台兼容、国际化友好、Docker 默认支持）
CREATE DATABASE gamehub_db
    WITH 
    OWNER = postgres                    -- 数据库所有者（根据实际情况修改）
    ENCODING = 'UTF8'                   -- 字符编码：UTF-8（支持中英文、Emoji 等所有 Unicode 字符）
    LC_COLLATE = 'en_US.UTF-8'         -- 排序规则：en_US.UTF-8（英文自然排序，跨平台兼容性好）
    LC_CTYPE = 'en_US.UTF-8'           -- 字符分类：en_US.UTF-8（跨平台兼容性好）
    TEMPLATE = template0                -- 使用template0作为模板（避免继承其他数据库的设置）
    CONNECTION LIMIT = -1;              -- 连接数限制（-1表示无限制）

-- 添加数据库注释
COMMENT ON DATABASE gamehub_db IS '多人在线棋牌室平台主数据库（国际化基线：UTF8 + en_US.UTF-8 + UTC）';
```

> **说明**：
> - **统一基线**：使用 `en_US.UTF-8` 作为全局排序规则，不再区分"中文库""英文库"，全局只保留这一套设置
> - **英文自然排序**：A-Z、大写在前、小写在后，符合国际化标准
> - **跨平台兼容**：Docker 默认支持，跨平台兼容性好
> - **中文支持**：中文、日文等也能正常存储和显示
> - **国际化支持**：需要中文拼音排序或数字感知排序时，使用 ICU Collation 按列或按查询指定（见 2.6 节）
> - **时区统一**：数据库使用 UTC，展示时由应用层按用户时区本地化
>
> **选择 `en_US.UTF-8` 的理由**：
> - ✅ **用户体验**：英文自然排序（A-Z）符合大多数用户的期望，特别是国际化项目
> - ✅ **部署便利**：Docker 默认支持，无需额外配置 locale
> - ✅ **兼容性好**：跨平台兼容性好，不同环境下的排序结果一致
> - ⚠️ **性能考虑**：相比 `C.UTF-8` 性能略低（约 5-10%），但对于大多数应用场景影响可忽略
> - ⚠️ **中文排序**：中文按 Unicode 码点排序（非拼音），如需拼音排序需使用 ICU Collation（见 2.6 节）
>
> **如果追求极致性能或需要完全一致的跨平台排序**，可考虑使用 `C.UTF-8`，但会失去英文自然排序的优势。

### 2.2 连接数据库并设置扩展

```sql
-- 连接到新创建的数据库
\c gamehub_db

-- 创建扩展（所有扩展均使用 IF NOT EXISTS，可重入执行）
-- UUID 生成（PostgreSQL 13+ 已内置 gen_random_uuid()，但为了兼容旧版本和提供更多功能，建议安装 pgcrypto）
CREATE EXTENSION IF NOT EXISTS "pgcrypto";   -- 提供 gen_random_uuid() 等加密函数

-- 模糊/相似检索（支持中文模糊搜索）
CREATE EXTENSION IF NOT EXISTS "pg_trgm";    -- 提供 trigram 相似度匹配，支持 ILIKE 模糊搜索

-- 大小写不敏感字符串类型
CREATE EXTENSION IF NOT EXISTS "citext";     -- 提供 CITEXT 类型，大小写不敏感字符串比较

-- 注意：JSONB 索引支持已内置，无需额外扩展
```

> **说明**：
> - **pgcrypto**：虽然 PostgreSQL 13+ 内置了 `gen_random_uuid()`，但 `pgcrypto` 提供更多加密函数，建议安装
> - **pg_trgm**：支持中文模糊搜索，配合 GIN 索引使用 `ILIKE '%关键字%'`
> - **citext**：适用于邮箱、用户名等需要大小写不敏感比较的字段

### 2.3 数据库用户和角色创建（推荐）

```sql
-- 创建数据库角色（用于权限管理，最小权限原则）
CREATE ROLE gamehub_owner NOLOGIN;  -- 数据库所有者角色
CREATE ROLE gamehub_rw NOLOGIN;     -- 读写角色
CREATE ROLE gamehub_ro NOLOGIN;     -- 只读角色

-- 创建应用用户
CREATE USER gamehub_app WITH PASSWORD '***strong_password***';
GRANT gamehub_rw TO gamehub_app;

-- 设置数据库所有者
ALTER DATABASE gamehub_db OWNER TO gamehub_owner;

-- 创建应用 Schema（业务对象统一放在 app schema，便于管理和权限控制）
CREATE SCHEMA IF NOT EXISTS app AUTHORIZATION gamehub_owner;
ALTER DATABASE gamehub_db SET search_path = app, public;

-- 撤销 public schema 的公共权限（安全加固）
REVOKE ALL ON SCHEMA public FROM PUBLIC;

-- 授权 Schema 使用权限
GRANT USAGE ON SCHEMA app TO gamehub_rw, gamehub_ro;

-- 设置默认权限（未来新建对象自动继承权限，无需手动授权）
ALTER DEFAULT PRIVILEGES IN SCHEMA app 
    GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO gamehub_rw;
ALTER DEFAULT PRIVILEGES IN SCHEMA app 
    GRANT SELECT ON TABLES TO gamehub_ro;
ALTER DEFAULT PRIVILEGES IN SCHEMA app 
    GRANT USAGE, SELECT ON SEQUENCES TO gamehub_rw, gamehub_ro;
ALTER DEFAULT PRIVILEGES IN SCHEMA app 
    GRANT EXECUTE ON FUNCTIONS TO gamehub_rw;
```

> **说明**：
> - **Schema 隔离**：所有业务表统一放在 `app` schema，便于管理和权限控制
> - **显式前缀**：后续所有对象请显式带 `app.` 前缀（如 `app.sys_user`），避免被 `search_path` 劫持
> - **最小权限**：应用使用 `gamehub_app` 用户，禁止使用超级用户

### 2.4 数据库配置（时区与连接护栏）

```sql
-- 查看当前数据库配置
SHOW timezone;
SHOW server_encoding;
SELECT datcollate, datctype FROM pg_database WHERE datname = current_database();

-- 设置数据库级别的参数（需要超级用户权限）
-- 时区设置为中国时间（Asia/Shanghai）
ALTER DATABASE gamehub_db SET timezone = 'Asia/Shanghai';
ALTER DATABASE gamehub_db SET log_timezone = 'Asia/Shanghai';

-- 连接护栏（防止长时间运行的查询占用资源）
ALTER DATABASE gamehub_db SET statement_timeout = '30s';
ALTER DATABASE gamehub_db SET lock_timeout = '5s';
ALTER DATABASE gamehub_db SET idle_in_transaction_session_timeout = '60s';
```

> **说明**：
> - **时区设置为中国时间**：数据库时区设置为 `Asia/Shanghai`，所有时间字段使用 `TIMESTAMPTZ` 类型。注意：`TIMESTAMPTZ` 内部以 UTC 存储，显示时根据会话时区（当前为 `Asia/Shanghai`）进行渲染
> - **连接护栏**：可根据实际业务需求调整超时时间（复杂报表查询可能需要更大的 `statement_timeout`）
> - **连接池配置**（在应用层配置，如 HikariCP）：
>   - `maximumPoolSize`: 根据并发量设置（建议 10-50）
>   - `minimumIdle`: 保持最小连接数（建议 5-10）
>   - `connectionTimeout`: 连接超时（建议 30000ms）
>   - `idleTimeout`: 空闲连接超时（建议 600000ms）
>   - `maxLifetime`: 连接最大生命周期（建议 1800000ms）

### 2.5 字符集与排序规则说明

- **ENCODING = 'UTF8'**：使用 UTF-8 编码，支持中英文、Emoji 等所有 Unicode 字符

- **LC_COLLATE / LC_CTYPE = 'en_US.UTF-8'**：统一基线
  - **英文自然排序**：A-Z、大写在前、小写在后，符合国际化标准
  - **跨平台兼容**：Docker 默认支持，跨平台兼容性好
  - **中文支持**：中文、日文等也能正常存储和显示
  - **统一标准**：不再区分"中文库""英文库"，全局只保留这一套设置

- **需要中文/自然排序时**：使用 ICU Collation（PostgreSQL 15+）
  - 中文拼音排序：`zh_pinyin`（见 2.6 节）
  - 数字感知排序：`en_numeric`（见 2.6 节）
  - 按列或按查询指定，无需改全局配置

> **设计原则**：统一基线 = `UTF8 + en_US.UTF-8 + UTC`，不再维护"中文/英文两套建库脚本"。如后续需要中文拼音或自然语言排序，可在列或查询上单独添加 ICU Collation，无需改全局配置。
>
> **专业建议**：
> - **国际化项目**：`en_US.UTF-8` 是合理选择，符合用户期望，部署便利
> - **高性能场景**：如果排序性能是瓶颈（如大数据量排序），可考虑 `C.UTF-8`，但需在应用层处理排序逻辑
> - **中文为主**：如果主要用户是中文用户，且需要拼音排序，建议在关键字段（如昵称、菜单名）上使用 ICU Collation，而非改全局配置

### 2.6 ICU 排序规则（按需启用，PostgreSQL 15+）

**默认使用 `en_US.UTF-8`**。当需要"中文拼音/数字感知排序"时，仅对**指定列或查询**使用 ICU，不影响全库基线。

```sql
-- 创建 ICU 排序规则（按需创建）
-- 数字感知英文排序（'item2' < 'item10'）
CREATE COLLATION IF NOT EXISTS "en_numeric"
  (provider = icu, locale = 'en-u-kn-true');

-- 中文拼音排序
CREATE COLLATION IF NOT EXISTS "zh_pinyin"
  (provider = icu, locale = 'zh-u-co-pinyin');

-- 用法A：列级（该列默认按拼音/数字感知比较）
-- 示例：为昵称字段添加中文拼音排序
-- ALTER TABLE app.sys_user
--   ALTER COLUMN nickname TYPE VARCHAR(50) COLLATE "zh_pinyin";

-- 用法B：查询级（只在该语句里生效，推荐）
-- 示例：查询时按中文拼音排序
-- SELECT nickname FROM app.sys_user ORDER BY nickname COLLATE "zh_pinyin";
-- SELECT menu_name FROM app.sys_menu ORDER BY menu_name COLLATE "en_numeric";
```

> **说明**：
> - **按需使用**：仅在需要中文拼音排序或数字感知排序的列/查询中使用 ICU
> - **不影响全库**：全库基线仍为 `en_US.UTF-8`，确保跨平台兼容性
> - **PostgreSQL 版本**：ICU Collation 需要 PostgreSQL 15+，旧版本可忽略此节

### 2.7 脚本组织建议（可重入执行）

**脚本分层组织**，所有语句使用 `IF NOT EXISTS` / `OR REPLACE`，支持重复执行：

```
database/
├── 01_db.sql          # 数据库创建、扩展、参数、角色、Schema、权限
├── 02_tables.sql     # 建表（全部使用 app. 前缀）
├── 03_indexes.sql    # 索引创建
├── 04_triggers.sql   # 触发器创建
└── 05_seed.sql       # 初始化数据
```

**执行原则**：
- 所有 DDL 语句可重复执行，无副作用
- 统一使用 `IF NOT EXISTS` / `OR REPLACE`
- 避免使用 `DROP` 语句（除非明确需要重建）

### 2.8 快速自检清单

```sql
-- 检查数据库配置
SHOW server_encoding;    -- 应返回：UTF8
SHOW lc_collate;         -- 应返回：en_US.UTF-8
SHOW lc_ctype;           -- 应返回：en_US.UTF-8
SHOW timezone;           -- 应返回：UTC
SHOW log_timezone;       -- 应返回：UTC

-- 检查扩展
SELECT extname FROM pg_extension WHERE extname IN ('pgcrypto', 'pg_trgm', 'citext');
-- 应返回：pgcrypto, pg_trgm, citext

-- 检查 Schema 和权限
SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'app';
-- 应返回：app

-- 检查角色
SELECT rolname FROM pg_roles WHERE rolname IN ('gamehub_owner', 'gamehub_rw', 'gamehub_ro', 'gamehub_app');
-- 应返回：gamehub_owner, gamehub_rw, gamehub_ro, gamehub_app
```

---

## 三、RBAC 权限系统

### 3.1 用户表（sys_user）

```sql
CREATE TABLE sys_user (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    keycloak_user_id UUID NOT NULL UNIQUE, -- Keycloak 用户ID（对应 JWT 中 sub，必须非空）
    username CITEXT NOT NULL, -- 用户名（大小写不敏感）
    nickname VARCHAR(50), -- 昵称
    email CITEXT, -- 邮箱（大小写不敏感）
    phone VARCHAR(20), -- 手机号
    avatar_url VARCHAR(500), -- 头像URL
    user_type VARCHAR(20) DEFAULT 'NORMAL', -- 用户类型：NORMAL（普通用户）、ADMIN（管理员）
    dept_id UUID, -- 部门ID（应用层保证存在）
    status SMALLINT DEFAULT 1, -- 状态：0-禁用，1-启用
    remark VARCHAR(500), -- 备注
    player_id BIGINT NOT NULL DEFAULT nextval('player_id_seq'), -- 玩家ID（唯一数字ID，用于用户查找和分享，6-9位数字，使用序列自增）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法用户类型
    CONSTRAINT chk_user_type_valid CHECK (user_type IN ('NORMAL', 'ADMIN')),
    -- 约束：合法状态值
    CONSTRAINT chk_user_status_valid CHECK (status IN (0, 1)),
    -- 约束：玩家ID唯一性
    CONSTRAINT sys_user_player_id_key UNIQUE (player_id)
);

-- 索引
CREATE UNIQUE INDEX uk_sys_user_keycloak_id ON sys_user(keycloak_user_id) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX uk_sys_user_username_not_deleted ON sys_user(username) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX uk_sys_user_player_id ON sys_user(player_id) WHERE deleted_at IS NULL AND player_id IS NOT NULL;
CREATE INDEX idx_sys_user_email ON sys_user(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_user_phone ON sys_user(phone) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_user_dept ON sys_user(dept_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_user_status ON sys_user(status) WHERE deleted_at IS NULL;

-- 序列（用于 player_id 自增，如果已存在可跳过）
CREATE SEQUENCE IF NOT EXISTS player_id_seq
    START WITH 1000000
    INCREMENT BY 1
    MINVALUE 1000000
    MAXVALUE 999999999
    NO CYCLE;

-- 绑定序列归属，便于一起迁移/删除
ALTER SEQUENCE player_id_seq OWNED BY sys_user.player_id;

-- 表注释
COMMENT ON TABLE sys_user IS '用户表';
COMMENT ON COLUMN sys_user.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_user.keycloak_user_id IS 'Keycloak 用户ID（对应 JWT 中 sub，用于关联认证，必须非空，唯一）';
COMMENT ON COLUMN sys_user.username IS '用户名（唯一，大小写不敏感，使用 CITEXT 类型，必须非空）';
COMMENT ON COLUMN sys_user.nickname IS '昵称（用户显示名称）';
COMMENT ON COLUMN sys_user.email IS '邮箱（大小写不敏感，使用 CITEXT 类型）';
COMMENT ON COLUMN sys_user.phone IS '手机号';
COMMENT ON COLUMN sys_user.avatar_url IS '头像URL（用户头像图片地址）';
COMMENT ON COLUMN sys_user.user_type IS '用户类型枚举：NORMAL（普通用户）、ADMIN（管理员），默认 NORMAL';
COMMENT ON COLUMN sys_user.dept_id IS '部门ID（关联 sys_dept.id，应用层保证存在）';
COMMENT ON COLUMN sys_user.status IS '状态枚举：0（禁用）、1（启用），默认 1';
COMMENT ON COLUMN sys_user.remark IS '备注信息';
COMMENT ON COLUMN sys_user.player_id IS '玩家ID（唯一数字ID，用于用户查找和分享，6-9位数字，序列自增，必须非空）';
COMMENT ON COLUMN sys_user.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_user.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
COMMENT ON COLUMN sys_user.deleted_at IS '软删除时间（TIMESTAMPTZ，NULL 表示未删除）';
```

### 3.2 用户扩展表（sys_user_profile）

```sql
CREATE TABLE sys_user_profile (
    user_id UUID PRIMARY KEY, -- 用户ID（应用层保证存在）
    bio VARCHAR(500), -- 个人简介
    locale VARCHAR(10) DEFAULT 'zh-CN', -- 语言偏好
    timezone VARCHAR(50) DEFAULT 'Asia/Shanghai', -- 时区
    settings JSONB DEFAULT '{}'::jsonb, -- 用户设置（JSONB，如：{"theme": "dark", "notifications": true}）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_user_profile_locale ON sys_user_profile(locale);

-- 表注释
COMMENT ON TABLE sys_user_profile IS '用户扩展表';
COMMENT ON COLUMN sys_user_profile.user_id IS '用户ID（主键，关联 sys_user.id，应用层保证存在）';
COMMENT ON COLUMN sys_user_profile.bio IS '个人简介（用户自我介绍）';
COMMENT ON COLUMN sys_user_profile.locale IS '语言偏好（如：zh-CN、en-US），默认 zh-CN';
COMMENT ON COLUMN sys_user_profile.timezone IS '时区（如：Asia/Shanghai、UTC），默认 Asia/Shanghai';
COMMENT ON COLUMN sys_user_profile.settings IS '用户设置（JSONB，灵活存储用户偏好配置，如：{"theme": "dark", "notifications": true}）';
COMMENT ON COLUMN sys_user_profile.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_user_profile.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
```

### 3.3 部门表（sys_dept）

```sql
CREATE TABLE sys_dept (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    dept_name VARCHAR(100) NOT NULL, -- 部门名称
    dept_code VARCHAR(50) UNIQUE, -- 部门编码
    parent_id UUID, -- 父部门ID（应用层保证存在）
    leader_id UUID, -- 负责人用户ID（应用层保证存在）
    phone VARCHAR(20), -- 联系电话
    email VARCHAR(100), -- 邮箱
    sort_order INT DEFAULT 0, -- 排序
    status SMALLINT DEFAULT 1, -- 状态：0-禁用，1-启用
    settings JSONB DEFAULT '{}'::jsonb, -- 部门设置（JSONB）
    remark VARCHAR(500), -- 备注
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法状态值
    CONSTRAINT chk_dept_status_valid CHECK (status IN (0, 1))
);

-- 索引
CREATE UNIQUE INDEX uk_sys_dept_code_not_deleted ON sys_dept(dept_code) WHERE deleted_at IS NULL AND dept_code IS NOT NULL;
CREATE INDEX idx_sys_dept_parent ON sys_dept(parent_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_dept_leader ON sys_dept(leader_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_dept_status ON sys_dept(status) WHERE deleted_at IS NULL;

-- 表注释
COMMENT ON TABLE sys_dept IS '部门表';
COMMENT ON COLUMN sys_dept.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_dept.dept_name IS '部门名称（必须非空）';
COMMENT ON COLUMN sys_dept.dept_code IS '部门编码（唯一标识，用于业务编码）';
COMMENT ON COLUMN sys_dept.parent_id IS '父部门ID（关联 sys_dept.id，支持树形结构，NULL 表示顶级部门，应用层保证存在）';
COMMENT ON COLUMN sys_dept.leader_id IS '负责人用户ID（关联 sys_user.id，应用层保证存在）';
COMMENT ON COLUMN sys_dept.phone IS '联系电话';
COMMENT ON COLUMN sys_dept.email IS '邮箱';
COMMENT ON COLUMN sys_dept.sort_order IS '排序号（数字越小越靠前），默认 0';
COMMENT ON COLUMN sys_dept.status IS '状态枚举：0（禁用）、1（启用），默认 1';
COMMENT ON COLUMN sys_dept.settings IS '部门设置（JSONB，灵活存储部门配置信息）';
COMMENT ON COLUMN sys_dept.remark IS '备注信息';
COMMENT ON COLUMN sys_dept.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_dept.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
COMMENT ON COLUMN sys_dept.deleted_at IS '软删除时间（TIMESTAMPTZ，NULL 表示未删除）';
```

### 3.4 角色表（sys_role）

```sql
CREATE TABLE sys_role (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role_code VARCHAR(50) NOT NULL UNIQUE, -- 角色编码
    role_name VARCHAR(50) NOT NULL, -- 角色名称
    role_desc VARCHAR(200), -- 角色描述
    data_scope VARCHAR(20) DEFAULT 'ALL', -- 数据权限范围：ALL（全部）、DEPT（本部门）、DEPT_AND_CHILD（本部门及子部门）、SELF（仅自己）
    sort_order INT DEFAULT 0, -- 排序
    status SMALLINT DEFAULT 1, -- 状态：0-禁用，1-启用
    remark VARCHAR(500), -- 备注
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法数据权限范围
    CONSTRAINT chk_role_data_scope_valid CHECK (data_scope IN ('ALL', 'DEPT', 'DEPT_AND_CHILD', 'SELF')),
    -- 约束：合法状态值
    CONSTRAINT chk_role_status_valid CHECK (status IN (0, 1))
);

-- 索引
CREATE UNIQUE INDEX uk_sys_role_code_not_deleted ON sys_role(role_code) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_role_status ON sys_role(status) WHERE deleted_at IS NULL;

-- 表注释
COMMENT ON TABLE sys_role IS '角色表';
COMMENT ON COLUMN sys_role.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_role.role_code IS '角色编码（唯一标识，用于业务编码，必须非空）';
COMMENT ON COLUMN sys_role.role_name IS '角色名称（必须非空）';
COMMENT ON COLUMN sys_role.role_desc IS '角色描述（角色说明信息）';
COMMENT ON COLUMN sys_role.data_scope IS '数据权限范围枚举：ALL（全部数据）、DEPT（本部门数据）、DEPT_AND_CHILD（本部门及子部门数据）、SELF（仅自己数据），默认 ALL';
COMMENT ON COLUMN sys_role.sort_order IS '排序号（数字越小越靠前），默认 0';
COMMENT ON COLUMN sys_role.status IS '状态枚举：0（禁用）、1（启用），默认 1';
COMMENT ON COLUMN sys_role.remark IS '备注信息';
COMMENT ON COLUMN sys_role.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_role.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
COMMENT ON COLUMN sys_role.deleted_at IS '软删除时间（TIMESTAMPTZ，NULL 表示未删除）';
```

### 3.5 权限表（sys_permission）

```sql
CREATE TABLE sys_permission (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    permission_code VARCHAR(100) NOT NULL UNIQUE, -- 权限编码
    permission_name VARCHAR(100) NOT NULL, -- 权限名称
    permission_type VARCHAR(20) NOT NULL, -- 权限类型：MENU（菜单）、BUTTON（按钮）、API（接口）
    resource_type VARCHAR(50), -- 资源类型
    resource_path VARCHAR(500), -- 资源路径
    http_method VARCHAR(10), -- HTTP方法（GET、POST、PUT、DELETE等）
    data_expr JSONB DEFAULT '{}'::jsonb, -- 数据权限表达式（JSONB，灵活的数据权限规则）
    sort_order INT DEFAULT 0, -- 排序
    status SMALLINT DEFAULT 1, -- 状态：0-禁用，1-启用
    remark VARCHAR(500), -- 备注
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法权限类型
    CONSTRAINT chk_permission_type_valid CHECK (permission_type IN ('MENU', 'BUTTON', 'API')),
    -- 约束：合法HTTP方法
    CONSTRAINT chk_permission_http_method_valid CHECK (
        http_method IS NULL OR http_method IN ('GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS')
    ),
    -- 约束：合法状态值
    CONSTRAINT chk_permission_status_valid CHECK (status IN (0, 1))
);

-- 索引
CREATE UNIQUE INDEX uk_sys_permission_code_not_deleted ON sys_permission(permission_code) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_permission_type ON sys_permission(permission_type) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_permission_resource ON sys_permission(resource_type, resource_path) WHERE deleted_at IS NULL;

-- 唯一索引：API 权限防重复（同一 resource_path + http_method 组合唯一）
CREATE UNIQUE INDEX uk_sys_permission_api ON sys_permission(resource_path, http_method) 
    WHERE deleted_at IS NULL AND resource_path IS NOT NULL AND http_method IS NOT NULL;

-- 表注释
COMMENT ON TABLE sys_permission IS '权限表';
COMMENT ON COLUMN sys_permission.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_permission.permission_code IS '权限编码（唯一标识，用于业务编码，必须非空）';
COMMENT ON COLUMN sys_permission.permission_name IS '权限名称（必须非空）';
COMMENT ON COLUMN sys_permission.permission_type IS '权限类型枚举：MENU（菜单权限）、BUTTON（按钮权限）、API（接口权限），必须非空';
COMMENT ON COLUMN sys_permission.resource_type IS '资源类型（资源分类标识）';
COMMENT ON COLUMN sys_permission.resource_path IS '资源路径（API 路径或资源标识）';
COMMENT ON COLUMN sys_permission.http_method IS 'HTTP方法枚举：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS（API 权限时使用）';
COMMENT ON COLUMN sys_permission.data_expr IS '数据权限表达式（JSONB，灵活的数据权限规则，如：{"dept_ids": [1,2,3], "user_ids": [10,20]}）';
COMMENT ON COLUMN sys_permission.sort_order IS '排序号（数字越小越靠前），默认 0';
COMMENT ON COLUMN sys_permission.status IS '状态枚举：0（禁用）、1（启用），默认 1';
COMMENT ON COLUMN sys_permission.remark IS '备注信息';
COMMENT ON COLUMN sys_permission.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_permission.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
COMMENT ON COLUMN sys_permission.deleted_at IS '软删除时间（TIMESTAMPTZ，NULL 表示未删除）';
```

### 3.6 菜单表（sys_menu）

```sql
CREATE TABLE sys_menu (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    menu_name VARCHAR(100) NOT NULL, -- 菜单名称
    menu_type VARCHAR(20) NOT NULL, -- 菜单类型：DIRECTORY（目录）、MENU（菜单）、BUTTON（按钮）
    parent_id UUID, -- 父菜单ID（应用层保证存在）
    path VARCHAR(200), -- 路由路径
    component VARCHAR(200), -- 组件路径
    icon VARCHAR(100), -- 图标
    permission_code VARCHAR(100), -- 权限编码（关联权限表）
    route_meta JSONB DEFAULT '{}'::jsonb, -- 路由元数据（JSONB，前端路由配置）
    sort_order INT DEFAULT 0, -- 排序
    status SMALLINT DEFAULT 1, -- 状态：0-禁用，1-启用
    remark VARCHAR(500), -- 备注
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法菜单类型
    CONSTRAINT chk_menu_type_valid CHECK (menu_type IN ('DIRECTORY', 'MENU', 'BUTTON')),
    -- 约束：合法状态值
    CONSTRAINT chk_menu_status_valid CHECK (status IN (0, 1))
);

-- 索引
CREATE UNIQUE INDEX uk_menu_path ON sys_menu(path) WHERE deleted_at IS NULL AND path IS NOT NULL;
CREATE INDEX idx_sys_menu_parent ON sys_menu(parent_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_menu_type ON sys_menu(menu_type) WHERE deleted_at IS NULL;
CREATE INDEX idx_sys_menu_status ON sys_menu(status) WHERE deleted_at IS NULL;

-- 唯一索引：菜单命名在同父级下唯一（同一父级下菜单名不能重复）
CREATE UNIQUE INDEX uk_sys_menu_parent_name ON sys_menu(parent_id, menu_name) WHERE deleted_at IS NULL;

-- 索引：权限联动查询（通过 permission_code 关联权限表）
CREATE INDEX idx_sys_menu_permission_code ON sys_menu(permission_code) WHERE deleted_at IS NULL AND permission_code IS NOT NULL;

-- 表注释
COMMENT ON TABLE sys_menu IS '菜单表';
COMMENT ON COLUMN sys_menu.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_menu.menu_name IS '菜单名称（必须非空，同一父级下唯一）';
COMMENT ON COLUMN sys_menu.menu_type IS '菜单类型枚举：DIRECTORY（目录/文件夹）、MENU（菜单项）、BUTTON（按钮），必须非空';
COMMENT ON COLUMN sys_menu.parent_id IS '父菜单ID（关联 sys_menu.id，NULL 表示顶级菜单，应用层保证存在）';
COMMENT ON COLUMN sys_menu.path IS '路由路径（前端路由地址，全局唯一）';
COMMENT ON COLUMN sys_menu.component IS '组件路径（前端组件文件路径）';
COMMENT ON COLUMN sys_menu.icon IS '图标（菜单图标标识）';
COMMENT ON COLUMN sys_menu.permission_code IS '权限编码（关联 sys_permission.permission_code，用于权限控制）';
COMMENT ON COLUMN sys_menu.route_meta IS '路由元数据（JSONB，前端路由配置，如：{"title": "首页", "hidden": false, "affix": true}）';
COMMENT ON COLUMN sys_menu.sort_order IS '排序号（数字越小越靠前），默认 0';
COMMENT ON COLUMN sys_menu.status IS '状态枚举：0（禁用）、1（启用），默认 1';
COMMENT ON COLUMN sys_menu.remark IS '备注信息';
COMMENT ON COLUMN sys_menu.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
COMMENT ON COLUMN sys_menu.updated_at IS '更新时间（TIMESTAMPTZ，触发器自动更新）';
COMMENT ON COLUMN sys_menu.deleted_at IS '软删除时间（TIMESTAMPTZ，NULL 表示未删除）';
```

### 3.7 用户角色关联表（sys_user_role）

```sql
CREATE TABLE sys_user_role (
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    role_id UUID NOT NULL, -- 角色ID（应用层保证存在）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id) -- 复合主键，直接保证唯一性
);

-- 索引（按 role_id 反向查询时使用）
CREATE INDEX idx_user_role_role ON sys_user_role(role_id);

-- 表注释
COMMENT ON TABLE sys_user_role IS '用户角色关联表（多对多关系）';
COMMENT ON COLUMN sys_user_role.user_id IS '用户ID（关联 sys_user.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_user_role.role_id IS '角色ID（关联 sys_role.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_user_role.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
```

### 3.8 角色权限关联表（sys_role_permission）

```sql
CREATE TABLE sys_role_permission (
    role_id UUID NOT NULL, -- 角色ID（应用层保证存在）
    permission_id UUID NOT NULL, -- 权限ID（应用层保证存在）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_id, permission_id) -- 复合主键，直接保证唯一性
);

-- 索引（按 permission_id 反向查询时使用）
CREATE INDEX idx_role_permission_permission ON sys_role_permission(permission_id);

-- 表注释
COMMENT ON TABLE sys_role_permission IS '角色权限关联表（多对多关系）';
COMMENT ON COLUMN sys_role_permission.role_id IS '角色ID（关联 sys_role.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_role_permission.permission_id IS '权限ID（关联 sys_permission.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_role_permission.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
```

### 3.9 角色菜单关联表（sys_role_menu）

```sql
CREATE TABLE sys_role_menu (
    role_id UUID NOT NULL, -- 角色ID（应用层保证存在）
    menu_id UUID NOT NULL, -- 菜单ID（应用层保证存在）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (role_id, menu_id) -- 复合主键，直接保证唯一性
);

-- 索引（按 menu_id 反向查询时使用）
CREATE INDEX idx_role_menu_menu ON sys_role_menu(menu_id);

-- 表注释
COMMENT ON TABLE sys_role_menu IS '角色菜单关联表（多对多关系）';
COMMENT ON COLUMN sys_role_menu.role_id IS '角色ID（关联 sys_role.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_role_menu.menu_id IS '菜单ID（关联 sys_menu.id，复合主键之一，应用层保证存在）';
COMMENT ON COLUMN sys_role_menu.created_at IS '创建时间（TIMESTAMPTZ，自动设置）';
```

### 3.10 登录日志表（sys_login_log）

```sql
CREATE TABLE sys_login_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sys_user_id UUID, -- 用户ID（应用层保证存在）
    username VARCHAR(50), -- 用户名（冗余，避免JOIN）
    login_type VARCHAR(20), -- 登录类型：PASSWORD（密码）、OAUTH（第三方）
    ip_address VARCHAR(50), -- IP地址
    location VARCHAR(200), -- 登录地点
    device_type VARCHAR(50), -- 设备类型
    browser VARCHAR(100), -- 浏览器
    os VARCHAR(100), -- 操作系统
    status SMALLINT, -- 状态：0-失败，1-成功
    failure_reason VARCHAR(500), -- 失败原因
    login_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 约束：合法登录类型
    CONSTRAINT chk_login_type_valid CHECK (login_type IS NULL OR login_type IN ('PASSWORD', 'OAUTH')),
    -- 约束：合法状态值
    CONSTRAINT chk_login_status_valid CHECK (status IS NULL OR status IN (0, 1))
);

-- 索引
CREATE INDEX idx_login_log_user ON sys_login_log(sys_user_id);
CREATE INDEX idx_login_log_time ON sys_login_log(login_time DESC);
CREATE INDEX idx_login_log_ip ON sys_login_log(ip_address);
CREATE INDEX idx_login_log_status ON sys_login_log(status);

-- 表注释
COMMENT ON TABLE sys_login_log IS '登录日志表';
COMMENT ON COLUMN sys_login_log.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_login_log.sys_user_id IS '用户ID（关联 sys_user.id，应用层保证存在）';
COMMENT ON COLUMN sys_login_log.username IS '用户名（冗余字段，避免JOIN查询）';
COMMENT ON COLUMN sys_login_log.login_type IS '登录类型枚举：PASSWORD（密码登录）、OAUTH（第三方登录）';
COMMENT ON COLUMN sys_login_log.ip_address IS 'IP地址（登录时的客户端IP）';
COMMENT ON COLUMN sys_login_log.location IS '登录地点（根据IP解析的地理位置）';
COMMENT ON COLUMN sys_login_log.device_type IS '设备类型（如：PC、Mobile、Tablet）';
COMMENT ON COLUMN sys_login_log.browser IS '浏览器（如：Chrome、Firefox、Safari）';
COMMENT ON COLUMN sys_login_log.os IS '操作系统（如：Windows、macOS、Linux、iOS、Android）';
COMMENT ON COLUMN sys_login_log.status IS '状态枚举：0（登录失败）、1（登录成功）';
COMMENT ON COLUMN sys_login_log.failure_reason IS '失败原因（登录失败时的错误信息）';
COMMENT ON COLUMN sys_login_log.login_time IS '登录时间（TIMESTAMPTZ，自动设置）';
```

### 3.11 操作日志表（sys_op_log）

```sql
CREATE TABLE sys_op_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sys_user_id UUID, -- 用户ID（应用层保证存在）
    username VARCHAR(50), -- 用户名（冗余）
    target_name VARCHAR(100), -- 操作目标名称
    method VARCHAR(20), -- 请求方法（GET、POST、PUT、DELETE等）
    request_url VARCHAR(500), -- 请求URL
    request_params TEXT, -- 请求参数
    response_code INT, -- 响应状态码
    ip_address VARCHAR(50), -- IP地址
    user_agent VARCHAR(500), -- 用户代理
    error_message TEXT, -- 错误信息
    duration_ms INT, -- 耗时（毫秒）
    op_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_op_log_user ON sys_op_log(sys_user_id);
CREATE INDEX idx_op_log_time ON sys_op_log(op_time DESC);
CREATE INDEX idx_op_log_url ON sys_op_log(request_url);
CREATE INDEX idx_op_log_method ON sys_op_log(method);

-- 表注释
COMMENT ON TABLE sys_op_log IS '操作日志表';
COMMENT ON COLUMN sys_op_log.id IS '主键ID（UUID）';
COMMENT ON COLUMN sys_op_log.sys_user_id IS '用户ID（关联 sys_user.id，应用层保证存在）';
COMMENT ON COLUMN sys_op_log.username IS '用户名（冗余字段，避免JOIN查询）';
COMMENT ON COLUMN sys_op_log.target_name IS '操作目标名称（被操作的对象名称）';
COMMENT ON COLUMN sys_op_log.method IS '请求方法（HTTP方法：GET、POST、PUT、DELETE、PATCH等）';
COMMENT ON COLUMN sys_op_log.request_url IS '请求URL（完整的请求路径）';
COMMENT ON COLUMN sys_op_log.request_params IS '请求参数（请求体或查询参数，TEXT类型）';
COMMENT ON COLUMN sys_op_log.response_code IS '响应状态码（HTTP状态码，如：200、404、500）';
COMMENT ON COLUMN sys_op_log.ip_address IS 'IP地址（操作时的客户端IP）';
COMMENT ON COLUMN sys_op_log.user_agent IS '用户代理（浏览器User-Agent信息）';
COMMENT ON COLUMN sys_op_log.error_message IS '错误信息（操作失败时的错误详情）';
COMMENT ON COLUMN sys_op_log.duration_ms IS '操作耗时（毫秒，从请求开始到响应结束的时间）';
COMMENT ON COLUMN sys_op_log.op_time IS '操作时间（TIMESTAMPTZ，自动设置）';
```

> **注意**：`sys_login_log` 和 `sys_op_log` 是高频写入表，建议按时间分区以提高查询性能和管理便利性。分区模板见 3.13 节。

### 3.12 日志表分区模板（可选，规模化准备）

```sql
-- 登录日志表按月分区（示例：2024年1月）
CREATE TABLE sys_login_log_2024_01 PARTITION OF sys_login_log
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 操作日志表按月分区（示例：2024年1月）
CREATE TABLE sys_op_log_2024_01 PARTITION OF sys_op_log
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 注意：需要先将原表改为分区表（使用 ALTER TABLE ... PARTITION BY RANGE）
-- 建议：使用定时任务每月自动创建下月分区，3个月前的分区数据归档到冷存储
```

> **说明**：
> - **分区策略**：按月分区，便于数据管理和归档
> - **自动创建**：建议使用定时任务（如 cron）每月初自动创建下月分区
> - **数据归档**：3个月前的分区数据可归档到冷存储，释放主库空间
> - **查询优化**：PostgreSQL 会自动路由查询到对应分区，无需应用层处理

### 3.13 触发器

```sql
-- 自动更新 updated_at 触发器函数
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 为需要自动更新 updated_at 的表创建触发器
CREATE TRIGGER trg_sys_user_updated_at
    BEFORE UPDATE ON sys_user
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_sys_user_profile_updated_at
    BEFORE UPDATE ON sys_user_profile
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_sys_dept_updated_at
    BEFORE UPDATE ON sys_dept
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_sys_role_updated_at
    BEFORE UPDATE ON sys_role
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_sys_permission_updated_at
    BEFORE UPDATE ON sys_permission
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_sys_menu_updated_at
    BEFORE UPDATE ON sys_menu
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## 四、游戏模块

### 4.1 游戏类型表（game_type）

```sql
CREATE TABLE game_type (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_code VARCHAR(50) NOT NULL UNIQUE,
    game_name VARCHAR(50) NOT NULL,
    game_desc VARCHAR(200),
    icon_url VARCHAR(500),
    min_players INT DEFAULT 2,
    max_players INT DEFAULT 2,
    status SMALLINT DEFAULT 1, -- 0-禁用，1-启用
    sort_order INT DEFAULT 0,
    config JSONB DEFAULT '{}'::jsonb, -- 游戏配置（规则、棋盘大小等）
    remark VARCHAR(500),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法状态值
    CONSTRAINT chk_game_type_status_valid CHECK (status IN (0, 1)),
    -- 约束：玩家数合理性
    CONSTRAINT chk_game_type_players_valid CHECK (min_players > 0 AND max_players >= min_players)
);

-- 索引
CREATE UNIQUE INDEX uk_game_type_code_not_deleted ON game_type(game_code) WHERE deleted_at IS NULL;
CREATE INDEX idx_game_type_status ON game_type(status);
CREATE INDEX idx_game_type_status_sort ON game_type(status, sort_order) WHERE deleted_at IS NULL;

-- 表注释
COMMENT ON TABLE game_type IS '游戏类型表';
COMMENT ON COLUMN game_type.game_code IS '游戏编码（如：gomoku, chess, go）';
COMMENT ON COLUMN game_type.game_name IS '游戏名称（如：五子棋、象棋、围棋）';
COMMENT ON COLUMN game_type.min_players IS '最少玩家数';
COMMENT ON COLUMN game_type.max_players IS '最多玩家数';
COMMENT ON COLUMN game_type.config IS '游戏配置（JSONB，如：{"board_size": 15, "rules": ["STANDARD", "RENJU"]}）';
```

### 4.2 游戏房间表（game_room）

```sql
CREATE TABLE game_room (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_code VARCHAR(50) UNIQUE, -- 房间号（可选的短码，便于分享）
    game_type_id UUID NOT NULL, -- 游戏类型ID（应用层保证存在）
    owner_id UUID NOT NULL, -- 房主用户ID（应用层保证存在）
    client_op_id VARCHAR(64), -- 客户端操作ID（用于幂等，前端生成UUID）
    room_name VARCHAR(100), -- 房间名称
    room_mode VARCHAR(20) NOT NULL, -- PVP（人人对战）、PVE（人机对战）
    room_status VARCHAR(20) DEFAULT 'WAITING', -- WAITING（等待中）、PLAYING（游戏中）、FINISHED（已结束）、CLOSED（已关闭）
    max_players INT DEFAULT 2 NOT NULL, -- 最大玩家数（必须非空，默认2）
    current_players INT DEFAULT 0 NOT NULL, -- 当前玩家数（由触发器自动同步，应用层也可手动维护，必须非空）
    password_hash VARCHAR(200), -- 房间密码哈希（可选，使用 bcrypt/argon2 等算法）
    is_private BOOLEAN DEFAULT FALSE, -- 是否私密房间
    config JSONB DEFAULT '{}'::jsonb, -- 房间配置（规则、AI难度等）
    started_at TIMESTAMPTZ, -- 开始时间
    finished_at TIMESTAMPTZ, -- 结束时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法房间模式
    CONSTRAINT chk_room_mode_valid CHECK (room_mode IN ('PVP', 'PVE')),
    -- 约束：状态值合法
    CONSTRAINT chk_room_status CHECK (
        room_status IN ('WAITING', 'PLAYING', 'FINISHED', 'CLOSED')
    ),
    -- 约束：私密房间必须有密码哈希
    CONSTRAINT chk_private_password CHECK (
        (is_private = FALSE) OR (is_private = TRUE AND password_hash IS NOT NULL)
    ),
    -- 约束：终态房间不允许修改（应用层也需要校验）
    CONSTRAINT chk_room_final_state CHECK (
        room_status NOT IN ('FINISHED', 'CLOSED') OR 
        (room_status IN ('FINISHED', 'CLOSED') AND finished_at IS NOT NULL)
    ),
    -- 约束：玩家数合理性
    CONSTRAINT chk_players_count CHECK (current_players >= 0 AND current_players <= max_players)
);

-- 索引
CREATE UNIQUE INDEX uk_game_room_code_not_deleted ON game_room(room_code) WHERE deleted_at IS NULL AND room_code IS NOT NULL;
CREATE INDEX idx_game_room_game_type ON game_room(game_type_id);
CREATE INDEX idx_game_room_owner ON game_room(owner_id);

-- 注意：不使用外键约束，应用层保证 game_type_id 和 owner_id 的有效性
CREATE INDEX idx_game_room_status ON game_room(room_status);
CREATE INDEX idx_game_room_status_created ON game_room(room_status, created_at DESC) WHERE deleted_at IS NULL;

-- 唯一索引：客户端操作ID幂等（防止重复建房）
CREATE UNIQUE INDEX uk_game_room_client_op ON game_room(client_op_id) WHERE client_op_id IS NOT NULL AND deleted_at IS NULL;

-- 表注释
COMMENT ON TABLE game_room IS '游戏房间表';
COMMENT ON COLUMN game_room.room_code IS '房间号（短码，便于分享）';
COMMENT ON COLUMN game_room.client_op_id IS '客户端操作ID（前端生成UUID，用于幂等，防止重复建房）';
COMMENT ON COLUMN game_room.room_mode IS '房间模式：PVP（人人对战）、PVE（人机对战），必须非空';
COMMENT ON COLUMN game_room.room_status IS '房间状态：WAITING（等待中）、PLAYING（游戏中）、FINISHED（已结束）、CLOSED（已关闭），默认WAITING';
COMMENT ON COLUMN game_room.max_players IS '最大玩家数（必须非空，默认2）';
COMMENT ON COLUMN game_room.current_players IS '当前玩家数（由触发器自动同步 game_room_player 表，必须非空，范围：0 到 max_players）';
COMMENT ON COLUMN game_room.password_hash IS '房间密码哈希（使用 bcrypt/argon2 等安全算法，不可明文存储）';
COMMENT ON COLUMN game_room.config IS '房间配置（JSONB，如：{"rule": "STANDARD", "ai_difficulty": "medium"}）';
```

### 4.3 房间玩家表（game_room_player）

```sql
CREATE TABLE game_room_player (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID NOT NULL, -- 房间ID（应用层保证存在）
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    player_role VARCHAR(20) DEFAULT 'PLAYER', -- PLAYER（玩家）、OBSERVER（观战者）
    player_side VARCHAR(10), -- 执子方（如：X、O、BLACK、WHITE，根据游戏类型不同）
    seat_key VARCHAR(50), -- 座位密钥（用于断线重连）
    is_ready BOOLEAN DEFAULT FALSE, -- 是否准备
    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMPTZ, -- 离开时间
    UNIQUE(room_id, user_id),
    -- 约束：合法角色值
    CONSTRAINT chk_player_role_valid CHECK (
        player_role IS NULL OR player_role IN ('PLAYER', 'OBSERVER')
    ),
    -- 约束：合法边值
    CONSTRAINT chk_side_valid CHECK (
        player_side IS NULL OR player_side IN ('X','O','BLACK','WHITE')
    )
);

-- 索引
CREATE INDEX idx_room_player_room ON game_room_player(room_id);
CREATE INDEX idx_room_player_user ON game_room_player(user_id);
CREATE INDEX idx_room_player_seat_key ON game_room_player(seat_key) WHERE seat_key IS NOT NULL;

-- 唯一索引：同一房间，每个 side 仅允许 1 人（NULL 不约束，支持观战者）
CREATE UNIQUE INDEX uk_room_side ON game_room_player(room_id, player_side) WHERE player_side IS NOT NULL;

-- 唯一索引：同一房间，seat_key 唯一（支持断线重连幂等）
CREATE UNIQUE INDEX uk_room_seat_key ON game_room_player(room_id, seat_key) WHERE seat_key IS NOT NULL;

-- 注意：不使用外键约束，应用层保证 room_id 和 user_id 的有效性
-- 删除房间或用户时，应用层负责清理关联数据

-- 表注释
COMMENT ON TABLE game_room_player IS '房间玩家表';
COMMENT ON COLUMN game_room_player.player_role IS '玩家角色：PLAYER（玩家）、OBSERVER（观战者），默认PLAYER';
COMMENT ON COLUMN game_room_player.player_side IS '执子方（如：X、O、BLACK、WHITE，NULL表示观战者）';
COMMENT ON COLUMN game_room_player.seat_key IS '座位密钥（用于断线重连，同一房间内唯一）';
COMMENT ON COLUMN game_room_player.joined_at IS '加入时间（必须非空）';
```

### 4.4 游戏对局表（game_match）

```sql
CREATE TABLE game_match (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    match_code VARCHAR(50) UNIQUE, -- 对局编号
    room_id UUID, -- 所属房间ID（可为空，匹配对局可能没有房间，应用层保证存在）
    game_type_id UUID NOT NULL, -- 游戏类型ID（应用层保证存在）
    match_type VARCHAR(20) NOT NULL, -- ROOM（房间对局）、MATCH（匹配对局）、FRIEND（好友对局）
    match_status VARCHAR(20) DEFAULT 'PLAYING', -- PLAYING（进行中）、FINISHED（已结束）、ABANDONED（已放弃）
    player1_id UUID NOT NULL, -- 玩家1用户ID（应用层保证存在）
    player2_id UUID, -- 玩家2用户ID（PVE时为空，应用层保证存在）
    player1_side VARCHAR(10), -- 玩家1执子方
    player2_side VARCHAR(10), -- 玩家2执子方
    winner_id UUID, -- 获胜者用户ID（平局为空，应用层保证存在）
    result VARCHAR(20), -- WIN（一方获胜）、DRAW（平局）、ABANDON（放弃）
    match_config JSONB DEFAULT '{}'::jsonb, -- 对局配置
    started_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    finished_at TIMESTAMPTZ,
    duration_seconds INT, -- 对局时长（秒）
    total_moves INT DEFAULT 0, -- 总步数
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ, -- 软删除支持
    -- 约束：合法对局类型
    CONSTRAINT chk_match_type_valid CHECK (match_type IN ('ROOM', 'MATCH', 'FRIEND')),
    -- 约束：状态值合法
    CONSTRAINT chk_match_status CHECK (
        match_status IN ('PLAYING', 'FINISHED', 'ABANDONED')
    ),
    -- 约束：结果与胜者一致性（平局无胜者，胜利必须有胜者）
    CONSTRAINT chk_match_result_winner CHECK (
        (result = 'DRAW' AND winner_id IS NULL)
        OR (result = 'WIN' AND winner_id IS NOT NULL)
        OR (result = 'ABANDON')
        OR (result IS NULL)
    ),
    -- 约束：终态对局不允许修改（应用层也需要校验）
    CONSTRAINT chk_match_final_state CHECK (
        match_status NOT IN ('FINISHED', 'ABANDONED') OR 
        (match_status IN ('FINISHED', 'ABANDONED') AND finished_at IS NOT NULL)
    )
);

-- 索引
CREATE UNIQUE INDEX uk_game_match_code ON game_match(match_code) WHERE match_code IS NOT NULL;
CREATE INDEX idx_game_match_room ON game_match(room_id) WHERE room_id IS NOT NULL;
CREATE INDEX idx_game_match_game_type ON game_match(game_type_id);
CREATE INDEX idx_game_match_player1 ON game_match(player1_id);
CREATE INDEX idx_game_match_player2 ON game_match(player2_id) WHERE player2_id IS NOT NULL;
CREATE INDEX idx_game_match_status ON game_match(match_status);
CREATE INDEX idx_game_match_started ON game_match(started_at DESC);
CREATE INDEX idx_game_match_players ON game_match(player1_id, player2_id) WHERE player2_id IS NOT NULL;
CREATE INDEX idx_match_not_deleted ON game_match(id) WHERE deleted_at IS NULL;

-- 注意：不使用外键约束，应用层保证所有ID的有效性
-- 删除用户时，应用层负责处理历史记录（如：winner_id 置为 NULL 或保留）

-- 表注释
COMMENT ON TABLE game_match IS '游戏对局表';
COMMENT ON COLUMN game_match.match_type IS '对局类型：ROOM（房间对局）、MATCH（匹配对局）、FRIEND（好友对局），必须非空';
COMMENT ON COLUMN game_match.match_status IS '对局状态：PLAYING（进行中）、FINISHED（已结束）、ABANDONED（已放弃），默认PLAYING';
COMMENT ON COLUMN game_match.result IS '对局结果：WIN（一方获胜）、DRAW（平局）、ABANDON（放弃）';
COMMENT ON COLUMN game_match.match_config IS '对局配置（JSONB，如：{"rule": "STANDARD", "board_size": 15}）';
COMMENT ON COLUMN game_match.started_at IS '开始时间（必须非空，默认当前时间）';
COMMENT ON COLUMN game_match.deleted_at IS '软删除时间（终态对局建议保留，不删除）';
```

### 4.5 对局详情表（game_match_detail）

```sql
CREATE TABLE game_match_detail (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    match_id UUID NOT NULL, -- 对局ID（应用层保证存在）
    move_number INT NOT NULL, -- 步数（从1开始）
    player_id UUID NOT NULL, -- 玩家用户ID（应用层保证存在）
    move_data JSONB NOT NULL, -- 走子数据（JSONB，格式根据游戏类型不同）
    move_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, -- 走子时间
    is_valid BOOLEAN DEFAULT TRUE, -- 是否有效步
    remark VARCHAR(500)
);

-- 索引
CREATE INDEX idx_match_detail_match ON game_match_detail(match_id);
CREATE INDEX idx_match_detail_match_move ON game_match_detail(match_id, move_number);
CREATE INDEX idx_match_detail_player ON game_match_detail(player_id);
CREATE INDEX idx_match_detail_time ON game_match_detail(move_time);

-- 唯一索引：同一对局，步数唯一（防止重复，保证重放/复盘正确性）
CREATE UNIQUE INDEX uk_match_move ON game_match_detail(match_id, move_number);

-- 注意：不使用外键约束，应用层保证 match_id 和 player_id 的有效性
-- 删除对局时，应用层负责清理详情数据

-- 表注释
COMMENT ON TABLE game_match_detail IS '对局详情表（记录每一步走子）';
COMMENT ON COLUMN game_match_detail.move_number IS '步数（从1开始，同一对局内唯一）';
COMMENT ON COLUMN game_match_detail.move_data IS '走子数据（JSONB，如：{"x": 7, "y": 7, "piece": "X"}）';
```

### 4.6 对局快照表（game_match_snapshot）

```sql
CREATE TABLE game_match_snapshot (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    match_id UUID NOT NULL, -- 对局ID（应用层保证存在）
    snapshot_type VARCHAR(20) NOT NULL, -- BOARD（棋盘快照）、STATE（状态快照）
    snapshot_data JSONB NOT NULL, -- 快照数据
    step_number INT, -- 对应步数
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_match_snapshot_match ON game_match_snapshot(match_id);
CREATE INDEX idx_match_snapshot_match_step ON game_match_snapshot(match_id, step_number) WHERE step_number IS NOT NULL;

-- 注意：不使用外键约束，应用层保证 match_id 的有效性
-- 删除对局时，应用层负责清理快照数据

-- 表注释
COMMENT ON TABLE game_match_snapshot IS '对局快照表（用于复盘、断线重连）';
COMMENT ON COLUMN game_match_snapshot.snapshot_type IS '快照类型：BOARD（棋盘快照）、STATE（状态快照）';
COMMENT ON COLUMN game_match_snapshot.snapshot_data IS '快照数据（JSONB，完整的棋盘或状态信息）';
```

---

## 五、社交模块

### 5.1 好友关系表（user_friend）

```sql
CREATE TABLE user_friend (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    friend_id UUID NOT NULL, -- 好友用户ID（应用层保证存在）
    friend_nickname VARCHAR(50), -- 好友备注昵称
    friend_group VARCHAR(50), -- 好友分组
    status VARCHAR(20) DEFAULT 'ACTIVE', -- ACTIVE（正常）、BLOCKED（已拉黑）
    is_favorite BOOLEAN DEFAULT FALSE, -- 是否特别关心
    last_interaction_time TIMESTAMPTZ, -- 最后互动时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, friend_id),
    -- 约束：不能加自己为好友
    CONSTRAINT chk_not_self_friend CHECK (user_id != friend_id),
    -- 约束：合法状态值
    CONSTRAINT chk_friend_status_valid CHECK (status IN ('ACTIVE', 'BLOCKED'))
);

-- 索引
CREATE INDEX idx_user_friend_user ON user_friend(user_id);
CREATE INDEX idx_user_friend_friend ON user_friend(friend_id);
CREATE INDEX idx_user_friend_status ON user_friend(user_id, status);
CREATE INDEX idx_user_friend_interaction ON user_friend(user_id, last_interaction_time DESC) WHERE last_interaction_time IS NOT NULL;

-- 注意：不使用外键约束，应用层保证 user_id 和 friend_id 的有效性
-- 删除用户时，应用层负责清理好友关系

-- 表注释
COMMENT ON TABLE user_friend IS '好友关系表';
COMMENT ON COLUMN user_friend.friend_nickname IS '好友备注昵称';
COMMENT ON COLUMN user_friend.friend_group IS '好友分组（如：游戏好友、现实好友）';
COMMENT ON COLUMN user_friend.status IS '关系状态：ACTIVE（正常）、BLOCKED（已拉黑）';
```

### 5.2 好友申请表（friend_request）

```sql
CREATE TABLE friend_request (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    requester_id UUID NOT NULL, -- 申请人用户ID（应用层保证存在）
    receiver_id UUID NOT NULL, -- 接收人用户ID（应用层保证存在）
    request_message VARCHAR(200), -- 申请留言
    status VARCHAR(20) DEFAULT 'PENDING', -- PENDING（待处理）、ACCEPTED（已接受）、REJECTED（已拒绝）、EXPIRED（已过期）
    handled_at TIMESTAMPTZ, -- 处理时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 约束：不能向自己发送申请
    CONSTRAINT chk_not_self_request CHECK (requester_id != receiver_id),
    -- 约束：合法状态值
    CONSTRAINT chk_request_status_valid CHECK (status IN ('PENDING', 'ACCEPTED', 'REJECTED', 'EXPIRED'))
);

-- 索引
CREATE INDEX idx_friend_request_requester ON friend_request(requester_id);
CREATE INDEX idx_friend_request_receiver ON friend_request(receiver_id);
CREATE INDEX idx_friend_request_status ON friend_request(receiver_id, status) WHERE status = 'PENDING';
CREATE INDEX idx_friend_request_created ON friend_request(created_at DESC);

-- 唯一索引：同一对用户，同一方向只能有一个待处理的申请（幂等性）
CREATE UNIQUE INDEX uk_friend_request_pending ON friend_request(requester_id, receiver_id) WHERE status = 'PENDING';

-- 注意：不使用外键约束，应用层保证 requester_id 和 receiver_id 的有效性
-- 删除用户时，应用层负责清理好友申请

-- 表注释
COMMENT ON TABLE friend_request IS '好友申请表';
COMMENT ON COLUMN friend_request.status IS '申请状态：PENDING（待处理）、ACCEPTED（已接受）、REJECTED（已拒绝）、EXPIRED（已过期）';
```

### 5.3 聊天会话表（chat_session）

```sql
CREATE TABLE chat_session (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_type VARCHAR(20) NOT NULL, -- PRIVATE（私聊）、ROOM（房间聊天）、GROUP（群聊）
    session_name VARCHAR(100), -- 会话名称（群聊时使用）
    support_key VARCHAR(120), -- 私聊会话唯一键（min(user1,user2)||'|'||max(user1,user2)）
    room_id UUID, -- 房间ID（房间聊天时使用，应用层保证存在）
    created_by UUID, -- 创建人用户ID（群聊时使用，应用层保证存在）
    last_message_id UUID, -- 最后一条消息ID
    last_message_time TIMESTAMPTZ, -- 最后消息时间
    member_count INT DEFAULT 0 NOT NULL, -- 成员数量（必须非空，默认0）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 约束：合法会话类型
    CONSTRAINT chk_session_type_valid CHECK (session_type IN ('PRIVATE', 'ROOM', 'GROUP')),
    -- 约束：成员数合理性
    CONSTRAINT chk_member_count CHECK (member_count >= 0)
);

-- 索引
CREATE INDEX idx_chat_session_type ON chat_session(session_type);
CREATE INDEX idx_chat_session_room ON chat_session(room_id) WHERE room_id IS NOT NULL;
CREATE INDEX idx_chat_session_last_message ON chat_session(last_message_time DESC) WHERE last_message_time IS NOT NULL;

-- 唯一索引：私聊会话去重（相同两个用户只能有一个PRIVATE会话）
CREATE UNIQUE INDEX uk_chat_private_key ON chat_session(support_key) WHERE session_type = 'PRIVATE';

-- 唯一索引：房间会话唯一（一个房间只能有一个ROOM类型会话）
CREATE UNIQUE INDEX uk_chat_session_room_unique ON chat_session(room_id) WHERE session_type = 'ROOM' AND room_id IS NOT NULL;

-- 注意：不使用外键约束，应用层保证 room_id 和 created_by 的有效性

-- 表注释
COMMENT ON TABLE chat_session IS '聊天会话表';
COMMENT ON COLUMN chat_session.session_type IS '会话类型：PRIVATE（私聊）、ROOM（房间聊天）、GROUP（群聊），必须非空';
COMMENT ON COLUMN chat_session.support_key IS '私聊会话唯一键（格式：min(user1,user2)||"|"||max(user1,user2)），用于去重';
COMMENT ON COLUMN chat_session.member_count IS '成员数量（必须非空，默认0，范围：>= 0）';
```

### 5.4 聊天会话成员表（chat_session_member）

```sql
CREATE TABLE chat_session_member (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL, -- 会话ID（应用层保证存在）
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    member_role VARCHAR(20) DEFAULT 'MEMBER', -- MEMBER（成员）、ADMIN（管理员）、OWNER（群主）
    nickname_in_session VARCHAR(50), -- 在会话中的昵称
    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMPTZ, -- 离开时间
    last_read_message_id UUID, -- 最后已读消息ID
    last_read_time TIMESTAMPTZ, -- 最后已读时间
    UNIQUE(session_id, user_id),
    -- 约束：合法角色值
    CONSTRAINT chk_member_role_valid CHECK (member_role IN ('MEMBER', 'ADMIN', 'OWNER'))
);

-- 索引
CREATE INDEX idx_session_member_session ON chat_session_member(session_id);
CREATE INDEX idx_session_member_user ON chat_session_member(user_id);
CREATE INDEX idx_session_member_user_session ON chat_session_member(user_id, session_id);

-- 注意：不使用外键约束，应用层保证 session_id 和 user_id 的有效性
-- 删除会话或用户时，应用层负责清理成员数据

-- 表注释
COMMENT ON TABLE chat_session_member IS '聊天会话成员表';
COMMENT ON COLUMN chat_session_member.member_role IS '成员角色：MEMBER（成员）、ADMIN（管理员）、OWNER（群主），默认MEMBER';
COMMENT ON COLUMN chat_session_member.joined_at IS '加入时间（必须非空）';
```

### 5.5 聊天消息表（chat_message）

```sql
CREATE TABLE chat_message (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL, -- 会话ID（应用层保证存在）
    sender_id UUID NOT NULL, -- 发送者用户ID（应用层保证存在）
    client_op_id VARCHAR(64), -- 客户端操作ID（用于幂等，前端生成UUID）
    message_type VARCHAR(20) DEFAULT 'TEXT', -- TEXT（文本）、IMAGE（图片）、FILE（文件）、SYSTEM（系统消息）
    content TEXT NOT NULL, -- 消息内容
    content_tsv tsvector, -- 全文检索向量（自动生成）
    extra_data JSONB DEFAULT '{}'::jsonb, -- 扩展数据（图片URL、文件信息等）
    reply_to_message_id UUID, -- 回复的消息ID（应用层保证存在）
    is_recalled BOOLEAN DEFAULT FALSE, -- 是否已撤回
    recalled_at TIMESTAMPTZ, -- 撤回时间
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 约束：合法消息类型
    CONSTRAINT chk_message_type_valid CHECK (message_type IN ('TEXT', 'IMAGE', 'FILE', 'SYSTEM'))
);

-- 索引
CREATE INDEX idx_chat_message_session ON chat_message(session_id);
CREATE INDEX idx_chat_message_sender ON chat_message(sender_id);
CREATE INDEX idx_chat_message_session_time ON chat_message(session_id, created_at DESC);
CREATE INDEX idx_chat_message_reply ON chat_message(reply_to_message_id) WHERE reply_to_message_id IS NOT NULL;

-- 全文检索索引（GIN索引，支持快速文本搜索）
CREATE INDEX idx_chat_message_tsv ON chat_message USING GIN (content_tsv);

-- 唯一索引：客户端操作ID幂等（防止重复发消息）
CREATE UNIQUE INDEX uk_chat_message_client_op ON chat_message(client_op_id) WHERE client_op_id IS NOT NULL;

-- 注意：不使用外键约束，应用层保证 session_id、sender_id、reply_to_message_id 的有效性
-- 删除会话或用户时，应用层负责处理消息数据

-- 表注释
COMMENT ON TABLE chat_message IS '聊天消息表';
COMMENT ON COLUMN chat_message.client_op_id IS '客户端操作ID（前端生成UUID，用于幂等，防止重复发送）';
COMMENT ON COLUMN chat_message.message_type IS '消息类型：TEXT（文本）、IMAGE（图片）、FILE（文件）、SYSTEM（系统消息）';
COMMENT ON COLUMN chat_message.content_tsv IS '全文检索向量（自动生成，用于快速文本搜索）';
COMMENT ON COLUMN chat_message.extra_data IS '扩展数据（JSONB，如：{"image_url": "...", "file_name": "..."}）';
```

### 5.6 聊天消息附件表（chat_message_attachment）

```sql
CREATE TABLE chat_message_attachment (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    message_id UUID NOT NULL, -- 消息ID（应用层保证存在）
    file_url VARCHAR(1000) NOT NULL,
    file_name VARCHAR(255),
    file_size BIGINT,
    file_type VARCHAR(100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_msg_attach_msg ON chat_message_attachment(message_id);

-- 注意：不使用外键约束，应用层保证 message_id 的有效性
-- 删除消息时，应用层负责清理附件数据

-- 表注释
COMMENT ON TABLE chat_message_attachment IS '聊天消息附件表（大文件外置，避免混入extra_data）';
COMMENT ON COLUMN chat_message_attachment.file_url IS '文件URL';
COMMENT ON COLUMN chat_message_attachment.file_size IS '文件大小（字节）';
COMMENT ON COLUMN chat_message_attachment.file_type IS '文件类型（MIME类型）';
```

---

## 六、用户成长模块

### 6.1 用户积分表（user_score）

```sql
CREATE TABLE user_score (
    user_id UUID PRIMARY KEY, -- 用户ID（应用层保证存在）
    total_score BIGINT DEFAULT 0, -- 总积分
    current_score BIGINT DEFAULT 0, -- 当前可用积分
    frozen_score BIGINT DEFAULT 0, -- 冻结积分
    level_id UUID, -- 当前等级ID（应用层保证存在）
    level_name VARCHAR(50), -- 当前等级名称（冗余，避免JOIN）
    experience_points BIGINT DEFAULT 0, -- 经验值
    win_count INT DEFAULT 0, -- 胜场数
    lose_count INT DEFAULT 0, -- 负场数
    draw_count INT DEFAULT 0, -- 平局数
    total_matches INT DEFAULT 0, -- 总对局数
    win_rate DECIMAL(5,2) DEFAULT 0.00, -- 胜率（百分比）
    highest_score BIGINT DEFAULT 0, -- 历史最高积分
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_user_score_level ON user_score(level_id);
CREATE INDEX idx_user_score_total ON user_score(total_score DESC);
CREATE INDEX idx_user_score_experience ON user_score(experience_points DESC);

-- 注意：不使用外键约束，应用层保证 user_id 和 level_id 的有效性
-- 删除用户时，应用层负责清理积分数据

-- 表注释
COMMENT ON TABLE user_score IS '用户积分表';
COMMENT ON COLUMN user_score.total_score IS '总积分（累计获得）';
COMMENT ON COLUMN user_score.current_score IS '当前可用积分';
COMMENT ON COLUMN user_score.frozen_score IS '冻结积分（如：押注、活动冻结）';
COMMENT ON COLUMN user_score.experience_points IS '经验值（用于升级）';
COMMENT ON COLUMN user_score.win_rate IS '胜率（百分比，如：65.50 表示 65.50%）';
```

### 6.2 用户等级表（user_level）

```sql
CREATE TABLE user_level (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    level_code VARCHAR(50) NOT NULL UNIQUE, -- 等级编码
    level_name VARCHAR(50) NOT NULL, -- 等级名称
    level_number INT NOT NULL UNIQUE, -- 等级数字（1, 2, 3...）
    min_experience BIGINT NOT NULL, -- 最低经验值
    max_experience BIGINT, -- 最高经验值（NULL表示无上限）
    level_icon VARCHAR(500), -- 等级图标
    level_color VARCHAR(20), -- 等级颜色
    privileges JSONB DEFAULT '{}'::jsonb, -- 等级特权（JSONB）
    sort_order INT DEFAULT 0,
    status SMALLINT DEFAULT 1, -- 0-禁用，1-启用
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,
    -- 约束：合法状态值
    CONSTRAINT chk_user_level_status_valid CHECK (status IN (0, 1)),
    -- 约束：经验值合理性
    CONSTRAINT chk_user_level_experience_valid CHECK (
        max_experience IS NULL OR max_experience >= min_experience
    ),
    -- 约束：等级数字合理性
    CONSTRAINT chk_user_level_number_valid CHECK (level_number > 0)
);

-- 索引
CREATE UNIQUE INDEX uk_user_level_code_not_deleted ON user_level(level_code) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX uk_user_level_number_not_deleted ON user_level(level_number) WHERE deleted_at IS NULL;
CREATE INDEX idx_user_level_status ON user_level(status);
CREATE INDEX idx_user_level_experience ON user_level(min_experience, max_experience) WHERE deleted_at IS NULL;

-- 表注释
COMMENT ON TABLE user_level IS '用户等级表';
COMMENT ON COLUMN user_level.level_code IS '等级编码（如：BRONZE, SILVER, GOLD）';
COMMENT ON COLUMN user_level.level_number IS '等级数字（1, 2, 3...，数字越大等级越高）';
COMMENT ON COLUMN user_level.privileges IS '等级特权（JSONB，如：{"daily_bonus": 100, "match_bonus_rate": 1.2}）';
```

### 6.3 积分变更记录表（score_change_log）

```sql
CREATE TABLE score_change_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    change_type VARCHAR(50) NOT NULL, -- 变更类型（WIN_MATCH, LOSE_MATCH, DAILY_BONUS, PURCHASE等）
    change_amount BIGINT NOT NULL, -- 变更数量（正数表示增加，负数表示减少）
    before_score BIGINT NOT NULL, -- 变更前积分
    after_score BIGINT NOT NULL, -- 变更后积分
    related_match_id UUID, -- 关联对局ID（应用层保证存在）
    related_order_id UUID, -- 关联订单ID（如购买道具）
    description VARCHAR(500), -- 变更描述
    extra_data JSONB DEFAULT '{}'::jsonb, -- 扩展数据
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_score_change_user ON score_change_log(user_id);
CREATE INDEX idx_score_change_type ON score_change_log(change_type);
CREATE INDEX idx_score_change_match ON score_change_log(related_match_id) WHERE related_match_id IS NOT NULL;
CREATE INDEX idx_score_change_time ON score_change_log(user_id, created_at DESC);

-- 注意：不使用外键约束，应用层保证 user_id 和 related_match_id 的有效性
-- 删除用户或对局时，应用层决定是否保留日志（建议保留历史日志）

-- 表注释
COMMENT ON TABLE score_change_log IS '积分变更记录表';
COMMENT ON COLUMN score_change_log.change_type IS '变更类型：WIN_MATCH（对局获胜）、LOSE_MATCH（对局失败）、DAILY_BONUS（每日奖励）等';
COMMENT ON COLUMN score_change_log.change_amount IS '变更数量（正数表示增加，负数表示减少）';
```

### 6.4 经验值变更记录表（experience_change_log）

```sql
CREATE TABLE experience_change_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    change_type VARCHAR(50) NOT NULL, -- 变更类型
    change_amount BIGINT NOT NULL, -- 变更数量
    before_experience BIGINT NOT NULL, -- 变更前经验值
    after_experience BIGINT NOT NULL, -- 变更后经验值
    before_level_id UUID, -- 变更前等级ID（应用层保证存在）
    after_level_id UUID, -- 变更后等级ID（应用层保证存在）
    related_match_id UUID, -- 关联对局ID（应用层保证存在）
    description VARCHAR(500),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_experience_change_user ON experience_change_log(user_id);
CREATE INDEX idx_experience_change_time ON experience_change_log(user_id, created_at DESC);
CREATE INDEX idx_experience_change_match ON experience_change_log(related_match_id) WHERE related_match_id IS NOT NULL;

-- 注意：不使用外键约束，应用层保证所有ID的有效性
-- 删除用户或对局时，应用层决定是否保留日志（建议保留历史日志）

-- 表注释
COMMENT ON TABLE experience_change_log IS '经验值变更记录表';
COMMENT ON COLUMN experience_change_log.change_type IS '变更类型：PLAY_MATCH（对局）、DAILY_LOGIN（每日登录）等';
```

---

## 七、匹配模块

### 7.1 匹配队列表（match_queue）

```sql
CREATE TABLE match_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL, -- 用户ID（应用层保证存在）
    game_type_id UUID NOT NULL, -- 游戏类型ID（应用层保证存在）
    client_op_id VARCHAR(64), -- 客户端操作ID（用于幂等，前端生成UUID）
    queue_status VARCHAR(20) DEFAULT 'WAITING', -- WAITING（等待中）、MATCHED（已匹配）、CANCELLED（已取消）、TIMEOUT（超时）
    match_preferences JSONB DEFAULT '{}'::jsonb, -- 匹配偏好（如：等级范围、积分范围）
    joined_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    matched_at TIMESTAMPTZ, -- 匹配成功时间
    cancelled_at TIMESTAMPTZ, -- 取消时间
    timeout_at TIMESTAMPTZ, -- 超时时间
    matched_match_id UUID, -- 匹配到的对局ID（应用层保证存在）
    -- 约束：合法队列状态值
    CONSTRAINT chk_queue_status_valid CHECK (queue_status IN ('WAITING', 'MATCHED', 'CANCELLED', 'TIMEOUT'))
);

-- 索引
CREATE INDEX idx_match_queue_user ON match_queue(user_id);
CREATE INDEX idx_match_queue_game_type ON match_queue(game_type_id);
CREATE INDEX idx_match_queue_status ON match_queue(queue_status, game_type_id) WHERE queue_status = 'WAITING';
CREATE INDEX idx_match_queue_joined ON match_queue(joined_at) WHERE queue_status = 'WAITING';

-- 唯一索引：同一用户对同一游戏只能有一条 WAITING 状态的记录（防重入）
CREATE UNIQUE INDEX uk_queue_user_game_waiting ON match_queue(user_id, game_type_id) WHERE queue_status = 'WAITING';

-- 唯一索引：客户端操作ID幂等（防止重复请求）
CREATE UNIQUE INDEX uk_match_queue_client_op ON match_queue(client_op_id) WHERE client_op_id IS NOT NULL AND queue_status = 'WAITING';

-- 公平性索引：保障"先入先配"（按游戏类型和加入时间排序）
CREATE INDEX idx_match_queue_fairness ON match_queue(game_type_id, joined_at) WHERE queue_status = 'WAITING';

-- JSONB 表达式索引：匹配偏好中的等级范围（高频查询）
CREATE INDEX idx_mq_pref_min_level ON match_queue((match_preferences->>'min_level')) WHERE queue_status = 'WAITING';
CREATE INDEX idx_mq_pref_max_level ON match_queue((match_preferences->>'max_level')) WHERE queue_status = 'WAITING';

-- 注意：不使用外键约束，应用层保证 user_id、game_type_id、matched_match_id 的有效性
-- 删除用户或游戏类型时，应用层负责清理队列数据

-- 表注释
COMMENT ON TABLE match_queue IS '匹配队列表';
COMMENT ON COLUMN match_queue.client_op_id IS '客户端操作ID（前端生成UUID，用于幂等）';
COMMENT ON COLUMN match_queue.queue_status IS '队列状态：WAITING（等待中）、MATCHED（已匹配）、CANCELLED（已取消）、TIMEOUT（超时），默认WAITING';
COMMENT ON COLUMN match_queue.match_preferences IS '匹配偏好（JSONB，如：{"min_level": 1, "max_level": 10, "score_range": [1000, 2000]}）';
COMMENT ON COLUMN match_queue.joined_at IS '加入队列时间（必须非空）';
```

### 7.2 匹配记录表（match_record）

```sql
CREATE TABLE match_record (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    match_id UUID NOT NULL, -- 对局ID（应用层保证存在）
    match_type VARCHAR(20) NOT NULL, -- RANDOM（随机匹配）、FRIEND（好友匹配）
    player1_id UUID NOT NULL, -- 玩家1用户ID（应用层保证存在）
    player2_id UUID, -- 玩家2用户ID（PVE时为空，应用层保证存在）
    player1_score_before BIGINT, -- 玩家1匹配前积分
    player1_score_after BIGINT, -- 玩家1匹配后积分
    player2_score_before BIGINT, -- 玩家2匹配前积分
    player2_score_after BIGINT, -- 玩家2匹配后积分
    match_quality_score DECIMAL(5,2), -- 匹配质量评分（如：85.50，表示匹配度85.50%）
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    -- 约束：合法匹配类型
    CONSTRAINT chk_match_record_type_valid CHECK (match_type IN ('RANDOM', 'FRIEND'))
);

-- 索引
CREATE INDEX idx_match_record_match ON match_record(match_id);
CREATE INDEX idx_match_record_player1 ON match_record(player1_id);
CREATE INDEX idx_match_record_player2 ON match_record(player2_id) WHERE player2_id IS NOT NULL;
CREATE INDEX idx_match_record_type ON match_record(match_type);

-- 注意：不使用外键约束，应用层保证所有ID的有效性
-- 删除对局或用户时，应用层决定是否保留记录（建议保留历史记录）

-- 表注释
COMMENT ON TABLE match_record IS '匹配记录表';
COMMENT ON COLUMN match_record.match_type IS '匹配类型：RANDOM（随机匹配）、FRIEND（好友匹配），必须非空';
COMMENT ON COLUMN match_record.match_quality_score IS '匹配质量评分（0-100，表示匹配度，如：85.50 表示 85.50%）';
```

---

## 八、触发器

### 8.1 自动更新 updated_at 触发器

```sql
-- 创建触发器函数（如果还没有）
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 为需要自动更新 updated_at 的表创建触发器
CREATE TRIGGER trg_game_type_updated_at
    BEFORE UPDATE ON game_type
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_game_room_updated_at
    BEFORE UPDATE ON game_room
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_user_friend_updated_at
    BEFORE UPDATE ON user_friend
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_chat_session_updated_at
    BEFORE UPDATE ON chat_session
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_user_score_updated_at
    BEFORE UPDATE ON user_score
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trg_user_level_updated_at
    BEFORE UPDATE ON user_level
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### 8.2 自动更新用户积分统计触发器

```sql
-- 对局结束后自动更新用户积分统计
CREATE OR REPLACE FUNCTION update_user_score_after_match()
RETURNS TRIGGER AS $$
DECLARE
    v_player1_score_change BIGINT;
    v_player2_score_change BIGINT;
BEGIN
    -- 只有对局结束时才更新
    IF NEW.match_status = 'FINISHED' AND (OLD.match_status IS NULL OR OLD.match_status != 'FINISHED') THEN
        -- 根据对局结果计算积分变化（这里简化处理，实际应该根据ELO算法等）
        IF NEW.result = 'WIN' THEN
            IF NEW.winner_id = NEW.player1_id THEN
                v_player1_score_change := 20; -- 获胜+20分
                v_player2_score_change := -10; -- 失败-10分
            ELSE
                v_player1_score_change := -10;
                v_player2_score_change := 20;
            END IF;
        ELSIF NEW.result = 'DRAW' THEN
            v_player1_score_change := 5; -- 平局+5分
            v_player2_score_change := 5;
        ELSE
            -- ABANDON 不改变积分
            v_player1_score_change := 0;
            v_player2_score_change := 0;
        END IF;
        
        -- 更新玩家1积分
        UPDATE user_score
        SET total_score = total_score + v_player1_score_change,
            current_score = current_score + v_player1_score_change,
            win_count = CASE WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player1_id THEN win_count + 1 ELSE win_count END,
            lose_count = CASE WHEN NEW.result = 'WIN' AND NEW.winner_id != NEW.player1_id THEN lose_count + 1 ELSE lose_count END,
            draw_count = CASE WHEN NEW.result = 'DRAW' THEN draw_count + 1 ELSE draw_count END,
            total_matches = total_matches + 1,
            win_rate = CASE 
                WHEN total_matches + 1 > 0 THEN 
                    ROUND((win_count + CASE WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player1_id THEN 1 ELSE 0 END)::NUMERIC / (total_matches + 1) * 100, 2)
                ELSE 0
            END,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.player1_id;
        
        -- 更新玩家2积分（如果存在）
        IF NEW.player2_id IS NOT NULL THEN
            UPDATE user_score
            SET total_score = total_score + v_player2_score_change,
                current_score = current_score + v_player2_score_change,
                win_count = CASE WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player2_id THEN win_count + 1 ELSE win_count END,
                lose_count = CASE WHEN NEW.result = 'WIN' AND NEW.winner_id != NEW.player2_id THEN lose_count + 1 ELSE lose_count END,
                draw_count = CASE WHEN NEW.result = 'DRAW' THEN draw_count + 1 ELSE draw_count END,
                total_matches = total_matches + 1,
                win_rate = CASE 
                    WHEN total_matches + 1 > 0 THEN 
                        ROUND((win_count + CASE WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player2_id THEN 1 ELSE 0 END)::NUMERIC / (total_matches + 1) * 100, 2)
                    ELSE 0
                END,
                updated_at = CURRENT_TIMESTAMP
            WHERE user_id = NEW.player2_id;
        END IF;
        
        -- 记录积分变更日志
        INSERT INTO score_change_log (user_id, change_type, change_amount, before_score, after_score, related_match_id, description)
        SELECT 
            NEW.player1_id,
            CASE 
                WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player1_id THEN 'WIN_MATCH'
                WHEN NEW.result = 'WIN' AND NEW.winner_id != NEW.player1_id THEN 'LOSE_MATCH'
                WHEN NEW.result = 'DRAW' THEN 'DRAW_MATCH'
                ELSE 'ABANDON_MATCH'
            END,
            v_player1_score_change,
            (SELECT current_score FROM user_score WHERE user_id = NEW.player1_id) - v_player1_score_change,
            (SELECT current_score FROM user_score WHERE user_id = NEW.player1_id),
            NEW.id,
            '对局积分变更'
        WHERE v_player1_score_change != 0;
        
        IF NEW.player2_id IS NOT NULL AND v_player2_score_change != 0 THEN
            INSERT INTO score_change_log (user_id, change_type, change_amount, before_score, after_score, related_match_id, description)
            SELECT 
                NEW.player2_id,
                CASE 
                    WHEN NEW.result = 'WIN' AND NEW.winner_id = NEW.player2_id THEN 'WIN_MATCH'
                    WHEN NEW.result = 'WIN' AND NEW.winner_id != NEW.player2_id THEN 'LOSE_MATCH'
                    WHEN NEW.result = 'DRAW' THEN 'DRAW_MATCH'
                    ELSE 'ABANDON_MATCH'
                END,
                v_player2_score_change,
                (SELECT current_score FROM user_score WHERE user_id = NEW.player2_id) - v_player2_score_change,
                (SELECT current_score FROM user_score WHERE user_id = NEW.player2_id),
                NEW.id,
                '对局积分变更';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_game_match_update_score
    AFTER UPDATE ON game_match
    FOR EACH ROW
    EXECUTE FUNCTION update_user_score_after_match();
```

### 8.3 聊天消息全文检索触发器

```sql
-- 创建全文检索触发器函数
CREATE OR REPLACE FUNCTION chat_message_tsv_trg()
RETURNS TRIGGER AS $$
BEGIN
    NEW.content_tsv = to_tsvector('simple', coalesce(NEW.content, ''));
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器：自动更新全文检索向量
CREATE TRIGGER trg_chat_message_tsv
    BEFORE INSERT OR UPDATE ON chat_message
    FOR EACH ROW
    EXECUTE FUNCTION chat_message_tsv_trg();
```

### 8.4 房间玩家数自动同步触发器

```sql
-- 自动同步 game_room.current_players 与 game_room_player 表
CREATE OR REPLACE FUNCTION sync_room_player_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- 插入玩家时，增加计数
        UPDATE game_room
        SET current_players = current_players + 1
        WHERE id = NEW.room_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        -- 删除玩家时，减少计数
        UPDATE game_room
        SET current_players = GREATEST(0, current_players - 1)
        WHERE id = OLD.room_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER trg_sync_room_player_count_ins
    AFTER INSERT ON game_room_player
    FOR EACH ROW
    EXECUTE FUNCTION sync_room_player_count();

CREATE TRIGGER trg_sync_room_player_count_del
    AFTER DELETE ON game_room_player
    FOR EACH ROW
    EXECUTE FUNCTION sync_room_player_count();
```

### 8.5 终态封口触发器（可选，作为双重保障）

```sql
-- 终态房间/对局禁止修改关键字段（可选，应用层已做校验）
CREATE OR REPLACE FUNCTION prevent_final_state_modification()
RETURNS TRIGGER AS $$
BEGIN
    -- 允许更新的字段：updated_at, remark, finished_at（终态时设置）
    IF OLD.room_status IN ('FINISHED', 'CLOSED') AND 
       (NEW.room_status != OLD.room_status OR 
        NEW.current_players != OLD.current_players OR
        NEW.room_mode != OLD.room_mode OR
        NEW.max_players != OLD.max_players) THEN
        RAISE EXCEPTION '房间已结束，不允许修改状态或关键字段';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 对局终态保护（可选）
CREATE OR REPLACE FUNCTION prevent_match_final_state_modification()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.match_status IN ('FINISHED', 'ABANDONED') AND 
       (NEW.match_status != OLD.match_status OR
        NEW.player1_id != OLD.player1_id OR
        NEW.player2_id != OLD.player2_id OR
        NEW.winner_id != OLD.winner_id OR
        NEW.result != OLD.result) THEN
        RAISE EXCEPTION '对局已结束，不允许修改关键字段';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器（可选，建议仅作为双重保障）
-- CREATE TRIGGER trg_prevent_room_final_modify
--     BEFORE UPDATE ON game_room
--     FOR EACH ROW
--     WHEN (OLD.room_status IN ('FINISHED', 'CLOSED'))
--     EXECUTE FUNCTION prevent_final_state_modification();

-- CREATE TRIGGER trg_prevent_match_final_modify
--     BEFORE UPDATE ON game_match
--     FOR EACH ROW
--     WHEN (OLD.match_status IN ('FINISHED', 'ABANDONED'))
--     EXECUTE FUNCTION prevent_match_final_state_modification();
```

---

## 九、初始化数据

### 9.1 游戏类型初始化

```sql
-- 插入默认游戏类型
INSERT INTO game_type (game_code, game_name, game_desc, min_players, max_players, config) VALUES
('gomoku', '五子棋', '五子棋游戏', 2, 2, '{"board_size": 15, "rules": ["STANDARD", "RENJU"]}'),
('chess', '象棋', '中国象棋', 2, 2, '{"board_size": 9, "rules": ["STANDARD"]}'),
('go', '围棋', '围棋游戏', 2, 2, '{"board_size": 19, "rules": ["STANDARD"]}')
ON CONFLICT (game_code) DO NOTHING;
```

### 9.2 用户等级初始化

```sql
-- 插入默认等级
INSERT INTO user_level (level_code, level_name, level_number, min_experience, max_experience, privileges) VALUES
('BRONZE_1', '青铜I', 1, 0, 100, '{"daily_bonus": 10}'),
('BRONZE_2', '青铜II', 2, 100, 300, '{"daily_bonus": 15}'),
('BRONZE_3', '青铜III', 3, 300, 600, '{"daily_bonus": 20}'),
('SILVER_1', '白银I', 4, 600, 1200, '{"daily_bonus": 30, "match_bonus_rate": 1.1}'),
('SILVER_2', '白银II', 5, 1200, 2000, '{"daily_bonus": 40, "match_bonus_rate": 1.15}'),
('GOLD_1', '黄金I', 6, 2000, 3500, '{"daily_bonus": 50, "match_bonus_rate": 1.2}'),
('GOLD_2', '黄金II', 7, 3500, 5500, '{"daily_bonus": 60, "match_bonus_rate": 1.25}'),
('PLATINUM', '铂金', 8, 5500, NULL, '{"daily_bonus": 80, "match_bonus_rate": 1.3}')
ON CONFLICT (level_code) DO NOTHING;
```

### 9.3 RBAC 权限系统初始化

```sql
-- 插入默认角色
INSERT INTO sys_role (role_code, role_name, role_desc, data_scope, sort_order) VALUES
('SUPER_ADMIN', '超级管理员', '系统超级管理员，拥有所有权限', 'ALL', 1),
('ADMIN', '管理员', '系统管理员，拥有管理权限', 'ALL', 2),
('USER', '普通用户', '普通用户，基础权限', 'SELF', 3)
ON CONFLICT (role_code) DO NOTHING;

-- 插入默认权限（示例，根据实际业务需求调整）
INSERT INTO sys_permission (permission_code, permission_name, permission_type, resource_path, http_method, sort_order) VALUES
('system:user:list', '用户列表', 'API', '/api/system/user', 'GET', 1),
('system:user:add', '新增用户', 'API', '/api/system/user', 'POST', 2),
('system:user:edit', '编辑用户', 'API', '/api/system/user', 'PUT', 3),
('system:user:delete', '删除用户', 'API', '/api/system/user', 'DELETE', 4),
('system:role:list', '角色列表', 'API', '/api/system/role', 'GET', 10),
('system:role:add', '新增角色', 'API', '/api/system/role', 'POST', 11),
('game:room:create', '创建房间', 'API', '/api/game/room', 'POST', 100),
('game:room:join', '加入房间', 'API', '/api/game/room/join', 'POST', 101),
('game:match:list', '对局列表', 'API', '/api/game/match', 'GET', 110)
ON CONFLICT (permission_code) DO NOTHING;

-- 插入默认菜单（示例，根据实际前端路由调整）
INSERT INTO sys_menu (menu_name, menu_type, parent_id, path, component, icon, permission_code, sort_order) VALUES
('系统管理', 'DIRECTORY', NULL, '/system', 'Layout', 'system', NULL, 1),
('用户管理', 'MENU', (SELECT id FROM sys_menu WHERE menu_name = '系统管理' LIMIT 1), '/system/user', 'system/user/index', 'user', 'system:user:list', 1),
('角色管理', 'MENU', (SELECT id FROM sys_menu WHERE menu_name = '系统管理' LIMIT 1), '/system/role', 'system/role/index', 'peoples', 'system:role:list', 2),
('游戏大厅', 'MENU', NULL, '/game', 'game/index', 'game', 'game:room:list', 10),
('我的对局', 'MENU', NULL, '/game/match', 'game/match/index', 'list', 'game:match:list', 11)
ON CONFLICT (path) WHERE deleted_at IS NULL DO NOTHING;

-- 为超级管理员角色分配所有权限（示例）
INSERT INTO sys_role_permission (role_id, permission_id)
SELECT 
    (SELECT id FROM sys_role WHERE role_code = 'SUPER_ADMIN' LIMIT 1),
    id
FROM sys_permission
WHERE deleted_at IS NULL
ON CONFLICT (role_id, permission_id) DO NOTHING;

-- 为超级管理员角色分配所有菜单（示例）
INSERT INTO sys_role_menu (role_id, menu_id)
SELECT 
    (SELECT id FROM sys_role WHERE role_code = 'SUPER_ADMIN' LIMIT 1),
    id
FROM sys_menu
WHERE deleted_at IS NULL
ON CONFLICT (role_id, menu_id) DO NOTHING;
```

### 9.4 全文索引历史数据回填

```sql
-- 回填 chat_message 历史数据的全文检索向量
UPDATE chat_message
SET content_tsv = to_tsvector('simple', coalesce(content, ''))
WHERE content_tsv IS NULL;

-- 优化表统计信息
VACUUM ANALYZE chat_message;
```

---

## 十、常用查询示例

### 10.1 查询用户战绩

```sql
-- 查询用户总战绩（通过用户ID）
SELECT 
    us.win_count,
    us.lose_count,
    us.draw_count,
    us.total_matches,
    us.win_rate,
    us.total_score,
    ul.level_name
FROM user_score us
LEFT JOIN user_level ul ON us.level_id = ul.id
WHERE us.user_id = $1;

-- 通过玩家ID查找用户信息（用于添加好友、搜索等场景）
SELECT 
    id,
    username,
    nickname,
    avatar_url,
    player_id,
    status
FROM sys_user
WHERE player_id = $1
  AND deleted_at IS NULL
  AND status = 1;
```

### 10.2 查询用户最近对局

```sql
-- 查询用户最近10局对局
SELECT 
    gm.id,
    gt.game_name,
    gm.match_type,
    gm.result,
    CASE 
        WHEN gm.winner_id = $1 THEN 'WIN'
        WHEN gm.result = 'DRAW' THEN 'DRAW'
        ELSE 'LOSE'
    END AS user_result,
    gm.started_at,
    gm.finished_at
FROM game_match gm
JOIN game_type gt ON gm.game_type_id = gt.id
WHERE (gm.player1_id = $1 OR gm.player2_id = $1)
  AND gm.match_status = 'FINISHED'
ORDER BY gm.finished_at DESC
LIMIT 10;
```

### 10.3 查询好友列表

```sql
-- 查询用户好友列表
SELECT 
    uf.friend_id,
    u.username,
    u.nickname,
    u.avatar_url,
    uf.friend_nickname,
    uf.friend_group,
    uf.last_interaction_time,
    us.total_score,
    ul.level_name
FROM user_friend uf
JOIN sys_user u ON uf.friend_id = u.id
LEFT JOIN user_score us ON uf.friend_id = us.user_id
LEFT JOIN user_level ul ON us.level_id = ul.id
WHERE uf.user_id = $1
  AND uf.status = 'ACTIVE'
ORDER BY uf.last_interaction_time DESC NULLS LAST;
```

### 10.4 查询房间列表

```sql
-- 查询可加入的房间列表
SELECT 
    gr.id,
    gr.room_code,
    gr.room_name,
    gt.game_name,
    gr.room_mode,
    gr.current_players,
    gr.max_players,
    u.username AS owner_name,
    gr.created_at
FROM game_room gr
JOIN game_type gt ON gr.game_type_id = gt.id
JOIN sys_user u ON gr.owner_id = u.id
WHERE gr.room_status = 'WAITING'
  AND gr.is_private = FALSE
  AND gr.deleted_at IS NULL
ORDER BY gr.created_at DESC
LIMIT 20;
```

### 10.5 RBAC 权限查询示例

```sql
-- 查询用户的所有权限（通过角色）
SELECT DISTINCT 
    p.permission_code,
    p.permission_name,
    p.permission_type,
    p.resource_path,
    p.http_method
FROM sys_user_role ur
JOIN sys_role_permission rp ON ur.role_id = rp.role_id
JOIN sys_permission p ON rp.permission_id = p.id
WHERE ur.user_id = $1
  AND p.deleted_at IS NULL
  AND p.status = 1;

-- 查询用户的菜单树（通过角色）
WITH RECURSIVE menu_tree AS (
    -- 根菜单
    SELECT 
        m.id,
        m.menu_name,
        m.menu_type,
        m.parent_id,
        m.path,
        m.component,
        m.icon,
        m.permission_code,
        m.sort_order,
        1 AS level
    FROM sys_menu m
    WHERE m.parent_id IS NULL
      AND m.deleted_at IS NULL
      AND m.status = 1
      AND EXISTS (
          SELECT 1 
          FROM sys_user_role ur
          JOIN sys_role_menu rm ON ur.role_id = rm.role_id
          WHERE ur.user_id = $1
            AND rm.menu_id = m.id
      )
    
    UNION ALL
    
    -- 子菜单
    SELECT 
        m.id,
        m.menu_name,
        m.menu_type,
        m.parent_id,
        m.path,
        m.component,
        m.icon,
        m.permission_code,
        m.sort_order,
        mt.level + 1
    FROM sys_menu m
    JOIN menu_tree mt ON m.parent_id = mt.id
    WHERE m.deleted_at IS NULL
      AND m.status = 1
      AND EXISTS (
          SELECT 1 
          FROM sys_user_role ur
          JOIN sys_role_menu rm ON ur.role_id = rm.role_id
          WHERE ur.user_id = $1
            AND rm.menu_id = m.id
      )
)
SELECT * FROM menu_tree
ORDER BY level, sort_order;

-- 检查用户是否有指定权限
SELECT EXISTS (
    SELECT 1
    FROM sys_user_role ur
    JOIN sys_role_permission rp ON ur.role_id = rp.role_id
    JOIN sys_permission p ON rp.permission_id = p.id
    WHERE ur.user_id = $1
      AND p.permission_code = $2
      AND p.deleted_at IS NULL
      AND p.status = 1
) AS has_permission;
```

### 10.6 RBAC 菜单→权限健康巡检

```sql
-- 检查菜单绑定的权限是否真实存在（用于定时任务）
SELECT 
    m.id AS menu_id,
    m.menu_name,
    m.permission_code
FROM sys_menu m
WHERE m.permission_code IS NOT NULL
  AND m.deleted_at IS NULL
  AND m.permission_code NOT IN (
      SELECT permission_code 
      FROM sys_permission 
      WHERE deleted_at IS NULL
  );

-- 检查孤立数据（对局中不存在的用户ID）
SELECT DISTINCT player1_id AS orphan_user_id, 'player1' AS role
FROM game_match 
WHERE player1_id NOT IN (SELECT id FROM sys_user WHERE deleted_at IS NULL)
UNION
SELECT DISTINCT player2_id, 'player2'
FROM game_match 
WHERE player2_id IS NOT NULL 
  AND player2_id NOT IN (SELECT id FROM sys_user WHERE deleted_at IS NULL);

-- 检查角色→权限/菜单孤儿记录（关联表中引用的ID是否在主表中存在）
-- 检查角色权限关联表中的权限ID是否在权限表中存在
SELECT 
    rp.role_id,
    rp.permission_id AS orphan_id,
    'permission' AS type
FROM sys_role_permission rp
WHERE rp.permission_id NOT IN (
    SELECT id FROM sys_permission WHERE deleted_at IS NULL
)
UNION ALL
-- 检查角色菜单关联表中的菜单ID是否在菜单表中存在
SELECT 
    rm.role_id,
    rm.menu_id AS orphan_id,
    'menu' AS type
FROM sys_role_menu rm
WHERE rm.menu_id NOT IN (
    SELECT id FROM sys_menu WHERE deleted_at IS NULL
)
UNION ALL
-- 检查用户角色关联表中的角色ID是否在角色表中存在
SELECT 
    ur.user_id,
    ur.role_id AS orphan_id,
    'role' AS type
FROM sys_user_role ur
WHERE ur.role_id NOT IN (
    SELECT id FROM sys_role WHERE deleted_at IS NULL
);
```

---

## 十一、扩展路线（可选）

### 11.1 多租户支持（SaaS 模式）

如果未来考虑 SaaS 多租户模式，建议在核心表中预留 `tenant_id` 字段，并调整唯一索引为包含 `tenant_id` 的复合唯一索引。

**需要修改的表**：
- `sys_user`、`sys_role`、`sys_permission`、`sys_menu`、`sys_dept`
- `game_room`、`game_match`、`user_friend`、`chat_session` 等核心业务表

**示例修改**：
```sql
-- 示例：sys_user 表添加 tenant_id
ALTER TABLE sys_user ADD COLUMN tenant_id UUID;

-- 示例：唯一索引改为包含 tenant_id 的复合唯一索引
DROP INDEX uk_sys_user_username_not_deleted;
CREATE UNIQUE INDEX uk_sys_user_tenant_username ON sys_user(tenant_id, username) 
    WHERE deleted_at IS NULL;

-- 示例：sys_role 表添加 tenant_id
ALTER TABLE sys_role ADD COLUMN tenant_id UUID;
CREATE UNIQUE INDEX uk_sys_role_tenant_code ON sys_role(tenant_id, role_code) 
    WHERE deleted_at IS NULL;
```

**注意事项**：
- 所有查询都需要带上 `tenant_id` 过滤条件
- 应用层需要实现租户隔离逻辑
- 建议使用 Row Level Security (RLS) 策略自动过滤租户数据

> **说明**：当前单租户系统可以不实施，此方案作为未来扩展路线参考。

---

## 十二、总结

### 12.1 表结构统计

- **RBAC权限系统**：11张表（用户、角色、权限、菜单、部门、日志等）
- **游戏模块**：6张表（游戏类型、房间、玩家、对局、详情、快照）
- **社交模块**：6张表（好友、好友申请、会话、成员、消息、消息附件）
- **用户成长模块**：4张表（积分、等级、积分变更、经验变更）
- **匹配模块**：2张表（匹配队列、匹配记录）

**总计：29张表**

### 12.2 设计特点

✅ **模块化设计**：各模块独立，便于扩展  
✅ **完整索引**：所有常用查询字段都有索引，包括唯一索引和部分索引  
✅ **玩家ID唯一性**：`player_id` 使用序列自增 + 唯一索引，提供 6-9 位数字ID，便于查找和分享  
✅ **无外键约束**：微服务架构下，不使用外键约束，通过应用层保证数据一致性（便于维护、性能更好）  
✅ **状态机终态封口**：数据库 CHECK 约束 + 应用层双重校验，防止终态被修改  
✅ **幂等键规范**：高频接口统一使用 `client_op_id` 保证幂等性（匹配、建房、发消息）  
✅ **私聊会话去重**：通过 `support_key` 唯一索引防止重复创建  
✅ **房间会话唯一**：一个房间只能有一个 ROOM 类型会话  
✅ **密码安全**：房间密码使用哈希存储（bcrypt/argon2），不可明文  
✅ **玩家数同步**：通过触发器自动同步 `current_players`，防止数据漂移  
✅ **CHECK约束**：保证数据一致性（结果与胜者一致性、状态值合法性、座位唯一性、玩家数合理性、成员数合理性等）  
✅ **触发器**：自动更新统计数据和积分、全文检索向量  
✅ **JSONB字段**：灵活存储配置和扩展数据  
✅ **软删除支持**：关键表支持软删除  
✅ **全文检索**：聊天消息支持全文搜索（tsvector + GIN索引）  
✅ **完整注释**：所有表和字段都有注释说明  

### 12.3 扩展性

- **游戏类型扩展**：通过 `game_type` 表轻松添加新游戏
- **等级系统扩展**：通过 `user_level` 表配置等级和特权
- **积分规则扩展**：通过触发器或应用层逻辑灵活调整
- **匹配算法扩展**：通过 `match_preferences` JSONB字段支持复杂匹配规则

> 🎯 本设计适用于多人在线棋牌室平台，支持游戏、社交、成长、匹配等完整功能，可直接用于生产环境部署。

---

## 十三、应用层实现说明

### 13.1 状态机终态封口

**数据库层**：已添加 CHECK 约束，但仅能保证 `finished_at` 不为空，无法阻止更新操作。

**应用层实现**：
- **Service 层**：所有写操作（就座、换座、落子、准备）前检查状态，终态（FINISHED/CLOSED/ABANDONED）直接拒绝
- **Repository 层**：使用 `@Query` 或 `@Modifying` 时，WHERE 条件必须包含 `room_status NOT IN ('FINISHED', 'CLOSED')`
- **网关层**：统一拦截终态写请求（可选，作为双重保障）

**示例逻辑**：
```java
// Service 层
if (room.getRoomStatus() == RoomStatus.FINISHED || room.getRoomStatus() == RoomStatus.CLOSED) {
    throw new BusinessException("房间已结束，无法操作");
}
```

### 13.2 私聊会话去重

**数据库层**：已添加 `support_key` 唯一索引。

**应用层实现**：
- **创建私聊前**：计算 `support_key = min(user1, user2) + "|" + max(user1, user2)`
- **查询或创建**：先按 `support_key` 查询，存在则返回，不存在则创建
- **异常处理**：捕获唯一索引冲突异常，转为查询已存在会话

**示例逻辑**：
```java
String supportKey = generateSupportKey(user1Id, user2Id);
ChatSession session = chatSessionRepository.findBySupportKeyAndSessionType(supportKey, "PRIVATE")
    .orElseGet(() -> createNewPrivateSession(user1Id, user2Id, supportKey));
```

### 13.3 幂等键处理

**数据库层**：已为 `match_queue`、`game_room`、`chat_message` 添加 `client_op_id` 唯一索引。

**应用层实现**：
- **前端**：所有可重放接口（匹配、建房、发消息）附带 `clientOpId`（前端生成 UUID）
- **后端**：接收请求后，先检查 `clientOpId` 是否已存在
  - 存在且状态匹配：返回已有结果（幂等）
  - 不存在：执行业务逻辑，保存 `clientOpId`
- **Redis 缓存**：可选，使用 Redis 设置 `clientOpId` 短期缓存（5分钟），减少数据库查询

**示例逻辑**：
```java
// 匹配接口
if (request.getClientOpId() != null) {
    MatchQueue existing = matchQueueRepository.findByClientOpId(request.getClientOpId());
    if (existing != null && existing.getQueueStatus() == QueueStatus.WAITING) {
        return existing; // 幂等返回
    }
}

// 建房接口
if (request.getClientOpId() != null) {
    GameRoom existing = gameRoomRepository.findByClientOpIdAndDeletedAtIsNull(request.getClientOpId());
    if (existing != null) {
        return existing; // 幂等返回
    }
}

// 发消息接口
if (request.getClientOpId() != null) {
    ChatMessage existing = chatMessageRepository.findByClientOpId(request.getClientOpId());
    if (existing != null) {
        return existing; // 幂等返回
    }
}
```

### 13.4 房间密码哈希处理

**数据库层**：已改为 `password_hash VARCHAR(200)`，使用安全哈希算法。

**应用层实现**：
- **创建房间时**：使用 bcrypt 或 argon2 对密码进行哈希，存储 `password_hash`
- **验证密码时**：使用哈希算法验证，不可明文对比
- **示例**：`BCrypt.checkpw(inputPassword, room.getPasswordHash())`

### 13.5 数据一致性验证

**插入前验证**：
- 所有关联 ID（`user_id`、`game_type_id`、`room_id` 等）在插入前必须验证存在性
- 调用对应服务或查询对应表验证
- 验证失败直接抛异常，不写入数据库

**删除时清理**：
- 删除用户：清理房间玩家、好友关系、匹配队列；对局记录保留但 `winner_id` 置 NULL
- 删除房间：清理房间玩家、对局记录（软删除）
- 删除对局：清理对局详情、快照（硬删除或软删除）

**定期巡检**：
- 定时任务（每日/每周）执行孤儿数据检查 SQL（见 10.5 节）
- 发现孤儿数据记录日志并告警
- 根据业务规则决定是否自动清理
- **RBAC 健康巡检**：检查菜单绑定的权限是否存在，发现异常及时修复

### 13.6 分区表管理（可选）

**适用表**：`chat_message`、`game_match_detail`、`score_change_log`（高写表）

**实现方式**：
- **自动创建分区**：每月初自动创建下月分区（定时任务）
- **自动归档**：3个月前的分区数据归档到冷存储
- **查询优化**：查询时自动路由到对应分区（PostgreSQL 自动处理）

**代码层面**：无需特殊处理，PostgreSQL 自动路由，但需要维护分区创建脚本。

---

## 十四、应用层数据一致性保证

### 14.1 为什么不用外键约束？

在微服务架构下，不使用外键约束的原因：

1. **服务边界隔离**：不同服务可能使用不同数据库，无法跨库建立外键
2. **性能影响**：外键检查会带来性能开销，特别是在高并发场景
3. **维护复杂**：删除操作需要级联处理，可能影响多个服务
4. **分布式事务**：跨服务的数据一致性需要分布式事务，复杂度高
5. **灵活性**：应用层可以更灵活地处理数据清理和一致性逻辑

### 14.2 应用层如何保证数据一致性？

#### 14.2.1 插入数据时验证

```java
// 示例：创建房间时验证 game_type_id 和 owner_id
@Service
public class GameRoomService {
    
    @Autowired
    private GameTypeRepository gameTypeRepository;
    
    @Autowired
    private UserServiceClient userServiceClient; // 调用用户服务验证
    
    public GameRoom createRoom(CreateRoomRequest request) {
        // 1. 验证游戏类型是否存在
        GameType gameType = gameTypeRepository.findById(request.getGameTypeId())
            .orElseThrow(() -> new BusinessException("游戏类型不存在"));
        
        // 2. 验证用户是否存在（调用用户服务）
        UserInfo userInfo = userServiceClient.getUserInfo(request.getOwnerId());
        if (userInfo == null) {
            throw new BusinessException("用户不存在");
        }
        
        // 3. 创建房间
        return gameRoomRepository.save(new GameRoom(...));
    }
}
```

#### 14.2.2 删除数据时清理关联

```java
// 示例：删除用户时清理关联数据
@Service
public class UserDeletionService {
    
    @Transactional
    public void deleteUser(UUID userId) {
        // 1. 清理房间玩家关系
        gameRoomPlayerRepository.deleteByUserId(userId);
        
        // 2. 处理对局记录（保留历史，但 winner_id 置为 NULL）
        gameMatchRepository.updateWinnerIdToNull(userId);
        
        // 3. 清理好友关系
        userFriendRepository.deleteByUserIdOrFriendId(userId, userId);
        
        // 4. 清理匹配队列
        matchQueueRepository.deleteByUserId(userId);
        
        // 5. 最后删除用户（软删除）
        sysUserRepository.softDelete(userId);
    }
}
```

#### 14.2.3 使用唯一索引保证唯一性

虽然不用外键，但**唯一索引**仍然保留，保证：
- 同一房间同一用户只能有一条记录：`UNIQUE(room_id, user_id)`
- 同一对局步数唯一：`UNIQUE(match_id, move_number)`
- 同一用户同一游戏只能有一条 WAITING：`UNIQUE(user_id, game_type_id) WHERE queue_status = 'WAITING'`

#### 14.2.4 定期数据一致性检查

```sql
-- 定期检查孤立数据（可选，用于监控）
-- 检查对局中不存在的用户ID
SELECT DISTINCT player1_id 
FROM game_match 
WHERE player1_id NOT IN (SELECT id FROM sys_user WHERE deleted_at IS NULL)
UNION
SELECT DISTINCT player2_id 
FROM game_match 
WHERE player2_id IS NOT NULL 
  AND player2_id NOT IN (SELECT id FROM sys_user WHERE deleted_at IS NULL);
```

### 14.3 最佳实践

1. **服务层验证**：在 Service 层统一验证关联数据是否存在
2. **事务管理**：使用 `@Transactional` 保证操作的原子性
3. **软删除优先**：优先使用软删除，保留历史数据
4. **异步清理**：对于非关键数据，可以使用异步任务清理
5. **监控告警**：定期检查数据一致性，发现异常及时告警

### 14.4 注意事项

⚠️ **应用层必须保证**：
- 插入数据前验证关联ID是否存在
- 删除数据时清理或处理关联数据
- 使用唯一索引防止重复数据
- 定期检查数据一致性

✅ **优势**：
- 性能更好（无外键检查开销）
- 维护更灵活（可按业务逻辑处理）
- 适合微服务架构（服务边界清晰）

