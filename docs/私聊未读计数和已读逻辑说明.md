# 私聊未读计数和已读逻辑说明

## 1. 未读计数计算逻辑

### 1.1 数据库字段

在 `chat_session_member` 表中，有两个关键字段用于跟踪已读状态：

- `last_read_message_id` (UUID): 最后已读的消息ID
- `last_read_time` (OffsetDateTime): 最后已读时间

### 1.2 后端计算逻辑

**位置**: `ChatSessionServiceImpl.countUnreadMessages()`

**计算流程**:

1. **查询成员记录**
   ```java
   ChatSessionMember member = memberRepository.findBySessionIdAndUserId(sessionId, userId)
   ```

2. **如果成员不存在**
   - 返回该会话中所有未撤回的消息数（认为全部未读）

3. **如果成员存在，但 `last_read_time` 为 null**
   - 说明用户从未打开过会话
   - 返回该会话中所有未撤回的消息数

4. **如果 `last_read_time` 不为 null，但 `last_read_message_id` 为 null**
   - 说明用户已经打开过会话，但会话还没有消息
   - 返回 0（已读）

5. **正常情况（两个字段都不为 null）**
   - 查询 `last_read_message_id` 对应的消息的 `created_at` 时间
   - 如果查询不到（消息可能被删除），使用 `last_read_time` 作为兜底
   - 统计 `created_at > lastReadTime` 且 `is_recalled = false` 的消息数量

**SQL 查询**:
```sql
SELECT COUNT(m) FROM chat_message m 
WHERE m.session_id = :sessionId 
AND m.is_recalled = false 
AND (m.created_at > :lastReadTime OR :lastReadTime IS NULL)
```

### 1.3 前端获取未读数

**位置**: `GlobalChat.jsx` - 加载会话列表时

**流程**:
1. 前端调用 `GET /chat-service/api/sessions`
2. 后端返回会话列表，每个会话包含 `unreadCount` 字段
3. 前端将未读数显示在会话列表中

**代码**:
```javascript
// 后端返回的会话对象
{
  sessionId: "...",
  sessionType: "PRIVATE",
  otherUserId: "...",
  unreadCount: 5,  // 未读消息数
  lastMessage: "...",
  lastMessageTime: "..."
}
```

## 2. 已读触发逻辑

### 2.1 触发时机

已读标记在以下两种情况下触发：

#### 情况1: 从"最近聊天"列表打开会话
**位置**: `GlobalChat.jsx.handleOpenThread()`

**流程**:
1. 用户点击"最近聊天"列表中的某个会话
2. 调用 `handleOpenThread(threadId)`
3. 前端立即将未读数设为 0（乐观更新）
4. 加载历史消息（如果还没有加载）
5. 调用 `markSessionAsRead(threadId, friendId)` 标记已读

#### 情况2: 从"好友列表"点击好友
**位置**: `GlobalChat.jsx.handleFriendClick()`

**流程**:
1. 用户点击好友列表中的某个好友
2. 调用 `handleFriendClick(friend)`
3. 创建或切换到该好友的会话
4. 加载历史消息（如果还没有加载）
5. 调用 `markSessionAsRead(threadId, friendId)` 标记已读

### 2.2 前端标记已读流程

**位置**: `GlobalChat.jsx.markSessionAsRead()`

**流程**:

1. **获取 sessionId**
   - 优先从本地缓存 `threadIdToSessionId` 中获取
   - 如果不存在，调用 `GET /chat-service/api/sessions/private/{friendId}` 查询
   - 如果返回 404，说明会话不存在（还没有发送过消息），跳过标记已读

2. **调用后端API**
   ```javascript
   await post(`/chat-service/api/sessions/${sessionId}/read`)
   ```

3. **错误处理**
   - 如果获取 sessionId 失败，尝试从会话列表中查找
   - 如果标记已读失败，记录警告但不影响用户体验

### 2.3 后端标记已读流程

**位置**: `ChatSessionController.markAsRead()` 和 `ChatSessionServiceImpl.markAsRead()`

**流程**:

1. **验证用户权限**
   ```java
   ChatSessionMember member = memberRepository.findBySessionIdAndUserId(sessionId, userId)
       .orElseThrow(() -> new IllegalArgumentException("用户不是该会话的成员"));
   ```

2. **确定已读消息ID**
   - 如果请求中提供了 `messageId`，使用它
   - 否则，查询会话的最后一条消息ID
   - 如果会话没有消息，`readMessageId` 为 null

3. **更新已读状态**
   ```java
   member.setLastReadMessageId(readMessageId);
   member.setLastReadTime(OffsetDateTime.now());
   memberRepository.save(member);
   ```

**重要**: 即使 `readMessageId` 为 null（会话没有消息），也会更新 `last_read_time`。这样在计算未读数时，如果 `last_read_time` 不为 null，即使 `last_read_message_id` 为 null，也能正确判断为已读。

### 2.4 API 端点

**标记已读**:
```
POST /chat-service/api/sessions/{sessionId}/read
Query参数: messageId (可选，如果不提供则标记为最后一条消息)
```

**查询私聊会话ID**（仅查询，不创建）:
```
GET /chat-service/api/sessions/private/{otherUserId}
返回: { sessionId: "..." }
如果会话不存在，返回 404
```

## 3. 完整流程图

### 3.1 未读计数流程

```
用户打开应用
    ↓
前端调用 GET /chat-service/api/sessions
    ↓
后端查询用户的所有会话
    ↓
对每个会话调用 countUnreadMessages()
    ↓
查询 chat_session_member 表获取 last_read_message_id 和 last_read_time
    ↓
查询 chat_message 表统计未读消息数
    ↓
返回会话列表（包含 unreadCount）
    ↓
前端显示未读数
```

### 3.2 已读标记流程

```
用户点击会话/好友
    ↓
前端调用 handleOpenThread() 或 handleFriendClick()
    ↓
前端立即将未读数设为 0（乐观更新）
    ↓
加载历史消息（如果需要）
    ↓
调用 markSessionAsRead()
    ↓
获取 sessionId（从缓存或查询）
    ↓
调用 POST /chat-service/api/sessions/{sessionId}/read
    ↓
后端更新 chat_session_member 表
    - last_read_message_id = 最后一条消息ID（或 null）
    - last_read_time = 当前时间
    ↓
完成标记已读
```

## 4. 特殊情况处理

### 4.1 会话不存在（还没有发送过消息）

- 前端调用 `GET /chat-service/api/sessions/private/{friendId}` 返回 404
- 前端跳过标记已读（这是正常的，因为还没有消息）
- 不会创建会话和成员记录

### 4.2 成员记录不存在

- 在计算未读数时，如果成员记录不存在，返回所有未撤回的消息数
- 在标记已读时，如果成员记录不存在，会抛出异常（用户不是该会话的成员）

### 4.3 最后已读消息被删除

- 在计算未读数时，如果 `last_read_message_id` 对应的消息不存在
- 使用 `last_read_time` 作为兜底时间戳
- 统计 `created_at > last_read_time` 的消息

### 4.4 用户从未打开过会话

- `last_read_time` 为 null
- 返回所有未撤回的消息数（认为全部未读）

## 5. 性能优化

1. **避免子查询**: 使用时间戳直接比较，而不是通过 `last_read_message_id` 查询消息再比较
2. **索引优化**: 确保 `chat_message` 表的 `(session_id, created_at, is_recalled)` 有索引
3. **批量查询**: 在 `listUserSessions` 中，一次性查询所有会话的未读数，而不是逐个查询

## 6. 注意事项

1. **时间戳比较**: 使用 `created_at` 时间戳比较，而不是 UUID 比较（UUID 不是时间有序的）
2. **已撤回消息**: 已撤回的消息（`is_recalled = true`）不计入未读数
3. **乐观更新**: 前端在打开会话时立即将未读数设为 0，然后异步调用后端标记已读
4. **会话创建**: 会话和成员记录只在发送第一条消息时创建，而不是在打开聊天框时创建

