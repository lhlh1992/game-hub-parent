# Game Hub 项目风险清单与示例

> **文档范围**：覆盖整个 `game-hub-parent` 项目的风险识别，包括 Gateway、Game-service、System-service、前端、基础设施及跨服务风险。

---

## 一、Gateway 服务风险

### 1.1 JWT 黑名单性能瓶颈
- **风险**：每次请求都要查询 Redis 黑名单，高并发下成为性能瓶颈。
- **示例**：1000 QPS 时，每秒 1000 次 Redis 查询，可能导致 Redis 连接池耗尽或响应延迟。
- **改进**：
  - 使用本地缓存（Caffeine）缓存黑名单，定期刷新。
  - 或使用布隆过滤器（Bloom Filter）快速过滤，减少 Redis 查询。

### 1.2 会话状态检查性能问题
- **风险**：JWT 验证时同步查询 `SessionRegistry`，阻塞请求处理。
- **示例**：`checkSessionStatus()` 在 JWT 解码器中同步查询 Redis，高并发下延迟累积。
- **改进**：
  - 异步查询会话状态，或使用响应式编程优化。
  - 或将会话状态信息编码到 JWT Claims 中，减少查询。

### 1.3 WebSocket 认证 Token 传递安全
- **风险**：WebSocket 握手时通过 URL 参数传递 token，可能被日志记录或泄露。
- **示例**：`WebSocketTokenFilter` 从 URL 参数提取 `access_token`，访问日志可能记录完整 URL。
- **改进**：
  - 使用 WebSocket 子协议传递 token。
  - 或使用一次性握手 token，握手后立即失效。

### 1.4 Keycloak 连接失败降级策略缺失
- **风险**：Keycloak 不可用时，Gateway 无法验证 JWT，导致所有请求被拒绝。
- **示例**：Keycloak 宕机或网络中断，`issuer-uri` 无法访问，JWT 验证失败。
- **改进**：
  - 实现 JWT 公钥缓存，Keycloak 不可用时使用缓存公钥验证。
  - 或实现降级策略，允许配置的"紧急白名单"通过。

### 1.5 路由配置硬编码
- **风险**：路由规则硬编码在 `application.yml`，无法动态调整。
- **示例**：需要灰度发布或 A/B 测试时，必须重启服务修改配置。
- **改进**：
  - 使用 Spring Cloud Config 或 Nacos 动态配置路由。
  - 或实现路由规则 API，支持动态更新。

---

## 二、Game-service 服务风险

### 2.1 多节点一致性与互斥
- **风险**：同一房间的关键动作（AI 落子、玩家落子应用）在多台实例上并发执行，出现"双落子"或状态竞争。
- **示例**：两台节点都判断"轮到 AI"，各自本地调度 AI 任务并执行 → 两次 AI 落子同时发生，最终只一方成功持久化，另一方内存短暂不一致。
- **改进**：
  - AI 执行前加房间级分布式短锁（SETNX `ai:lock:{roomId}` + TTL）。
  - 或者对同一房间做"单房间单节点路由"。
  - place 失败（CAS 冲突）后立即回读 Redis 刷新内存。

### 2.2 倒计时恢复误触发
- **风险**：停止计时后若未清理 Redis 键，重启恢复会把已停任务当作活跃任务恢复。
- **示例**：上一盘停止计时但 Redis 仍有 `countdown:{key}`，服务重启后 `restoreAllActive` 重新调度。
- **现状**：`stop()` 已增加删除 `stateKey/holderKey`，风险已降低。

### 2.3 恢复扫描使用 KEYS
- **风险**：`redis.keys("countdown:*")` 在生产上阻塞、不可扩展。
- **示例**：键空间大时 KEYS 会卡住 Redis，影响全局读写。
- **改进**：改用 SCAN 游标遍历或维护活跃集合。

### 2.4 AI 分支 CAS 条件硬编码
- **风险**：AI 持久化使用固定 `expectedTurn=WHITE`，与实际回合不符时 CAS 失败，导致前端状态滞后。
- **示例**：AI 实为黑棋回合，但 CAS 期望写白方 → updateAtomically 返回失败，广播和存储出现不一致。
- **改进**：使用 `now.current()` 作为 expectedTurn。

### 2.5 回合锚点缺少 TTL/清理
- **风险**：`turnKey` 无 TTL 时可能残留旧锚点，快照或恢复读取混淆。
- **示例**：终局后未清理 `gomoku:turn:{roomId}`，新局或恢复读取到旧的截止时间。
- **改进**：设置合理 TTL，或在终局/重开/stop 时显式删除。

### 2.6 内存与 Redis 短暂不一致窗口
- **风险**：流程为"内存 Room 先变更 → Redis CAS"，并发下另一节点也变更内存 → 一方 CAS 失败，但内存已被改写。
- **示例**：两个节点几乎同时 place，失败方需主动回读 Redis，否则后续逻辑用到脏内存。
- **改进**：place 后 CAS 失败立即强制回读刷新；或将关键变更下沉为 Redis/Lua 原子操作。

### 2.7 用户鉴权未统一
- **风险**：当前房间/落子以 session/seatKey 为主，未与平台 Auth 的 userId 统一，易产生越权或冒用。
- **示例**：多端/刷新场景下 seatKey 泄漏导致错误绑定。
- **改进**：通过 Gateway 注入 userId，在 game-service 内以 userId 为主体鉴权；seatKey 仅用于恢复。

### 2.8 WebSocket 广播顺序与幂等
- **风险**：并发广播 STATE/SNAPSHOT 时序被打乱或重复。
- **示例**：客户端先收到旧 STATE 后收到新 SNAPSHOT，短暂错乱。
- **改进**：在服务端保证广播顺序；客户端按 `gameId/step` 幂等覆盖展示。

### 2.9 配置与阈值可调性
- **风险**：holder 锁 TTL、AI 延迟、倒计时 TTL 等写死，难以按环境调优。
- **改进**：外置化配置，可按环境/场景覆盖。

---

## 三、System-service 服务风险

### 3.1 Keycloak 事件处理失败
- **风险**：Keycloak 事件回调失败时，用户注册信息未同步到系统数据库。
- **示例**：`KeycloakEventController` 接收注册事件，但 `KeycloakEventServiceImpl` 处理失败（数据库异常、网络中断），用户无法登录系统。
- **改进**：
  - 实现事件重试机制（Kafka 或本地队列）。
  - 或定期同步 Keycloak 用户到系统数据库。

### 3.2 用户同步一致性
- **风险**：Keycloak 与系统数据库用户信息不一致，导致登录失败或权限错误。
- **示例**：Keycloak 中用户已删除，但系统数据库中仍存在，或反之。
- **改进**：
  - 实现双向同步机制。
  - 或使用 Keycloak 作为唯一数据源，系统数据库仅做缓存。

### 3.3 Keycloak Admin API 调用失败
- **风险**：调用 Keycloak Admin API 创建/更新用户时失败，但系统数据库已更新，导致数据不一致。
- **示例**：`UserServiceImpl.createUser()` 先更新系统数据库，再调用 Keycloak API 失败，回滚困难。
- **改进**：
  - 使用 Saga 模式或补偿事务。
  - 或先调用 Keycloak，成功后再更新系统数据库。

### 3.4 数据库事务边界不清晰
- **风险**：复杂业务操作（创建用户+分配角色+初始化权限）事务边界不清晰，部分失败导致数据不一致。
- **示例**：创建用户成功，分配角色失败，用户处于中间状态。
- **改进**：
  - 明确事务边界，使用 `@Transactional` 标注。
  - 或使用领域事件，异步处理非关键操作。

### 3.5 软删除数据残留
- **风险**：使用软删除（`deleted_at`）时，数据长期残留，影响查询性能和存储空间。
- **示例**：大量已删除用户记录占用数据库空间，查询时需要过滤 `deleted_at IS NULL`。
- **改进**：
  - 定期清理软删除数据（归档或物理删除）。
  - 或使用分区表，将已删除数据迁移到归档分区。

---

## 四、前端（game-hub-web）风险

### 4.1 Token 刷新失败处理
- **风险**：Token 过期时自动刷新失败，用户被强制登出，体验差。
- **示例**：`authService.ensureAuthenticated()` 刷新 token 失败，用户正在游戏中被迫登出。
- **改进**：
  - 实现重试机制，多次失败后再登出。
  - 或使用 WebSocket 心跳检测，提前刷新 token。

### 4.2 WebSocket 重连状态丢失
- **风险**：WebSocket 断线重连后，游戏状态未同步，用户看到错误状态。
- **示例**：网络中断后重连，`GomokuResumeController` 返回的 `FullSync` 数据不完整。
- **改进**：
  - 重连时强制请求完整状态快照。
  - 或维护本地状态缓存，重连后对比差异。

### 4.3 并发请求竞态条件
- **风险**：多个 API 请求并发执行，响应顺序不确定，导致状态错乱。
- **示例**：创建房间和加入房间同时发起，可能创建失败但加入成功，或反之。
- **改进**：
  - 使用请求队列，串行化关键操作。
  - 或使用乐观锁，客户端处理冲突。

### 4.4 内存泄漏
- **风险**：WebSocket 订阅、定时器、事件监听器未清理，导致内存泄漏。
- **示例**：`useGomokuGame` Hook 中订阅 WebSocket，组件卸载时未取消订阅。
- **改进**：
  - 使用 `useEffect` 清理函数，确保资源释放。
  - 或使用 React 18+ 的 `useSyncExternalStore` 管理外部状态。

---

## 五、基础设施风险

### 5.1 Redis 单点故障
- **风险**：Redis 单点故障导致所有服务不可用（会话、游戏状态、倒计时）。
- **示例**：Redis 宕机，Gateway 无法验证会话，Game-service 无法读取游戏状态。
- **改进**：
  - 使用 Redis Sentinel 或 Cluster 实现高可用。
  - 或实现降级策略，关键数据写入数据库。

### 5.2 PostgreSQL 数据一致性
- **风险**：数据库主从延迟或事务隔离级别不当，导致数据不一致。
- **示例**：主库写入用户，从库未同步，查询从库时用户不存在。
- **改进**：
  - 关键操作强制读主库。
  - 或使用分布式事务（Seata）保证一致性。

### 5.3 Kafka 消息丢失
- **风险**：Kafka 消息丢失导致会话事件未通知下游服务。
- **示例**：用户登出事件丢失，其他服务仍认为用户在线。
- **改进**：
  - 配置 Kafka 持久化和副本。
  - 或实现消息确认机制，确保消息送达。

### 5.4 Keycloak 可用性
- **风险**：Keycloak 不可用导致所有用户无法登录。
- **示例**：Keycloak 宕机或网络中断，Gateway 无法验证 JWT。
- **改进**：
  - 实现 Keycloak 集群。
  - 或使用 JWT 公钥缓存，短期不可用时使用缓存验证。

### 5.5 Docker Compose 单机部署限制
- **风险**：当前使用 Docker Compose 单机部署，无法水平扩展。
- **示例**：单机资源耗尽，无法通过增加节点扩容。
- **改进**：
  - 迁移到 Kubernetes，支持水平扩展。
  - 或使用 Docker Swarm 实现多节点部署。

---

## 六、跨服务风险

### 6.1 服务间调用失败
- **风险**：Game-service 调用 System-service 失败，用户信息获取失败。
- **示例**：`SystemUserClient.getUserInfo()` 调用失败，游戏无法显示用户昵称。
- **改进**：
  - 使用 Resilience4j 实现熔断、重试、降级。
  - 或使用本地缓存，服务不可用时使用缓存数据。

### 6.2 事件丢失或重复
- **风险**：Kafka 事件丢失或重复消费，导致数据不一致。
- **示例**：会话失效事件丢失，Gateway 未清理会话，用户仍可访问。
- **改进**：
  - 实现幂等性处理，重复事件不影响结果。
  - 或使用事件溯源，通过事件重建状态。

### 6.3 数据一致性
- **风险**：跨服务数据不一致，如 Keycloak 用户与系统数据库用户不一致。
- **示例**：Keycloak 中用户已删除，但系统数据库中仍存在。
- **改进**：
  - 使用 Saga 模式或分布式事务。
  - 或定期同步，保证最终一致性。

### 6.4 服务版本兼容性
- **风险**：服务版本升级导致接口不兼容，调用失败。
- **示例**：Game-service 升级后接口变更，Gateway 仍使用旧接口调用。
- **改进**：
  - 使用 API 版本控制（`/v1/`, `/v2/`）。
  - 或使用契约测试（Pact）保证接口兼容性。

---

## 七、可观测性与运维风险

### 7.1 可观测性不足
- **风险**：缺少核心指标与链路追踪，线上问题难定位。
- **示例**：无法快速定位"AI 双执行""倒计时误判"的节点与时刻。
- **改进**：接入指标（在线/房间/WS/失败率/延迟）、日志规范、TraceId、告警。

### 7.2 日志规范缺失
- **风险**：日志格式不统一，缺少 TraceId，难以追踪请求链路。
- **示例**：多个服务日志混杂，无法关联同一请求的日志。
- **改进**：
  - 统一日志格式（JSON），包含 TraceId、SpanId。
  - 或使用 OpenTelemetry 实现分布式追踪。

### 7.3 告警机制缺失
- **风险**：服务异常时无告警，问题发现延迟。
- **示例**：Redis 连接池耗尽，但无告警，用户请求失败后才发现。
- **改进**：
  - 接入 Prometheus + AlertManager。
  - 或使用云监控服务（如阿里云、AWS CloudWatch）。

### 7.4 配置管理混乱
- **风险**：配置分散在多个文件，环境差异大，容易出错。
- **示例**：开发环境配置与生产环境不一致，导致生产环境问题。
- **改进**：
  - 使用 Spring Cloud Config 或 Nacos 统一配置管理。
  - 或使用环境变量，通过 CI/CD 注入。

---

## 八、安全风险

### 8.1 JWT Token 泄露
- **风险**：JWT Token 泄露（日志、抓包），攻击者可冒充用户。
- **示例**：Token 写入日志文件，被恶意访问。
- **改进**：
  - 避免在日志中记录完整 Token。
  - 或使用短期 Token + Refresh Token，降低泄露影响。

### 8.2 SQL 注入
- **风险**：使用字符串拼接 SQL，存在 SQL 注入风险。
- **示例**：`@Query` 注解中使用字符串拼接，未使用参数化查询。
- **改进**：
  - 使用 JPA 方法查询或参数化查询。
  - 或使用 MyBatis，避免字符串拼接。

### 8.3 跨站脚本攻击（XSS）
- **风险**：前端未对用户输入进行转义，存在 XSS 风险。
- **示例**：聊天消息中包含恶意脚本，其他用户查看时执行。
- **改进**：
  - 使用 React 自动转义，或使用 DOMPurify 清理 HTML。
  - 或使用 Content Security Policy（CSP）限制脚本执行。

### 8.4 跨站请求伪造（CSRF）
- **风险**：缺少 CSRF 防护，攻击者可伪造请求。
- **示例**：用户登录后，恶意网站发起请求，执行用户操作。
- **改进**：
  - 使用 CSRF Token 或 SameSite Cookie。
  - 或使用 OAuth2 标准流程，减少 CSRF 风险。

---

## 九、性能风险

### 9.1 数据库连接池耗尽
- **风险**：高并发下数据库连接池耗尽，请求失败。
- **示例**：1000 并发请求，连接池大小 20，大量请求等待连接。
- **改进**：
  - 调整连接池大小，或使用连接池监控。
  - 或使用数据库读写分离，减少主库压力。

### 9.2 Redis 内存溢出
- **风险**：Redis 内存使用过高，触发淘汰策略，影响性能。
- **示例**：大量游戏状态和会话数据占用内存，Redis 内存不足。
- **改进**：
  - 设置合理的 TTL，及时清理过期数据。
  - 或使用 Redis Cluster，分片存储。

### 9.3 WebSocket 连接数限制
- **风险**：单机 WebSocket 连接数有限，无法支持大规模并发。
- **示例**：单机最多支持 65535 个连接，超过后新连接失败。
- **改进**：
  - 使用负载均衡，分散连接。
  - 或使用 WebSocket 集群，通过 Redis 共享会话。

---

## 十、建议优先级（摘要）

### P0（紧急，立即处理）
1. **Game-service**：AI 执行房间级分布式锁；AI CAS 使用 `now.current()`。
2. **Gateway**：JWT 黑名单性能优化（本地缓存或布隆过滤器）。
3. **System-service**：Keycloak 事件处理失败重试机制。

### P1（重要，近期处理）
1. **Game-service**：倒计时恢复改 SCAN；turnKey TTL/清理补齐。
2. **Game-service**：place CAS 失败后强制回读刷新内存；或评估 Lua 原子化。
3. **Gateway**：Keycloak 连接失败降级策略。
4. **基础设施**：Redis 高可用（Sentinel 或 Cluster）。

### P2（一般，计划处理）
1. **Game-service**：接入 Gateway+Auth，落子/入座改为基于 userId 鉴权。
2. **可观测性**：指标/日志/TraceId/告警接入；序列化统一为 JSON。
3. **跨服务**：服务间调用熔断、重试、降级（Resilience4j）。
4. **安全**：JWT Token 泄露防护，SQL 注入防护。

### P3（优化，长期规划）
1. **基础设施**：迁移到 Kubernetes，支持水平扩展。
2. **性能**：数据库读写分离，Redis Cluster。
3. **配置**：统一配置管理（Spring Cloud Config 或 Nacos）。

---

## 十一、风险跟踪

建议使用以下方式跟踪风险：
- **风险登记表**：记录每个风险的 ID、描述、影响、优先级、负责人、状态。
- **定期评审**：每月评审风险清单，更新状态和优先级。
- **问题追踪**：使用 Jira、GitHub Issues 等工具跟踪风险改进进度。

---

> **文档维护**：本文档应随项目演进持续更新，新增风险及时补充，已解决风险标记为"已解决"并记录解决方案。
