# 单点登录系统完整实现详解

> 教学级文档：涵盖登录、登出、JWT黑名单、WebSocket管理、单点登录（后连踢前）、Kafka通知WS断连等完整实现

---

## 📑 目录

### 认证系统架构
- [认证系统架构设计](#认证系统架构设计)

### 第一章：概念基础
- [一、背景与问题分析](#一背景与问题分析)
- [二、核心设计思想](#二核心设计思想)
- [三、关键概念定义](#三关键概念定义)

### 第二章：核心流程
- [四、登录流程完整实现](#四登录流程完整实现)
- [五、JWT校验流程完整实现](#五jwt校验流程完整实现)
- [六、Token获取接口实现](#六token获取接口实现)
- [七、登出流程完整实现](#七登出流程完整实现)
- [七点五、前端认证实现](#七点五前端认证实现)

### 第三章：扩展功能
- [八、WebSocket连接管理](#八websocket连接管理)
- [九、Kafka事件通知机制](#九kafka事件通知机制)

### 第四章：核心组件
- [十、SessionRegistry核心实现](#十sessionregistry核心实现)
- [十一、JWT黑名单机制](#十一jwt黑名单机制)

### 第五章：总结与深化
- [十二、完整数据流图](#十二完整数据流图)
- [十三、关键设计决策](#十三关键设计决策)
- [十四、边界场景处理](#十四边界场景处理)

### 第六章：实践与运维
- [十五、测试验证](#十五测试验证)
- [十六、常见问题与解决方案](#十六常见问题与解决方案)
- [十七、性能优化建议](#十七性能优化建议)
- [十八、监控与运维](#十八监控与运维)

### 第七章：附录
- [附录](#附录)

---

## 认证系统架构设计

> **本章目标**：从顶层视角理解登录认证系统的架构设计，掌握各组件之间的交互关系和数据流向。
> 
> **说明**：本章仅描述**登录、认证、鉴权、登出**相关的系统架构，不涉及业务系统架构。

---

### 架构总览

本认证系统采用 **Keycloak + Gateway + Kafka + Redis** 的微服务架构，实现单点登录（SSO）、会话管理和 WebSocket 连接控制。

**架构特点**：
- **微服务架构**：Gateway、应用服务等独立服务，职责清晰
- **状态共享**：通过 Redis 实现会话状态共享，支持多实例部署
  - **统一 Redis 库**：所有服务（Gateway、game-service、system-service 等）使用相同的 Redis database（默认 database 0），确保会话数据共享
- **事件驱动**：通过 Kafka 实现服务间异步通信，解耦服务依赖
- **水平扩展**：Gateway 和应用服务均可多实例部署，通过共享存储协调

**文档范围说明**：
- ✅ 本文档仅描述**登录、认证、鉴权、登出**相关功能
- ✅ 不涉及业务逻辑、角色权限控制等业务功能
- ✅ 以 game-service 作为应用服务示例，展示 WebSocket 连接管理

#### 认证系统架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    登录认证系统架构图 (SSO 架构)                                │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          OAuth2/OIDC 角色定义                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Resource Owner (资源所有者): 用户 (User)                                      │
│  Client (客户端): Gateway (Confidential Client)                               │
│    - Gateway 作为 OAuth2 Client，处理与 Keycloak 的授权码流程                    │
│    - 前端应用通过 Gateway 的 /token 接口获取 token         						│
│  Authorization Server (授权服务器): Keycloak                                  │
│  Resource Server (资源服务器): Gateway, 应用服务 (game-service 等)              │
└─────────────────────────────────────────────────────────────────────────────┘

        ┌──────────────┐
        │   User       │  Resource Owner
        │  (用户)       │
        └──────┬───────┘
               │
               │ HTTP/HTTPS
               │
        ┌──────▼──────────────────────────────────────────────────┐
        │  Frontend Application                                    │
        │  (前端应用 - React)                                        │
        │  • AuthContext: 管理全局认证状态                            │
        │  • authService: 封装认证服务（获取token、验证、登出）      │
        │  • apiClient: HTTP请求自动携带token                        │
        │  • gomokuSocket: WebSocket连接传递token                    │
        │  • ProtectedRoute: 路由保护                               │
        │  • 通过 Gateway /token 接口获取 token                     │
        │  • 通过 Gateway /oauth2/authorization/keycloak 触发登录     │
        │  • 通过 Gateway /logout 接口登出                          │
        │  • 访问 Gateway (携带 JWT Token)                          │
        │  • Token 存储在 localStorage                             │
        └──────┬──────────────────────────────────────────────────┘
               │
               │ OAuth2/OIDC 授权码流程
               │
        ┌──────▼──────────────────────────────────────────────────┐
        │  Gateway                                                │
        │  (Confidential Client + Resource Server)                │
        │                                                         │
        │  • OAuth2 Login (处理 Keycloak 回调)                      │
        │  • /token (提供 Token 获取接口)                           │
        │  • /logout (处理登出流程)                                 │
        │  • JWT 验证 (三层验证: 黑名单/签名/会话状态)                  │
        │  • TokenRelay (透传 JWT 到下游服务)                        │
        │  • SessionRegistry (会话状态管理)                          │
        │  • 发布 Kafka 事件 (SESSION_INVALIDATED)                  │
        └──────┬──────────────────────────────────────────────────┘
               │                          
               │ OAuth2/OIDC               
               │                          
        ┌──────▼──────────────┐           
        │  Keycloak           │           
        │  (Authorization     │           
        │   Server)           │           
        │                     │          
        │  • 用户登录/注册      │           
        │  • 生成 JWT Token    │          
        │    (包含 sid/sub/jti)│           
        │  • 用户状态管理       │           
        │  • Webhook 推送事件   │
        │    (REGISTER/UPDATE │			  
        │     _PROFILE/...)   │			  
        └─────────────────────┘           
                             │              
                             │         
                          ┌──▼────────────────────────────┐
                          │  system-service               │
                          │  (Resource Server)            │
                          │                               │
                          │  • 接收 Webhook 事件            │
                          │    (/internal/keycloak/events)│
                          │  • 用户同步 (REGISTER)          │
                          │  • 事件处理                     │
                          └──────────────────────────────┘

        ┌──────────────────────────────────────────────────────────┐
        │  Kafka (事件总线)                                          │
        │                                                           │
        │  Topic: session-invalidated                               │
        │  • SESSION_INVALIDATED 事件                               │
        │  • 来源: Gateway (登出/单点登录后连踢前)                      │
        └──────┬───────────────────────────────────────────────────┘
               │
               │ 消费事件
               │
        ┌──────▼──────────────────────────────────────────────────┐
        │  应用服务 (示例: game-service)                            │
        │  (Resource Server)                                      │
        │                                                         │
        │  • JWT 验证 (WebSocket/REST API)                         │
        │  • WebSocket Auth (握手时验证 JWT)                        │
        │  • WebSocket SSO (监听 Kafka 事件)                        │
        │  • 注册/踢掉 WebSocket 连接                                │
        └──────┬──────────────────────────────────────────────────┘
               │
               │ 读写
               │
        ┌──────▼──────────────────────────────────────────────────┐
        │   Redis (SSO 状态存储)                                    │
        │                                                          │
        │  • session:login:loginSession:{loginSessionId} (LoginSessionInfo)     │
        │  • ws:session:{loginSessionId} (WebSocket 映射)          │
        │  • jwt:blacklist:{jti} (JWT 黑名单)                       │
        └──────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                              核心流程                                        								  │
├───────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│  1. 登录流程:                                                                								  │
│     User → Frontend → Gateway (OAuth2 Client) → Keycloak → Gateway → Frontend → User   								│
│                                                                              								│
│  2. 登出流程:                                                                								  │
│     User → Gateway → Redis (token黑名单) → KeycloakSsoLogoutService 注销 SSO 会话 → Kafka消息 → 应用服务 (断开 WebSocket)│
│                                                                              								 │
│  3. 单点登录 (后连踢前):                                                     									│
│     新登录 → Gateway → Redis (标记旧会话 KICKED) → KeycloakSsoLogoutService 注销旧 SSO 会话 → Kafka消息 → 应用服务(断开 WebSocket)│
│                                                                              								 │
│  4. 资源访问:                                                                								   │
│     User → Gateway (验证 JWT) → TokenRelay → 应用服务 (验证 JWT) → 响应    									   │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

#### 架构组件说明

**1. User（用户 / Resource Owner）**

- **OAuth2 角色**：Resource Owner（资源所有者）
- **职责**：发起登录请求，使用系统资源
- **交互方式**：通过浏览器/前端访问 Gateway

**2. Frontend Application（前端应用）**

- **OAuth2 角色**：不是 OAuth2 Client，只是通过 Gateway 获取 token 的客户端应用
- **职责**：通过 Gateway 获取 JWT Token，携带 Token 访问资源
- **关键功能**：
  - 通过 Gateway 的 `/token` 接口获取 token（Gateway 作为 OAuth2 Client 处理与 Keycloak 的交互）
  - 通过 Gateway 的 `/oauth2/authorization/keycloak` 端点触发登录流程
  - 在 Authorization Header 中携带 JWT Token 访问 Gateway 受保护资源
  - Token 存储在浏览器 `localStorage` 中
- **认证流程**：
  1. 前端调用 Gateway `/token` 接口
  2. 如果未登录，Gateway 返回 401，前端跳转到 `/oauth2/authorization/keycloak`
  3. Gateway 作为 OAuth2 Client 处理与 Keycloak 的授权码流程
  4. 登录成功后，前端再次调用 `/token` 接口获取 token

**注意**：
- **浏览器（Browser）** 不是 OAuth2 Client，它只是 User Agent（用户代理），用于运行前端应用代码
- **前端应用（Frontend Application）** 也不是 OAuth2 Client，它只是通过 Gateway 获取 token
- **Gateway** 才是 OAuth2 Client（Confidential Client），负责处理与 Keycloak 的 OAuth2 流程

**3. Keycloak（认证服务器 / Authorization Server）**

- **OAuth2 角色**：Authorization Server（授权服务器）
- **职责**：提供 OAuth2/OIDC 标准认证服务
- **功能**：
  - 用户登录/注册
  - 生成 JWT Token（包含 `sid`、`sub`、`jti` 等 claim）
  - 管理用户会话状态
  - 用户状态变更（禁用、启用、密码修改等）
- **输出**：
  - JWT Token（包含 `sub`、`sid`、`jti` 等 claim）
  - **Webhook 事件**：通过 HTTP POST 直接推送到 `system-service`（**不是 Kafka**）
- **Webhook 事件类型**：
  - `REGISTER`：用户注册
  - `LOGIN`：用户登录
  - `LOGOUT`：用户登出
  - `UPDATE_PROFILE`：用户资料更新
  - `USER_DISABLED`：用户被禁用（管理事件）
  - `PASSWORD_CHANGED`：密码修改（管理事件）
- **Webhook 推送方式**：Keycloak → HTTP POST → `system-service` `/internal/keycloak/events`

**4. Gateway（网关服务 / Confidential Client + Resource Server）**
- **OAuth2 角色**：
  - **Confidential Client**：与 Keycloak 进行 OAuth2 授权码流程（使用 client_secret）
  - **Resource Server**：验证 JWT Token，保护资源
- **Client 类型**：Confidential Client（需要 client_secret，可安全存储凭证）
- **职责**：统一入口，处理认证、授权和路由转发
- **核心功能**：
  - **OAuth2 Login**：处理 Keycloak 登录回调，建立 Gateway Session
  - **/token**：提供 Token 获取接口，支持自动刷新
  - **/logout**：处理登出流程，写入 JWT 黑名单，发布 Kafka 事件
  - **JWT 验证**：三层验证（黑名单检查、签名验证、会话状态检查）
  - **TokenRelay**：自动将 JWT Token 透传到下游应用服务
  - **SessionRegistry**：管理所有活跃会话（存储在 Redis）
  - **发布 Kafka 事件**：登出、后连踢前时发布 `SESSION_INVALIDATED` 事件
  - **WebSocketTokenFilter**：在 WebSocket 握手阶段把 `access_token`（query/header）转换成 `Authorization: Bearer`，确保下游服务能够复用统一的 JWT 校验链路
- **关键设计**：
  - 使用 `sid`（loginSessionId）作为会话标识
  - 维护 `SessionRegistry` 管理所有活跃会话
  - 实现"后连踢前"逻辑（新登录踢掉旧登录）

**5. system-service（系统服务 / Resource Server）**
- **OAuth2 角色**：Resource Server（资源服务器）
- **职责**：接收和处理 Keycloak 用户事件，同步用户状态
- **核心功能**：
  - **接收 Webhook 事件**：监听 `/internal/keycloak/events` 端点（**HTTP POST，不是 Kafka**）
  - **用户同步**：处理 `REGISTER` 事件，同步用户信息到本地数据库
  - **事件处理**：处理 `UPDATE_PROFILE`、`USER_DISABLED` 等事件
- **关键设计**：
  - 使用 Basic Auth 验证 Webhook 请求（共享密钥）
  - 事件处理后，可触发会话失效（如用户禁用时）
- **说明**：本文档以 system-service 为例，展示如何接收 Keycloak Webhook 事件

**6. Kafka（事件总线）**
- **职责**：异步事件通知机制，用于会话状态变更通知
- **事件类型**：`SESSION_INVALIDATED`
- **触发场景**：
  - 用户主动登出
  - 新设备登录（后连踢前）
  - 会话过期
  - 用户被禁用（由 system-service 触发，未来扩展）
  - 密码修改（由 system-service 触发，未来扩展）
- **事件内容**：
  ```json
  {
    "loginSessionId": "sid-xxx",
    "userId": "user-123",
    "reason": "LOGOUT|KICKED|EXPIRED|USER_DISABLED|PASSWORD_CHANGED",
    "timestamp": "2024-01-01T00:00:00Z"
  }
  ```
- **事件来源**：
  - **Gateway 发布**：登录、登出、后连踢前
  - **system-service 发布**：用户禁用、密码修改等（可选，未来扩展）
- **重要说明**：Kafka 事件流与 Keycloak Webhook 事件流是**完全独立**的两条事件流

**7. 应用服务（示例：game-service / Resource Server）**
- **OAuth2 角色**：Resource Server（资源服务器）
- **职责**：处理 WebSocket 连接管理（作为 SSO 系统的下游服务示例）
- **核心功能**：
  - **JWT 验证**：验证从 Gateway 透传的 JWT Token（用于提取用户信息，确保本地验证）
  - **WebSocket Auth**：WebSocket 握手时验证 JWT Token
  - **WebSocket SSO**：监听 Kafka 事件，断开被踢掉的 WebSocket 连接
  - **注册/踢掉 WS**：管理 WebSocket 连接与 loginSessionId 的映射关系
- **关键设计**：
  - WebSocket 连接建立时，将 `loginSessionId` 与连接绑定
  - 收到 `SESSION_INVALIDATED` 事件时，查找并断开对应的 WebSocket 连接
  - **JWT 验证**：即使 Gateway 已验证，应用服务也会再次验证 JWT（用于提取用户信息，确保本地验证）
- **说明**：本文档以 game-service 为例，实际可以是任何需要 WebSocket 连接管理的应用服务

**8. Redis（SSO 状态存储）**
- **职责**：存储会话状态和 WebSocket 连接映射
- **数据结构**：
  - **`session:login:loginSession:{loginSessionId}`**：存储 `LoginSessionInfo`（会话状态、用户信息等）
  - **`ws:session:{loginSessionId}`**：存储 WebSocket 连接标识（用于跨服务查找）
  - **`jwt:blacklist:{jti}`**：存储已撤销的 JWT Token（黑名单）
- **TTL 策略**：
  - 会话信息：与 JWT 刷新 Token 有效期一致
  - WebSocket 映射：连接断开时自动清理
  - JWT 黑名单：与 JWT Token 有效期一致

---

### 数据流向说明

#### 1. 登录流程（前后端交互）

```
前端应用（React）
    │
    │ 1. 用户访问受保护资源（如 /lobby）
    │ 2. AuthProvider 初始化，调用 ensureAuthenticated(true)
    │ 3. 尝试从 Gateway 获取 token（GET /token，带cookie）
    │ 4. 如果未登录（返回401），跳转到 /oauth2/authorization/keycloak
    ▼
Gateway API
    │
    │ 5. Spring Security OAuth2 Client Filter 拦截
    │ 6. 构建授权URL，重定向到 Keycloak
    ▼
Keycloak
    │
    │ 7. 用户在 Keycloak 登录页面输入用户名密码
    │ 8. Keycloak 验证用户凭证
    │ 9. Keycloak 生成授权码，重定向回 Gateway
    │ 10. 回调URL: /login/oauth2/code/keycloak?code=xxx&state=xxx
    ▼
Gateway API
    │
    │ 11. Gateway 使用授权码换取 access_token
    │ 12. LoginSessionKickHandler 处理登录成功
    │     ├─ 解析 JWT，提取 sid（loginSessionId）、jti（sessionId）、userId
    │     ├─ 存储到 Redis: session:login:loginSession:{sid}
    │     ├─ 注册到 SessionRegistry（registerLoginSessionEnforceSingle）
    │     ├─ 检查是否有旧会话，如有则踢掉（标记为KICKED，加入黑名单，发布 Kafka 事件）
    │     └─ 存储 loginSessionId 到 HTTP Session
    │ 13. Gateway 重定向回前端（原始地址或首页）
    ▼
前端应用
    │
    │ 14. 前端再次调用 ensureAuthenticated()
    │ 15. 前端调用 GET /token（带cookie: JSESSIONID）
    │ 16. Gateway 从 Session 中获取 token，返回给前端
    │ 17. 前端保存 token 到 localStorage（键名：access_token）
    │ 18. 前端设置认证状态（isAuthenticated = true）
    │ 19. 前端加载用户信息（getUserInfo()）
    │ 20. 前端渲染应用
    ▼
用户浏览器（获得 Session Cookie + localStorage 中的 token）
```

#### 2. Token 获取流程（前后端交互）

```
前端应用
    │
    │ 1. 前端需要 token（HTTP请求或WebSocket连接）
    │ 2. 调用 ensureAuthenticated()
    │ 3. 优先从 Gateway 获取最新 token
    │    GET /token (携带cookie: JSESSIONID，credentials: 'include')
    ▼
Gateway API
    │
    │ 4. TokenController.getToken()
    │    ├─ 检查 Authentication（未认证返回401）
    │    ├─ 从 Session 获取 OAuth2AuthorizedClient
    │    ├─ 验证 loginSessionId 与 Session 匹配
    │    ├─ 检查 SessionRegistry 中的会话状态（如果状态为 KICKED，返回 401）
    │    ├─ 验证 token 的 jti 与会话的 sessionId 匹配
    │    └─ 如果状态为 ACTIVE，返回 access_token（如果token已过期，自动刷新）
    ▼
前端应用
    │
    │ 5. 如果 Gateway 返回401，说明未登录，触发登录流程
    │ 6. 如果 Gateway 返回200，获取到 token
    │ 7. 前端验证 token 有效性（GET /game-service/me，Authorization: Bearer {token}）
    │ 8. 如果token有效，保存到 localStorage（键名：access_token）
    │ 9. 返回 token 供后续使用
    ▼
用户浏览器（localStorage 中保存 JWT Token）
```

#### 3. 登出流程（前后端交互）

```
前端应用
    │
    │ 1. 用户点击登出按钮
    │ 2. 调用 logoutFromGateway()
    │ 3. POST /logout (携带cookie: JSESSIONID，credentials: 'include')
    ▼
Gateway API
    │
    │ 4. Spring Security Logout Filter 拦截
    │ 5. jwtBlacklistLogoutHandler 执行登出处理
    │    ├─ 获取 OAuth2AuthorizedClient（从 Session）
    │    ├─ 提取当前 loginSessionId（sid）
    │    ├─ 将 JWT 写入黑名单（JwtBlacklistService）
    │    ├─ 发布 Kafka 事件：SESSION_INVALIDATED（包含 loginSessionId）
    │    ├─ 清理 SessionRegistry（removeAllSessions(userId)）
    │    └─ 移除 OAuth2AuthorizedClient
    │ 6. OidcClientInitiatedServerLogoutSuccessHandler
    │    └─ 调用 KeycloakSsoLogoutService（Keycloak Admin API）失效对应的 SSO 会话
    │ 7. Gateway 重定向到前端首页（http://localhost:5173/）
    ▼
Kafka
    │
    │ 事件：SESSION_INVALIDATED（包含 loginSessionId）
    ▼
game-service
    │
    │ 8. SessionInvalidatedListener 监听 Kafka 事件
    │ 9. 基于 loginSessionId 查询 WebSocket 会话
    │ 10. 断开对应的 WebSocket 连接
    ▼
前端应用
    │
    │ 11. 前端清除本地 token（localStorage.removeItem('access_token')）
    │ 12. 前端设置认证状态（isAuthenticated = false）
    │ 13. 前端渲染首页（未登录状态）
    ▼
用户浏览器（WebSocket 连接断开，token已清除）
```

#### 4. 后连踢前流程（前后端交互）

```
设备 1（前端）：已登录，WebSocket 连接活跃
    │
    │ 1. 设备 1 已建立 WebSocket 连接
    │ 2. 设备 1 已保存 token 到 localStorage
    │
设备 2（前端）：用户登录
    │
    │ 3. 设备 2 跳转到 /oauth2/authorization/keycloak
    │ 4. 设备 2 在 Keycloak 登录成功
    ▼
Gateway API
    │
    │ 5. LoginSessionKickHandler 处理登录成功
    │    ├─ 检测到设备 1 的旧会话（通过 userId 查询所有 ACTIVE 会话）
    │    ├─ 在 Redis / SessionRegistry 中将设备 1 会话标记为 KICKED
    │    ├─ 删除旧会话记录（unregisterLoginSession）
    │    ├─ 把旧 JWT 写入黑名单（JwtBlacklistService）
    │    ├─ 调用 KeycloakSsoLogoutService 让 Keycloak 端的设备 1 会话立即失效
    │    ├─ 发布 Kafka 事件：SESSION_KICKED（loginSessionId = 设备1的 sid）
    │    └─ 注册设备 2 的新会话（registerLoginSessionEnforceSingle）
    ▼
Kafka
    │
    │ 事件：SESSION_KICKED（包含 loginSessionId = 设备1的 sid）
    ▼
game-service
    │
    │ 6. SessionInvalidatedListener 监听 Kafka 事件
    │ 7. 基于 loginSessionId 查询 WebSocket 会话（SessionRegistry）
    │ 8. 断开设备 1 的 WebSocket 连接（WebSocketDisconnectHelper）
    │ 9. 发送 KICKED 消息到设备 1（/user/queue/gomoku.kicked）
    ▼
设备 1（前端）
    │
    │ 10. WebSocket 连接断开（onDisconnect 回调）
    │ 11. 前端检测到连接断开
    │ 12. 前端显示认证过期弹窗
    │     ├─ 提示："您的登录已过期或被其他设备挤下线，请重新登录后继续。"
    │     └─ 提供"重新登录"按钮
    │ 13. 用户点击"重新登录"
    │ 14. 前端跳转到 /oauth2/authorization/keycloak
    │ 15. 重新登录流程
    ▼
设备 2（前端）
    │
    │ 16. Gateway 重定向回设备 2
    │ 17. 设备 2 获取 token，保存到 localStorage
    │ 18. 设备 2 建立 WebSocket 连接
    │ 19. 设备 2 正常使用
```
game-service
    │
    │ 1. 监听 Kafka 事件
    │ 2. 断开设备 1 的 WebSocket 连接
    ▼
设备 1：WebSocket 断开，后续 API 请求返回 401
```

---

### 架构设计原则

1. **解耦设计**
   - 登录会话 ID（`sid`）与访问令牌（`jti`）解耦
   - 会话状态管理与 Token 管理分离
   - Gateway 与下游应用服务通过 Kafka 事件解耦

2. **统一入口**
   - 所有认证请求通过 Gateway 统一处理
   - Gateway 负责 JWT 解析和会话状态校验（三层验证）
   - Gateway 通过 TokenRelay 透传 JWT 到下游服务
   - 下游应用服务也验证 JWT（用于提取用户信息，确保本地验证）

3. **事件驱动**
   - **Keycloak Webhook 事件**：Keycloak 推送用户事件（注册、禁用等）到 system-service
   - **Kafka 会话事件**：Gateway 发布会话失效事件，下游应用服务监听并断开 WebSocket 连接
   - 避免轮询，提高性能和实时性

4. **状态集中管理**
   - 会话状态统一存储在 Redis（共享存储）
   - SessionRegistry 维护内存索引（快速查询）
   - **支持水平扩展**：多个 Gateway 实例通过 Redis 共享会话状态，实现分布式部署

---

### 本章总结

本章从顶层视角展示了**登录认证系统**的架构设计，包括：

- ✅ **8 个核心组件**：User（用户）、Browser/Frontend（浏览器/前端）、Keycloak（认证服务器）、Gateway（网关）、system-service（系统服务）、Kafka（事件总线）、应用服务（示例：game-service）、Redis（状态存储）
- ✅ **4 个核心流程**：登录、Token 获取、登出、后连踢前
- ✅ **4 个设计原则**：解耦、统一入口、事件驱动、状态集中管理

**关键要点**：
- Gateway 是认证系统的核心控制点，负责会话管理和状态校验
- Kafka 用于异步事件通知，实现服务间解耦
- Redis 作为共享存储，实现会话状态共享（支持多实例部署）
- `sid`（loginSessionId）是认证系统的核心标识符

**架构范围说明**：
- ✅ 本架构图仅展示**登录认证系统**的组件和交互
- ✅ 不包含业务系统的架构（如游戏逻辑、订单系统等）
- ✅ system-service 仅展示用户事件接收和同步功能（不涉及完整的用户管理业务）
- ✅ 应用服务（game-service）仅作为示例，展示如何集成认证系统

**事件驱动机制说明**：

本系统使用**两条完全独立的事件流**，分别处理不同的事件类型：

1. **Keycloak Webhook 事件流**（用户状态事件）
   - **流向**：Keycloak → **HTTP POST** → `system-service` `/internal/keycloak/events`
   - **传输方式**：**HTTP POST**（不是 Kafka）
   - **事件类型**：`REGISTER`（用户注册）、`UPDATE_PROFILE`（资料更新）、`USER_DISABLED`（用户禁用）、`PASSWORD_CHANGED`（密码修改）等
   - **用途**：同步用户状态到本地数据库，处理用户相关事件
   - **特点**：Keycloak 主动推送，system-service 被动接收

2. **Kafka 会话事件流**（会话失效事件）
   - **流向**：Gateway → **Kafka** → 应用服务（如 game-service）
   - **传输方式**：**Kafka**（消息队列）
   - **事件类型**：`SESSION_INVALIDATED`（会话失效）
   - **触发场景**：用户登出、后连踢前、会话过期等
   - **用途**：通知所有应用服务断开对应的 WebSocket 连接
   - **特点**：Gateway 发布，应用服务订阅消费

**重要区别**：
- **Webhook 事件流**：Keycloak 直接通过 HTTP POST 推送到 system-service，用于用户状态同步
- **Kafka 事件流**：Gateway 发布到 Kafka，应用服务订阅消费，用于会话失效通知
- **两者完全独立**：Webhook 事件不会进入 Kafka，Kafka 事件不会来自 Keycloak Webhook

**未来扩展**：system-service 收到用户禁用/密码修改事件后，可发布 Kafka 事件通知所有服务失效该用户的所有会话

**关于"分布式"的说明**：
- 架构图展示的是单实例部署（便于理解）
- 实际生产环境支持**水平扩展**：
  - Gateway 可部署多个实例（通过 Redis 共享 SessionRegistry 状态）
  - 应用服务可部署多个实例（通过 Kafka 消费事件，通过 Redis 共享 WebSocket 映射）
  - 所有实例通过 Redis 和 Kafka 实现状态协调和事件通信



---

## 一、背景与问题分析

> **本章目标**：理解功能需求和技术挑战，明确为什么需要这个方案，以及为什么选择 `sid` 作为 `loginSessionId`。

---

### 1.1 功能需求

#### 1.1.1 单点登录（SSO）需求

**应用场景**：
- 用户在多设备（PC、手机、平板）上使用系统
- 系统要求：**同一用户在同一时刻只能在一个设备上登录**
- 新设备登录时，旧设备应该自动退出

**期望效果**：
```
用户 A 在设备 1 登录 → 正常使用
用户 A 在设备 2 登录 → 设备 2 成为唯一有效登录
设备 1 上的所有操作 → 立即失效，提示「账号已在其他设备登录」
```

#### 1.1.2 后连踢前需求

**应用场景**：
- 用户忘记在旧设备上登出
- 用户在新设备上登录
- **新登录应该自动踢掉旧登录**，无需用户手动操作

**期望效果**：
```
旧设备：用户正在使用系统
新设备：用户登录
结果：旧设备的所有请求被拒绝，提示「账号已在其他设备登录」
```

#### 1.1.3 登出时 WebSocket 断连需求

**应用场景**：
- 用户通过 WebSocket 连接进行实时通信
- 用户登出时，所有 WebSocket 连接应该立即断开
- 用户在其他设备登录时，旧设备的 WebSocket 连接也应该断开

**期望效果**：
```
用户登出 → 所有 WebSocket 连接立即断开
用户在其他设备登录 → 旧设备的 WebSocket 连接立即断开
```

---

### 1.2 技术挑战

#### 1.2.1 JWT Token 刷新导致 jti 变化

**问题描述**：
- JWT token 有有效期（如 15 分钟）
- token 过期后，系统会自动使用 `refresh_token` 刷新
- **刷新后的新 token 的 `jti`（JWT ID）可能变化**

**问题示例**：
```
初始登录：
  Token 1: jti = "jti-001", loginSessionId = "sid-001"

Token 刷新后：
  Token 2: jti = "jti-002", loginSessionId = "sid-001" ← jti 变了，但 loginSessionId 不变
```

**影响**：
- ❌ 如果使用 `jti` 作为会话标识，刷新后无法关联到同一个会话
- ❌ 无法判断新 token 和旧 token 是否属于同一个登录会话
- ❌ 无法实现单点登录（后连踢前）

#### 1.2.2 OAuth2AuthorizedClientService 按 userId 覆盖

**问题描述**：
- Spring Security 的 `OAuth2AuthorizedClientService` 使用 `userId` 作为 key 存储授权客户端
- 同一用户的所有授权客户端共享同一个 key
- **新登录会覆盖旧登录的授权客户端**

**问题示例**：
```
设备 1 登录：
  OAuth2AuthorizedClientService[userId="user-123"] = Client1

设备 2 登录：
  OAuth2AuthorizedClientService[userId="user-123"] = Client2 ← 覆盖了 Client1
```

**影响**：
- ❌ 设备 1 调用 `/token` 接口时，可能获取到设备 2 的 token
- ❌ 无法区分同一用户的不同登录会话
- ❌ 无法实现单点登录（后连踢前）

#### 1.2.3 HTTP Session 无法通过 userId 清除

**问题描述**：
- Spring Security 的 HTTP Session 使用 Session ID（Cookie 中的 `JSESSIONID`）作为 key
- **无法通过 `userId` 直接查找或清除其他设备的 Session**
- 每个设备的 Session 是独立的

**问题示例**：
```
设备 1：Session ID = "session-001", userId = "user-123"
设备 2：Session ID = "session-002", userId = "user-123"

设备 2 登录后，无法清除设备 1 的 Session
```

**影响**：
- ❌ 设备 1 的 `Authentication` 仍然有效
- ❌ 设备 1 可以继续使用缓存的 token 调用 API
- ❌ 无法实现单点登录（后连踢前）

#### 1.2.4 WebSocket 长连接管理

**问题描述**：
- WebSocket 是长连接，连接建立后不会自动断开
- 用户登出或在新设备登录时，需要主动断开旧设备的 WebSocket 连接
- **需要一种机制来通知所有服务断开特定用户的 WebSocket 连接**

**问题示例**：
```
设备 1：WebSocket 连接活跃
设备 2：用户登录
结果：需要断开设备 1 的 WebSocket 连接
```

**影响**：
- ❌ 如果无法精确断开，旧设备的 WebSocket 连接可能一直保持
- ❌ 用户可能收到不应该收到的消息
- ❌ 资源浪费（保持无效连接）

---

### 1.3 为什么需要 loginSessionId（sid）

#### 1.3.1 jti 的问题

**问题**：token 刷新时 `jti` 可能变化

**示例**：
```
初始登录：
  Token: jti = "jti-001"

刷新后：
  Token: jti = "jti-002" ← 变了！
```

**影响**：
- ❌ 无法使用 `jti` 作为稳定的会话标识
- ❌ 刷新后无法关联到同一个登录会话
- ❌ 无法实现单点登录

#### 1.3.2 session_state 的问题

**问题**：`session_state` 可能不稳定或不总是可用

**示例**：
```
某些 Keycloak 版本：
  - session_state 可能不在 JWT claim 中
  - session_state 可能在 token 刷新时变化
  - session_state 的格式可能不一致
```

**影响**：
- ❌ 依赖 `session_state` 可能不稳定
- ❌ 不同 Keycloak 版本行为可能不同
- ❌ 需要额外的配置（Mapper）

#### 1.3.3 sid 的优势

**优势**：Keycloak 原生会话 ID，稳定不变

**特性**：
- ✅ **稳定性**：在整个登录生命周期内稳定不变
- ✅ **原生支持**：Keycloak 原生提供，无需额外配置
- ✅ **标准规范**：符合 OIDC 规范（Session ID）
- ✅ **token 刷新不变**：token 刷新时 `sid` 保持不变

**示例**：
```
初始登录：
  Token: sid = "sid-001", jti = "jti-001"

刷新后：
  Token: sid = "sid-001", jti = "jti-002" ← sid 不变，jti 变了
```

**结论**：
- ✅ 使用 `sid` 作为 `loginSessionId` 是最佳选择
- ✅ 可以稳定地标识整个登录会话
- ✅ 可以解决所有技术挑战

---

### 1.4 问题总结

**核心问题**：
1. ❌ 使用 `jti` 作为会话标识 → token 刷新时变化
2. ❌ `OAuth2AuthorizedClientService` 按 `userId` 覆盖 → 无法区分不同登录会话
3. ❌ HTTP Session 无法通过 `userId` 清除 → 旧设备仍然有效
4. ❌ WebSocket 长连接管理 → 需要精确断开机制

**解决方案**：
1. ✅ 使用 `sid` 作为 `loginSessionId` → 稳定不变
2. ✅ 引入 `SessionRegistry` → 集中管理会话状态
3. ✅ 三层校验机制 → 签名 + 黑名单 + 状态
4. ✅ Kafka 事件通知 → 精确断开 WebSocket

---

### 1.5 本章总结

**功能需求**：
- 单点登录（SSO）
- 后连踢前
- 登出时 WebSocket 断连

**技术挑战**：
- JWT token 刷新导致 `jti` 变化
- `OAuth2AuthorizedClientService` 按 `userId` 覆盖
- HTTP Session 无法通过 `userId` 清除
- WebSocket 长连接管理

**解决方案**：
- 使用 `sid` 作为 `loginSessionId`（稳定不变）
- 引入 `SessionRegistry`（集中管理）
- 三层校验机制（签名 + 黑名单 + 状态）
- Kafka 事件通知（精确断开）

---

## 二、核心设计思想

> **本章目标**：理解核心设计思想，掌握如何通过设计解决第一章提出的技术挑战。

---

### 2.1 登录会话ID与访问令牌解耦

#### 2.1.1 为什么需要解耦

**问题**：如果使用 token 的 `jti` 作为会话标识，token 刷新时 `jti` 可能变化，导致无法关联到同一个会话。

**解决方案**：将登录会话 ID（`loginSessionId`）与访问令牌（token）解耦。

**设计原则**：
- ✅ Token 可以多次刷新、变化
- ✅ 登录会话 ID 必须在整个登录生命周期内保持稳定

#### 2.1.2 loginSessionId（sid）vs sessionId（jti）

**对比**：

| 特性 | loginSessionId（sid） | sessionId（jti） |
|------|----------------------|------------------|
| **作用域** | 整个登录会话 | 单个 token |
| **稳定性** | ✅ 稳定（登录生命周期内不变） | ⚠️ 不稳定（token刷新可能变化） |
| **来源** | Keycloak 的 `sid` claim | JWT 的 `jti` claim |
| **用途** | 会话管理、单点登录 | token 标识、向后兼容 |
| **推荐使用** | ✅ 是（核心标识） | ⚠️ 仅向后兼容 |

**关系图**：
```
LoginSession (loginSessionId: "sid-001") ← 稳定不变
  ├── Token 1 (jti: "jti-001") ← 可能变化
  ├── Token 2 (jti: "jti-002") ← 刷新后变化
  └── Token 3 (jti: "jti-003") ← 再次刷新后变化
```

#### 2.1.3 如何解耦

**实现方式**：

1. **提取 loginSessionId**：从 JWT 的 `sid` claim 中提取
2. **存储 loginSessionId**：在 `LoginSessionInfo` 中存储 `loginSessionId`
3. **索引设计**：同时按 `loginSessionId` 和 `sessionId`（jti）建立索引

**代码示例**：
```java
// 从 JWT 中提取 loginSessionId（sid）
String loginSessionId = extractLoginSessionId(jwt); // 从 sid claim 提取

// 构建 LoginSessionInfo
LoginSessionInfo sessionInfo = LoginSessionInfo.builder()
    .sessionId(jwt.getId())              // jti，向后兼容
    .loginSessionId(loginSessionId)      // sid，核心标识
    .userId(jwt.getSubject())
    .token(tokenValue)
    .status(SessionStatus.ACTIVE)
    .build();
```

**存储结构**：
```
Redis Key 1: session:login:token:{sessionId} → LoginSessionInfo
Redis Key 2: session:login:loginSession:{loginSessionId} → LoginSessionInfo
```

**优势**：
- ✅ 可以按 `loginSessionId` 查询（稳定）
- ✅ 可以按 `sessionId`（jti）查询（向后兼容）
- ✅ token 刷新时，`loginSessionId` 保持不变

---

### 2.2 以"用户+登录会话"为控制单元

#### 2.2.1 从 token 维度到 loginSession 维度

**旧方案（token 维度）**：
- 以单个 token 为控制单元
- 问题：token 刷新后无法关联到同一个会话
- 问题：无法实现单点登录

**新方案（loginSession 维度）**：
- 以 `loginSessionId` 为控制单元
- 优势：token 刷新时 `loginSessionId` 保持不变
- 优势：可以稳定地管理整个登录会话

**对比图**：
```
旧方案（token 维度）：
  Token 1 (jti: "jti-001") → 会话 1
  Token 2 (jti: "jti-002") → 会话 2 ← 无法关联到会话 1

新方案（loginSession 维度）：
  LoginSession (loginSessionId: "sid-001")
    ├── Token 1 (jti: "jti-001")
    └── Token 2 (jti: "jti-002") ← 属于同一个 loginSession
```

#### 2.2.2 会话状态管理（ACTIVE/KICKED/EXPIRED）

**设计原则**：
- 对同一个用户，只允许一个登录会话处于 `ACTIVE` 状态
- 新会话建立时，必须显式将旧会话标记为 `KICKED`
- 先标记为 `KICKED`，然后在 `blacklistKickedSessions()` 中删除会话记录

**状态转换**：
```
[新登录] → ACTIVE
    ↓
[用户在其他设备登录] → KICKED（旧会话）
    ↓
[用户主动登出] → EXPIRED
    ↓
[会话过期] → EXPIRED
```

**实现逻辑**：
```java
// 新登录时，标记旧会话为 KICKED
List<LoginSessionInfo> activeSessions = getActiveLoginSessions(userId);
for (LoginSessionInfo oldSession : activeSessions) {
    // 跳过同一 loginSessionId 的会话（token 刷新）
    if (newSession.getLoginSessionId().equals(oldSession.getLoginSessionId())) {
        continue;
    }
    // 标记为 KICKED
    updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
}
// 新会话状态为 ACTIVE
newSession.setStatus(SessionStatus.ACTIVE);
```

**优势**：
- ✅ 可以精确控制哪个会话是有效的
- ✅ 先标记 KICKED，再删除会话记录（日志中保留审计信息）
- ✅ 可以追踪会话历史

---

### 2.3 三层校验机制

#### 2.3.1 设计原则

**所有服务统一走"三层校验"**（按执行顺序）：
1. **黑名单校验**：立即失效已撤销的 token（最先执行，快速拒绝）
2. **Token 签名校验**：防止伪造（委托 Nimbus JWT 解码器验证）
3. **会话状态校验**：判断 loginSession 是否被踢（最后执行，查询 Redis）

#### 2.3.2 第一层：Token 签名校验（Spring Security）

**作用**：验证 token 是否由合法的授权服务器（Keycloak）签发。

**实现**：
- Spring Security 自动完成
- 使用 Nimbus JWT 库验证签名
- 验证 token 的签名、过期时间、颁发者等

**代码位置**：
```java
// JwtDecoderConfig.java
ReactiveJwtDecoder delegate = NimbusReactiveJwtDecoder
    .withIssuerLocation(issuerUri)
    .build();
```

**校验内容**：
- ✅ 签名是否有效
- ✅ token 是否过期
- ✅ 颁发者（issuer）是否正确
- ✅ 受众（audience）是否正确

#### 2.3.3 第二层：黑名单校验（立即失效）

**作用**：立即失效已撤销的 token（如登出、被踢下线）。

**实现**：
- 使用 Redis 存储黑名单
- Key 格式：`jwt:blacklist:{token}`
- TTL 自动过期（与 token 有效期一致）

**代码位置**：
```java
// JwtDecoderConfig.java
return jwtBlacklistService.isBlacklisted(token)
    .flatMap(blacklisted -> {
        if (Boolean.TRUE.equals(blacklisted)) {
            return Mono.error(new JwtException("Token has been revoked"));
        }
        // 继续后续校验
    });
```

**使用场景**：
- 用户主动登出
- 用户在其他设备登录（旧 token 被加入黑名单）
- 管理员强制下线

**优势**：
- ✅ 立即失效，无需等待 token 过期
- ✅ 支持 TTL 自动清理
- ✅ 性能高（Redis 查询）

#### 2.3.4 第三层：会话状态校验（核心）

**作用**：判断 loginSession 是否被踢下线（核心机制）。

**实现**：
1. 从 JWT 中提取 `loginSessionId`（sid）
2. 查询 `SessionRegistry`，获取会话信息
3. 检查会话状态是否为 `ACTIVE`

**代码位置**：
```java
// JwtDecoderConfig.java
private Mono<Void> checkSessionStatus(Jwt jwt, String token) {
    // 1. 提取 loginSessionId
    String loginSessionId = extractLoginSessionId(jwt);
    
    // 2. 查询 SessionRegistry
    LoginSessionInfo sessionInfo = sessionRegistry
        .getLoginSessionByLoginSessionId(loginSessionId);
    
    // 3. 检查状态
    if (sessionInfo == null || sessionInfo.getStatus() != SessionStatus.ACTIVE) {
        return Mono.error(new JwtException("Session is not active"));
    }
    
    return Mono.empty();
}
```

**校验逻辑**：
```
1. 提取 loginSessionId（sid）
   ↓
2. 查询 SessionRegistry
   ↓
3. 检查状态
   - 不存在 → 拒绝（向后兼容：可能跳过）
   - ACTIVE → 通过
   - KICKED → 拒绝
   - EXPIRED → 拒绝
```

**优势**：
- ✅ 可以精确控制哪个会话是有效的
- ✅ 可以实现单点登录（后连踢前）
- ✅ 可以保留审计记录

#### 2.3.5 三层校验流程图

```
客户端请求
  ↓
[第一层] Token 签名校验
  ├── 签名无效 → 401 Unauthorized
  ├── token 过期 → 401 Unauthorized
  └── 通过 → 继续
  ↓
[第二层] 黑名单校验
  ├── 在黑名单中 → 401 Unauthorized
  └── 通过 → 继续
  ↓
[第三层] 会话状态校验
  ├── 状态非 ACTIVE → 401 Unauthorized
  └── 通过 → 允许访问
```

**关键点**：
- ✅ 三层校验缺一不可
- ✅ 顺序很重要（先签名，再黑名单，最后状态）
- ✅ 任何一层失败都会拒绝访问

---

### 2.4 设计思想总结

**核心设计原则**：

1. **登录会话ID与访问令牌解耦**
   - Token 可以变化，`loginSessionId` 必须稳定
   - 使用 `sid` 作为 `loginSessionId`

2. **以"用户+登录会话"为控制单元**
   - 从 token 维度到 loginSession 维度
   - 会话状态管理（ACTIVE/KICKED/EXPIRED）

3. **三层校验机制**
   - Token 签名校验（防止伪造）
   - 黑名单校验（立即失效）
   - 会话状态校验（核心机制）

**设计优势**：

- ✅ **稳定性**：`loginSessionId` 稳定不变，不受 token 刷新影响
- ✅ **精确性**：可以精确控制哪个会话是有效的
- ✅ **安全性**：三层校验确保安全性
- ✅ **可追溯性**：删除前标记 KICKED，日志中保留审计信息

**解决的技术挑战**：

1. ✅ JWT token 刷新导致 `jti` 变化 → 使用 `sid` 作为 `loginSessionId`
2. ✅ `OAuth2AuthorizedClientService` 按 `userId` 覆盖 → 引入 `SessionRegistry` 管理会话状态
3. ✅ HTTP Session 无法通过 `userId` 清除 → 通过会话状态校验拒绝访问
4. ✅ WebSocket 长连接管理 → 通过 Kafka 事件通知精确断开

---

### 2.5 本章总结

**核心设计思想**：
1. **解耦**：登录会话ID与访问令牌解耦
2. **控制单元**：以"用户+登录会话"为控制单元
3. **三层校验**：签名 + 黑名单 + 状态

**设计优势**：
- 稳定性、精确性、安全性、可追溯性

**解决的问题**：
- 所有第一章提出的技术挑战

---



## 三、关键概念定义

> **本章目标**：建立统一的概念体系，理解系统中涉及的所有核心概念及其关系。这是理解后续所有章节的基础。

---

### 3.1 用户（User）

#### 3.1.1 定义

**用户（User）** 是系统中的真实用户实体，是认证和授权的主体。

#### 3.1.2 用户标识：userId

- **来源**：来自 Keycloak JWT 的 `sub`（subject）claim
- **格式**：通常是 UUID 字符串，例如 `"123e4567-e89b-12d3-a456-426614174000"`
- **唯一性**：在整个系统中唯一标识一个用户
- **稳定性**：用户 ID 在用户生命周期内保持不变

**代码示例**：
```java
// 从 JWT 中提取 userId
Jwt jwt = ...; // 从 Spring Security 获取
String userId = jwt.getSubject(); // 获取 sub claim
```

#### 3.1.3 用户与登录会话的关系

**重要关系**：
- **一对多关系**：一个用户可以有多个登录会话（不同设备、不同浏览器）
- **会话策略**：同一时刻只允许一个登录会话处于 `ACTIVE` 状态
- **会话管理**：通过 `userId` 可以查询该用户的所有登录会话

**关系图**：
```
User (userId: "user-123")
  ├── LoginSession 1 (loginSessionId: "sid-001", status: KICKED)
  ├── LoginSession 2 (loginSessionId: "sid-002", status: ACTIVE) ← 当前有效
  └── LoginSession 3 (loginSessionId: "sid-003", status: EXPIRED)
```

---

### 3.2 登录会话（LoginSession）

#### 3.2.1 定义

**登录会话（LoginSession）** 是用户一次登录的完整生命周期，从登录成功开始，到登出或过期结束。

#### 3.2.2 核心标识符

##### 3.2.2.1 loginSessionId（登录会话ID）

**定义**：整个登录生命周期内稳定不变的标识符。

**来源**：
- **推荐**：Keycloak 的 `sid`（Session ID）claim
- **备选**：Keycloak 的 `session_state` claim（向后兼容）

**特性**：
- ✅ **稳定性**：在一次登录内稳定不变
- ✅ **唯一性**：每次登录都会生成新的 `loginSessionId`
- ✅ **持久性**：token 刷新时 `loginSessionId` 保持不变
- ✅ **可追踪性**：可以追踪整个登录会话的所有操作

**代码示例**：
```java
// 从 JWT 中提取 loginSessionId（优先使用 sid）
Object sidObj = jwt.getClaim("sid");
String loginSessionId = null;
if (sidObj != null) {
    String sid = sidObj.toString();
    if (sid != null && !sid.isBlank()) {
        loginSessionId = sid; // 使用 sid
    }
}
// 如果没有 sid，尝试使用 session_state（向后兼容）
if (loginSessionId == null) {
    Object sessionStateObj = jwt.getClaim("session_state");
    if (sessionStateObj != null) {
        loginSessionId = sessionStateObj.toString();
    }
}
```

##### 3.2.2.2 sessionId（会话ID）

**定义**：JWT token 的 `jti`（JWT ID）claim，用于标识单个 token。

**特性**：
- ⚠️ **不稳定性**：token 刷新时 `jti` 可能变化
- ⚠️ **token 级别**：每个 token 都有自己的 `jti`
- ✅ **向后兼容**：用于向后兼容旧系统

**代码示例**：
```java
// 从 JWT 中提取 sessionId（jti）
String sessionId = jwt.getId(); // 获取 jti claim
```

**对比表**：

| 特性 | loginSessionId（sid） | sessionId（jti） |
|------|----------------------|------------------|
| 稳定性 | ✅ 稳定（登录生命周期内不变） | ⚠️ 不稳定（token刷新可能变化） |
| 作用域 | 整个登录会话 | 单个 token |
| 用途 | 单点登录、会话管理 | token 标识、向后兼容 |
| 推荐使用 | ✅ 是 | ⚠️ 仅向后兼容 |

#### 3.2.3 会话状态：SessionStatus

**定义**：用于标识登录会话的当前状态。

**状态枚举**：

```java
public enum SessionStatus {
    /** 当前有效。会话处于活跃状态，用户可以正常使用。 */
    ACTIVE,
    
    /** 被后续登录踢下线。用户在其他设备/浏览器登录后，此会话被标记为 KICKED。 */
    KICKED,
    
    /** 正常超时或注销。会话已过期或被用户主动注销。 */
    EXPIRED
}
```

**状态转换图**：
```
[新登录] → ACTIVE
    ↓
[用户在其他设备登录] → KICKED
    ↓
[用户主动登出] → EXPIRED
    ↓
[会话过期] → EXPIRED
```

**状态说明**：

1. **ACTIVE（活跃）**
   - 会话当前有效，用户可以正常使用
   - 所有使用此会话的请求都应该被允许
   - 这是唯一允许访问资源的状态

2. **KICKED（被踢下线）**
   - 用户在其他设备/浏览器登录后，此会话被标记为 KICKED
   - 所有使用此会话的请求都应该被拒绝
   - 返回 401 或业务提示「账号已在其他设备登录」

3. **EXPIRED（已过期）**
   - 会话已过期或被用户主动注销
   - 所有使用此会话的请求都应该被拒绝
   - 返回 401 或业务提示「会话已过期」

#### 3.2.4 LoginSessionInfo 数据结构

**完整数据结构**：

```java
@Data
@Builder
public class LoginSessionInfo {
    /** 会话唯一标识（JWT 的 jti，向后兼容） */
    private String sessionId;
    
    /** 登录会话 ID（Keycloak 的 sid，核心标识） */
    private String loginSessionId;
    
    /** 会话状态（ACTIVE/KICKED/EXPIRED） */
    @Builder.Default
    private SessionStatus status = SessionStatus.ACTIVE;
    
    /** 原始 Token 值 */
    private String token;
    
    /** 关联的用户 ID */
    private String userId;
    
    /** 签发时间（毫秒时间戳） */
    private Long issuedAt;
    
    /** 过期时间（毫秒时间戳） */
    private Long expiresAt;
    
    /** 额外信息（IP、User-Agent、设备名等） */
    @Builder.Default
    private Map<String, String> attributes = new HashMap<>();
}
```

**数据示例**：
```json
{
  "sessionId": "jti-abc123",
  "loginSessionId": "sid-xyz789",
  "status": "ACTIVE",
  "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "userId": "user-123",
  "issuedAt": 1704067200000,
  "expiresAt": 1704070800000,
  "attributes": {
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0..."
  }
}
```

---

### 3.3 访问令牌（Token）

#### 3.3.1 定义

**访问令牌（Token）** 是 OAuth2/OIDC 协议中用于访问受保护资源的凭证。

#### 3.3.2 Token 类型

##### 3.3.2.1 access_token（访问令牌）

**定义**：用于访问受保护资源的令牌。

**特性**：
- **格式**：JWT（JSON Web Token）
- **有效期**：通常较短（如 5 分钟、15 分钟）
- **用途**：在 HTTP 请求的 `Authorization` header 中携带
- **包含信息**：用户 ID（sub）、会话 ID（sid）等
- **说明**：JWT 中可能包含 roles 等 claim，但本文档不涉及角色权限控制，仅关注认证和会话管理

**使用示例**：
```http
GET /api/users/me HTTP/1.1
Host: example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

##### 3.3.2.2 refresh_token（刷新令牌）

**定义**：用于刷新 `access_token` 的令牌。

**特性**：
- **格式**：通常是不透明的字符串（不是 JWT）
- **有效期**：通常较长（如 30 天、90 天）
- **用途**：在 `access_token` 过期时，用于获取新的 `access_token`
- **安全性**：需要妥善保管，泄露风险较高

**刷新流程**：
```
1. access_token 过期
2. 使用 refresh_token 调用刷新接口
3. 获取新的 access_token 和 refresh_token
4. 新 token 的 loginSessionId 保持不变（sid 不变）
```

#### 3.3.3 Token 与 LoginSession 的关系

**重要关系**：
- **多对一关系**：多个 token 可以属于同一个 `loginSessionId`
- **token 刷新**：刷新后的新 token 仍然属于同一个 `loginSessionId`
- **新登录**：新登录会产生新的 `loginSessionId`，不与旧登录共享

**关系图**：
```
LoginSession (loginSessionId: "sid-001")
  ├── Token 1 (jti: "jti-001", 已过期)
  ├── Token 2 (jti: "jti-002", 当前有效) ← Token 1 刷新后生成
  └── Token 3 (jti: "jti-003", 未来刷新) ← Token 2 刷新后生成

新登录：
LoginSession (loginSessionId: "sid-002") ← 新的 loginSessionId
  └── Token 4 (jti: "jti-004", 当前有效)
```

**关键点**：
- ✅ `loginSessionId` 在 token 刷新时保持不变
- ⚠️ `jti` 在 token 刷新时可能变化
- ✅ 新登录会产生新的 `loginSessionId`

---

### 3.4 WebSocket 会话

#### 3.4.1 定义

**WebSocket 会话（WebSocket Session）** 是客户端与服务器之间的长连接会话，用于实时双向通信。

#### 3.4.2 WebSocket sessionId

**定义**：WebSocket 连接的唯一标识符。

**来源**：
- Spring WebSocket：STOMP session ID
- SockJS：连接 ID
- 原生 WebSocket：连接 ID

**特性**：
- **唯一性**：每个 WebSocket 连接都有唯一的 `sessionId`
- **生命周期**：连接建立时创建，连接断开时销毁
- **作用域**：单个 WebSocket 连接

#### 3.4.3 WebSocket 会话与 LoginSession 的关联

**关联方式**：通过 `loginSessionId` 关联。

**关系图**：
```
LoginSession (loginSessionId: "sid-001", userId: "user-123")
  ├── WebSocket Session 1 (sessionId: "ws-001", service: "game-service")
  └── WebSocket Session 2 (sessionId: "ws-002", service: "chat-service")

新登录后：
LoginSession (loginSessionId: "sid-002", userId: "user-123")
  └── WebSocket Session 3 (sessionId: "ws-003", service: "game-service")

旧会话的 WebSocket 连接会被断开（基于 loginSessionId 查询）
```

**WebSocketSessionInfo 数据结构**：

```java
@Data
@Builder
public class WebSocketSessionInfo {
    /** WebSocket 会话 ID */
    private String sessionId;
    
    /** 关联的登录会话 ID（loginSessionId） */
    private String loginSessionId;
    
    /** 关联的用户 ID */
    private String userId;
    
    /** 产生该连接的服务名 */
    private String service;
    
    /** 连接建立时间 */
    private Long connectedAt;
    
    /** 额外信息 */
    @Builder.Default
    private Map<String, String> attributes = new HashMap<>();
}
```

**关联的作用**：
- ✅ **单点登录**：新登录时，可以基于 `loginSessionId` 查询并断开旧连接的 WebSocket
- ✅ **精确断开**：登出时，可以精确断开该 `loginSessionId` 的所有 WebSocket 连接
- ✅ **会话管理**：可以查询某个 `loginSessionId` 的所有 WebSocket 连接

---

### 3.5 概念关系总结

**完整关系图**：
```
User (userId: "user-123")
  │
  ├── LoginSession 1 (loginSessionId: "sid-001", status: KICKED)
  │   ├── Token 1 (jti: "jti-001", 已过期)
  │   ├── Token 2 (jti: "jti-002", 已过期)
  │   └── WebSocket Session 1 (sessionId: "ws-001", 已断开)
  │
  └── LoginSession 2 (loginSessionId: "sid-002", status: ACTIVE) ← 当前有效
      ├── Token 3 (jti: "jti-003", 当前有效)
      ├── WebSocket Session 2 (sessionId: "ws-002", 活跃)
      └── WebSocket Session 3 (sessionId: "ws-003", 活跃)
```

**关键关系总结**：

1. **User → LoginSession**：一对多，一个用户可以有多个登录会话
2. **LoginSession → Token**：一对多，一个登录会话可以有多个 token（token 刷新）
3. **LoginSession → WebSocket Session**：一对多，一个登录会话可以有多个 WebSocket 连接
4. **loginSessionId**：是关联所有资源的核心标识符

---

### 3.6 术语对照表

| 术语 | 英文 | 说明 | 代码中的字段名 |
|------|------|------|---------------|
| 用户ID | userId | Keycloak JWT 的 sub | `userId` |
| 登录会话ID | loginSessionId | Keycloak 的 sid | `loginSessionId` |
| 会话ID | sessionId | JWT 的 jti | `sessionId` |
| 访问令牌 | access_token | OAuth2 访问令牌 | `token` |
| 刷新令牌 | refresh_token | OAuth2 刷新令牌 | `refreshToken` |
| WebSocket会话ID | WebSocket sessionId | WebSocket 连接 ID | `sessionId`（WebSocketSessionInfo） |
| 会话状态 | SessionStatus | ACTIVE/KICKED/EXPIRED | `status` |

---

### 3.7 本章总结

**核心概念**：
1. **User（用户）**：系统中的真实用户，通过 `userId` 标识
2. **LoginSession（登录会话）**：用户一次登录的完整生命周期，通过 `loginSessionId` 标识
3. **Token（令牌）**：访问资源的凭证，多个 token 可以属于同一个 `loginSessionId`
4. **WebSocket Session（WebSocket 会话）**：长连接会话，通过 `loginSessionId` 关联到登录会话

**关键要点**：
- ✅ `loginSessionId`（sid）是核心标识符，稳定不变
- ✅ `sessionId`（jti）用于向后兼容，但不稳定
- ✅ 会话状态（ACTIVE/KICKED/EXPIRED）用于控制访问授权（是否允许访问）
- ✅ 所有资源（Token、WebSocket）都通过 `loginSessionId` 关联



---

## 四、登录流程完整实现

> **本章目标**：理解完整的登录流程，掌握从用户登录到会话注册、单点登录处理的每个步骤和代码实现细节。

---

### 4.1 登录流程概述

#### 4.1.1 OAuth2 登录流程（前后端交互）

**完整流程**：
1. **前端触发登录**：用户访问需要认证的页面，或前端调用 `initAndLogin()`
   - 前端跳转到 `/oauth2/authorization/keycloak`
2. **Gateway处理**：Spring Security OAuth2 Client Filter 拦截请求
   - 构建授权URL，重定向到 Keycloak
3. **Keycloak登录**：用户在 Keycloak 登录页面输入用户名密码
   - Keycloak 验证用户凭证
4. **Keycloak回调**：Keycloak 生成授权码，重定向回 Gateway
   - 回调URL: `/login/oauth2/code/keycloak?code=xxx&state=xxx`
5. **Gateway换取token**：Gateway 使用授权码换取 access_token
   - 调用 Keycloak Token 端点
   - Spring Security 创建 Authentication
6. **Gateway处理登录成功**：执行自定义登录成功处理器
   - 单点登录处理（踢旧连接）
   - 存储 loginSessionId 到 HTTP Session
7. **Gateway重定向**：重定向回前端（原始地址或首页）
8. **前端获取token**：前端调用 `GET /token`（带cookie）
   - Gateway 从 Session 中获取 token，返回给前端
   - 前端保存 token 到 localStorage
9. **前端加载用户信息**：前端调用 `getUserInfo()`
   - 调用 `/system-service/api/users/me` 或 `/game-service/me`

#### 4.1.2 登录成功后的处理

**自定义处理逻辑**（`LoginSessionKickHandler`）：
1. 提取 JWT 信息（userId、sessionId、loginSessionId）
2. 构建 `LoginSessionInfo`
3. 调用 `SessionRegistry.registerLoginSessionEnforceSingle()`（单点登录核心）
4. 将被踢掉的旧会话从 SessionRegistry 中删除，并将 token 加入黑名单
5. 发布 SESSION_KICKED 事件（通知各服务断开 WebSocket）
6. 存储 `loginSessionId` 到 HTTP Session

---

### 4.2 代码调用链路（登录）

#### 4.2.1 完整调用链路

```
用户访问 /oauth2/authorization/keycloak
  ↓
Spring Security OAuth2 Client Filter
  ↓
构建授权 URL，重定向到 Keycloak
  ↓
用户在 Keycloak 登录页面输入用户名密码
  ↓
Keycloak 验证用户凭证
  ↓
Keycloak 生成授权码，重定向回 Gateway
  ↓
回调 URL: /login/oauth2/code/keycloak?code=xxx&state=xxx
  ↓
Spring Security OAuth2 Client Filter 处理回调
  ↓
使用授权码换取 access_token（调用 Keycloak Token 端点）
  ↓
Keycloak 返回 access_token 和 refresh_token
  ↓
Spring Security 保存 OAuth2AuthorizedClient 到 Session
  ↓
Spring Security 创建 Authentication 对象
  ↓
调用 LoginSessionKickHandler.onAuthenticationSuccess()
  ↓
  ├─ 1. 获取 OAuth2AuthorizedClient
  │     authorizedClientManager.authorize()
  │
  ├─ 2. 提取 JWT 信息
  │     extractJwtInfo(tokenValue)
  │     ├─ userId (sub)
  │     ├─ sessionId (jti)
  │     ├─ loginSessionId (sid)
  │     ├─ expiresAt
  │     └─ issuedAt
  │
  ├─ 3. 构建 LoginSessionInfo
  │     LoginSessionInfo.builder()
  │     ├─ sessionId
  │     ├─ loginSessionId
  │     ├─ userId
  │     ├─ token
  │     ├─ status = ACTIVE
  │     └─ attributes (IP, User-Agent)
  │
  ├─ 4. 调用 registerLoginSessionEnforceSingle()
  │     SessionRegistry.registerLoginSessionEnforceSingle()
  │     ├─ 查询该用户的所有 ACTIVE 会话
  │     ├─ 将旧会话标记为 KICKED
  │     └─ 返回被踢掉的旧会话列表
  │
  ├─ 5. 删除旧会话并将 token 加入黑名单
  │     blacklistKickedSessions()
  │     ├─ 从 SessionRegistry 删除旧会话
  │     └─ 将旧 token 加入黑名单
  │     └─ JwtBlacklistService.addToBlacklist()
  │
  ├─ 6. 发布 SESSION_KICKED 事件
  │     publishKickedEvent()
  │     └─ SessionEventPublisher.publishSessionInvalidated()
  │
  └─ 7. 存储 loginSessionId 到 HTTP Session
        storeLoginSessionIdInSession()
        └─ WebSession.getAttributes().put("LOGIN_SESSION_ID", loginSessionId)
  ↓
调用默认成功处理器（重定向到首页）
  ↓
登录完成
```

#### 4.2.2 关键节点说明

**节点1：OAuth2 授权码流程**
- Spring Security 自动处理
- 无需手动实现

**节点2：登录成功处理器**
- 自定义 `LoginSessionKickHandler`
- 实现 `ServerAuthenticationSuccessHandler` 接口

**节点3：单点登录核心**
- `registerLoginSessionEnforceSingle()` 方法
- 标记旧会话为 KICKED

**节点4：黑名单处理**
- 立即失效旧 token
- 防止旧设备继续使用

**节点5：事件通知**
- Kafka 事件通知各服务
- 断开旧设备的 WebSocket 连接

---

### 4.3 关键代码解析

#### 4.3.1 LoginSessionKickHandler 类结构

**文件位置**：`apps/gateway/src/main/java/com/gamehub/gateway/handler/LoginSessionKickHandler.java`

**类定义**：
```java
@Slf4j
@Component
public class LoginSessionKickHandler implements ServerAuthenticationSuccessHandler {
    private static final String REGISTRATION_ID = "keycloak";
    private static final String SESSION_LOGIN_SESSION_ID_KEY = "LOGIN_SESSION_ID";
    
    private final ReactiveOAuth2AuthorizedClientManager authorizedClientManager;
    private final SessionRegistry sessionRegistry;
    private final JwtBlacklistService blacklistService;
    private final ServerAuthenticationSuccessHandler defaultSuccessHandler;
    private final SessionEventPublisher sessionEventPublisher;
}
```

**关键依赖**：
- `ReactiveOAuth2AuthorizedClientManager`：获取 OAuth2 授权客户端
- `SessionRegistry`：会话注册表，管理登录会话
- `JwtBlacklistService`：JWT 黑名单服务
- `SessionEventPublisher`：会话事件发布器（Kafka）

#### 4.3.2 onAuthenticationSuccess 方法

**方法签名**：
```java
@Override
public Mono<Void> onAuthenticationSuccess(WebFilterExchange exchange, Authentication authentication)
```

**完整实现流程**：

**步骤1：获取 OAuth2AuthorizedClient**

```java
OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest
        .withClientRegistrationId(REGISTRATION_ID)
        .principal(authentication)
        .build();

return authorizedClientManager.authorize(authorizeRequest)
        .flatMap(authorizedClient -> {
            // authorizedClient 包含 access_token 和 refresh_token
        });
```

**说明**：
- `authorizedClientManager.authorize()` 会从 Session 中获取已保存的 `OAuth2AuthorizedClient`
- 如果 token 已过期，会自动使用 `refresh_token` 刷新

**步骤2：提取 JWT 信息**
```java
OAuth2AccessToken accessToken = authorizedClient.getAccessToken();
String tokenValue = accessToken.getTokenValue();

return extractJwtInfo(tokenValue)
        .flatMap(jwtInfo -> {
            String userId = (String) jwtInfo.get("userId");
            String sessionId = (String) jwtInfo.get("sessionId"); // jti
            String loginSessionId = (String) jwtInfo.get("loginSessionId"); // sid
            Instant expiresAt = (Instant) jwtInfo.get("expiresAt");
            Instant issuedAt = (Instant) jwtInfo.get("issuedAt");
        });
```

**说明**：
- 需要手动解析 JWT（此时 Spring Security 还未解析）
- 提取关键信息：userId、sessionId、loginSessionId

**步骤3：构建 LoginSessionInfo**
```java
LoginSessionInfo newSession = LoginSessionInfo.builder()
        .sessionId(sessionId)                    // jti，向后兼容
        .loginSessionId(loginSessionId)          // sid，核心标识
        .userId(userId)                          // sub
        .token(tokenValue)                       // access_token
        .status(SessionStatus.ACTIVE)            // 新会话状态为 ACTIVE
        .issuedAt(issuedAt != null ? issuedAt.toEpochMilli() : Instant.now().toEpochMilli())
        .expiresAt(expiresAt != null ? expiresAt.toEpochMilli() : null)
        .attributes(buildAttributes(exchange.getExchange())) // IP、User-Agent
        .build();
```

**说明**：
- 新会话状态自动设置为 `ACTIVE`
- 包含 IP、User-Agent 等属性（用于审计）

**步骤4：计算 TTL 并调用单点登录注册**

```java
// 计算 TTL（秒）
// 登录会话（sid）的生命周期应该与 refresh_token 一致
// - 登录时创建，登出时删除
// - 如果 refresh_token 过期，用户无法刷新 token，登录会话也应该失效
// - 使用 refresh_token 的过期时间作为 TTL，而不是 access_token 的过期时间
long ttlSeconds = 0; // 默认使用默认 TTL（12小时）
if (refreshToken != null && refreshToken.getExpiresAt() != null) {
    Instant refreshExpiresAt = refreshToken.getExpiresAt();
    ttlSeconds = Duration.between(Instant.now(), refreshExpiresAt).getSeconds();
    ttlSeconds = Math.max(ttlSeconds, 0);
    log.debug("使用 refresh_token 过期时间计算 TTL: refreshExpiresAt={}, ttlSeconds={}", 
            refreshExpiresAt, ttlSeconds);
} else {
    log.debug("refresh_token 不存在或没有过期时间，使用默认 TTL（12小时）");
}

// 调用 registerLoginSessionEnforceSingle（会标记旧会话为 KICKED）
List<LoginSessionInfo> kickedSessions = sessionRegistry.registerLoginSessionEnforceSingle(newSession, ttlSeconds);

log.info("【单点登录】新登录会话已注册: userId={}, sessionId={}, loginSessionId={}, 踢掉旧会话数={}", 
        userId, sessionId, loginSessionId, kickedSessions.size());
```

**说明**：
- `registerLoginSessionEnforceSingle()` 会：
  1. 查询该用户的所有 ACTIVE 会话
  2. 将旧会话标记为 KICKED（跳过同一 loginSessionId 的会话）
  3. 注册新会话（状态为 ACTIVE）
  4. 返回被踢掉的旧会话列表
- **注意**：标记为 KICKED 后，会在 `blacklistKickedSessions()` 方法中从 SessionRegistry 删除旧会话记录

**步骤5-7：后续处理（并行执行）**
```java
return storeLoginSessionIdInSession(exchange.getExchange(), loginSessionId)
        .then(blacklistKickedSessions(kickedSessions))
        .then(publishKickedEvent(userId, loginSessionId, kickedSessions))
        .then(defaultSuccessHandler.onAuthenticationSuccess(exchange, authentication));
```

**说明**：
- 使用 `then()` 链式调用，顺序执行
- 最后调用默认成功处理器（重定向到首页）

#### 4.3.3 extractJwtInfo 方法

**方法签名**：

```java
private Mono<Map<String, Object>> extractJwtInfo(String tokenValue)
```

**实现逻辑**：
```java
return Mono.fromCallable(() -> {
    Map<String, Object> result = new HashMap<>();
    
    // 手动解析 JWT（Base64 解码 payload）
    String[] parts = tokenValue.split("\\.");
    if (parts.length < 2) {
        throw new IllegalArgumentException("Invalid JWT format");
    }
    
    // 解码 payload（Base64URL）
    String payload = new String(java.util.Base64.getUrlDecoder().decode(parts[1]));
    com.alibaba.fastjson2.JSONObject json = com.alibaba.fastjson2.JSON.parseObject(payload);
    
    // 提取所需信息
    result.put("userId", json.getString("sub"));
    result.put("sessionId", json.getString("jti"));
    result.put("loginSessionId", extractSid(json)); // 从 sid claim 提取
    
    // 提取时间信息
    Long exp = json.getLong("exp");
    Long iat = json.getLong("iat");
    result.put("expiresAt", exp != null ? Instant.ofEpochSecond(exp) : null);
    result.put("issuedAt", iat != null ? Instant.ofEpochSecond(iat) : null);
    
    return result;
});
```

**关键点**：
- ⚠️ **不验证签名**：只提取 claim，签名验证由 Spring Security 负责
- ✅ **Base64URL 解码**：JWT 使用 Base64URL 编码
- ✅ **提取关键信息**：userId、sessionId、loginSessionId、时间信息

#### 4.3.4 extractSid 方法

**方法签名**：
```java
private String extractSid(com.alibaba.fastjson2.JSONObject json)
```

**实现逻辑**：
```java
// 优先使用 sid
String sid = json.getString("sid");
if (sid != null && !sid.isBlank()) {
    return sid;
}

// 如果没有 sid，尝试使用 session_state（向后兼容）
String sessionState = json.getString("session_state");
if (sessionState != null && !sessionState.isBlank()) {
    return sessionState;
}

return null;
```

**关键点**：
- ✅ **优先使用 sid**：Keycloak 原生会话 ID
- ✅ **向后兼容**：如果没有 sid，使用 session_state
- ✅ **返回 null**：如果都没有，返回 null（向后兼容）

#### 4.3.5 blacklistKickedSessions 方法

**方法签名**：
```java
private Mono<Void> blacklistKickedSessions(List<LoginSessionInfo> kickedSessions)
```

**实现逻辑**：
```java
if (kickedSessions.isEmpty()) {
    return Mono.empty();
}

return Mono.fromRunnable(() -> {
    for (LoginSessionInfo kickedSession : kickedSessions) {
        // 1. 从 SessionRegistry 中删除旧会话
        try {
            sessionRegistry.unregisterLoginSession(kickedSession.getSessionId());
            log.debug("已从 SessionRegistry 删除旧会话: sessionId={}, loginSessionId={}", 
                    kickedSession.getSessionId(), kickedSession.getLoginSessionId());
        } catch (Exception e) {
            log.warn("从 SessionRegistry 删除旧会话失败: sessionId={}", kickedSession.getSessionId(), e);
        }
        
        // 2. 将旧 token 加入黑名单
        if (kickedSession.getToken() != null && !kickedSession.getToken().isBlank()) {
            // 计算剩余 TTL
            long ttlSeconds = 0;
            if (kickedSession.getExpiresAt() != null && kickedSession.getExpiresAt() > 0) {
                ttlSeconds = (kickedSession.getExpiresAt() - Instant.now().toEpochMilli()) / 1000;
                ttlSeconds = Math.max(ttlSeconds, 0);
            }
            
            // 加入黑名单
            blacklistService.addToBlacklist(kickedSession.getToken(), ttlSeconds)
                    .subscribe(
                            null,
                            error -> log.warn("将旧会话 token 加入黑名单失败: sessionId={}", 
                                    kickedSession.getSessionId(), error)
                    );
            
            log.debug("已将旧会话 token 加入黑名单: sessionId={}, loginSessionId={}", 
                    kickedSession.getSessionId(), kickedSession.getLoginSessionId());
        }
    }
});
```

**关键点**：
- ✅ **删除旧会话**：调用 `unregisterLoginSession()` 从 SessionRegistry 中删除旧会话记录
- ✅ **计算 TTL**：使用 token 剩余有效期作为黑名单 TTL
- ✅ **异步处理**：使用 `subscribe()` 异步执行，不阻塞主流程
- ✅ **错误处理**：记录警告日志，不抛出异常

#### 4.3.6 publishKickedEvent 方法

**方法签名**：
```java
private Mono<Void> publishKickedEvent(String userId, String loginSessionId, List<LoginSessionInfo> kickedSessions)
```

**实现逻辑**：
```java
if (sessionEventPublisher == null || kickedSessions.isEmpty()) {
    return Mono.empty();
}

return Mono.fromRunnable(() -> {
    try {
        // 发布事件：通知各服务断开被踢掉的会话的 WebSocket 连接
        for (LoginSessionInfo kickedSession : kickedSessions) {
            String kickedLoginSessionId = kickedSession.getLoginSessionId();
            if (kickedLoginSessionId != null && !kickedLoginSessionId.isBlank()) {
                SessionInvalidatedEvent event = SessionInvalidatedEvent.of(
                        userId,
                        kickedLoginSessionId,
                        SessionInvalidatedEvent.EventType.FORCE_LOGOUT,
                        "单点登录：被新登录踢下线"
                );
                sessionEventPublisher.publishSessionInvalidated(event);
            }
        }
    } catch (Exception e) {
        log.error("发布 SESSION_KICKED 事件失败", e);
        // 不抛出异常，避免影响登录流程
    }
});
```

**关键点**：
- ✅ **发布被踢掉的会话事件**：每个被踢掉的会话都发布一个事件
- ✅ **包含 loginSessionId**：事件包含被踢掉的会话的 `loginSessionId`
- ✅ **同步注销 Keycloak SSO 会话**：调用 `keycloakSsoLogoutService.logout()` 注销 Keycloak 端的会话
- ✅ **错误处理**：记录错误日志，不抛出异常

**完整实现**（包含 Keycloak SSO 注销）：
```java
for (LoginSessionInfo kickedSession : kickedSessions) {
    String kickedLoginSessionId = kickedSession.getLoginSessionId();
    if (kickedLoginSessionId == null || kickedLoginSessionId.isBlank()) {
        continue;
    }
    try {
        // 1. 发布 Kafka 事件
        if (sessionEventPublisher != null) {
            SessionInvalidatedEvent event = SessionInvalidatedEvent.of(
                    userId,
                    kickedLoginSessionId,
                    SessionInvalidatedEvent.EventType.FORCE_LOGOUT,
                    "单点登录：被新登录踢下线"
            );
            sessionEventPublisher.publishSessionInvalidated(event);
        }
    } catch (Exception e) {
        log.error("发布 SESSION_KICKED 事件失败", e);
    } finally {
        // 2. 同步注销 Keycloak SSO 会话
        try {
            keycloakSsoLogoutService.logout(userId, kickedLoginSessionId);
        } catch (Exception ex) {
            log.error("注销 Keycloak SSO 会话失败", ex);
        }
    }
}
```

#### 4.3.7 storeLoginSessionIdInSession 方法

**方法签名**：
```java
private Mono<Void> storeLoginSessionIdInSession(ServerWebExchange exchange, String loginSessionId)
```

**实现逻辑**：
```java
if (loginSessionId == null || loginSessionId.isBlank()) {
    return Mono.empty();
}

return exchange.getSession()
        .doOnNext((WebSession session) -> {
            session.getAttributes().put(SESSION_LOGIN_SESSION_ID_KEY, loginSessionId);
            log.debug("已将 loginSessionId 存储到 HTTP Session: loginSessionId={}, sessionId={}", 
                    loginSessionId, session.getId());
        })
        .then();
```

**关键点**：
- ✅ **存储到 HTTP Session**：用于后续在 `TokenController` 中验证
- ✅ **防止 token 被覆盖**：验证返回的 token 是否属于当前 Session

#### 4.3.8 handleAuthenticationFailure：401/403 响应策略

`handleAuthenticationFailure()` 是 Gateway 中 401/403 的统一入口，最新逻辑包括：

- **清理会话 + 写黑名单**：与主动登出一致，失效当前 `WebSession`、移除 `OAuth2AuthorizedClient` 并将 token 加入黑名单；
- **按请求类型返回**：
  - 如果是普通 HTML 请求，返回 303，`Location` 指向 `/oauth2/authorization/keycloak`，同时在响应头写入 `X-Auth-Redirect-To`；
  - 如果是 AJAX/Fetch 请求，返回 401 JSON（`{\"code\":\"AUTH_EXPIRED\",...}`），同样带上 `X-Auth-Redirect-To`。
- **前端配合**：`auth.js` 中的 `handleAuthExpiredResponse()`/`showAuthModal()` 会根据响应头弹出“登录状态失效”模态，引导用户点击“重新登录”（内部清除本地 token 并跳转 Keycloak）。

> ✅ 这样无论是刷新页面还是在按钮里发 AJAX 请求，只会出现一个统一的弹窗，不再依赖浏览器 `alert`。

#### 4.3.9 KeycloakSsoLogoutService：后台同步注销

仅仅清理 Gateway 本地状态还不够，被踢的浏览器可能仍然保留 Keycloak 的 SSO 会话，导致“静默登录”。为了解决这个问题：

- Gateway 新增 `KeycloakAdminProperties` / `KeycloakAdminConfig`，根据 `keycloak.admin.*` 配置创建一个 Keycloak Admin Client（默认使用 `admin-cli` + 管理员账号）。
- 新的 `KeycloakSsoLogoutService.logout(userId, loginSessionId)` 会优先调用 Keycloak Admin API 的 `deleteSession(loginSessionId, false)` 精确注销对应的在线 SSO，会话 ID 缺失时再回退到 `users().get(userId).logout()`（全量清掉该用户的会话）。
- 触发位置：
  1. `SecurityConfig.publishSessionInvalidatedEvent()`：用户主动登出；
  2. `SecurityConfig.publishSessionInvalidatedEvent(Jwt, ...)`：401/403、token 失效场景；
  3. `LoginSessionKickHandler.publishKickedEvent()`：单点登录“后连踢前”。

> ✅ 这样一来，被踢或超时的浏览器再次访问 `/oauth2/authorization/keycloak` 就一定会看到 Keycloak 登录页，不可能再静默刷新。

---

### 4.4 数据流转

#### 4.4.1 Redis 存储结构

**登录会话存储**：

```
Key 1: session:login:token:{sessionId}
Value: LoginSessionInfo JSON
TTL: token 剩余有效期

Key 2: session:login:loginSession:{loginSessionId}
Value: LoginSessionInfo JSON
TTL: token 剩余有效期

Key 3: session:login:user:{userId}
Type: Set
Members: [sessionId1, sessionId2, ...]
TTL: 与 Key 1 一致
```

**示例**：
```
session:login:token:jti-abc123 → {
  "sessionId": "jti-abc123",
  "loginSessionId": "sid-xyz789",
  "userId": "user-123",
  "status": "ACTIVE",
  ...
}

session:login:loginSession:sid-xyz789 → {
  "sessionId": "jti-abc123",
  "loginSessionId": "sid-xyz789",
  "userId": "user-123",
  "status": "ACTIVE",
  ...
}

session:login:user:user-123 → Set["jti-abc123"]
```

#### 4.4.2 SessionRegistry 数据结构

**内存中的数据结构**：
- `LoginSessionInfo` 对象
- 存储在 Redis 中，通过 key 查询

**查询方式**：
1. 按 `sessionId`（jti）查询：`session:login:token:{sessionId}`
2. 按 `loginSessionId`（sid）查询：`session:login:loginSession:{loginSessionId}`
3. 按 `userId` 查询：`session:login:user:{userId}` → 获取所有 sessionId → 逐个查询

#### 4.4.3 HTTP Session 存储

**存储内容**：
```
WebSession.getAttributes()
  └── "LOGIN_SESSION_ID" → "sid-xyz789"
```

**用途**：
- 在 `TokenController.getToken()` 中验证
- 确保返回的 token 属于当前 Session

---

### 4.5 单点登录核心逻辑

#### 4.5.1 registerLoginSessionEnforceSingle 方法

**方法位置**：`libs/session-common/src/main/java/com/gamehub/session/SessionRegistry.java`

**实现逻辑**：
```java
public List<LoginSessionInfo> registerLoginSessionEnforceSingle(LoginSessionInfo sessionInfo, long ttlSeconds) {
    // 1) 获取该用户的所有 ACTIVE 会话
    List<LoginSessionInfo> activeSessions = getActiveLoginSessions(sessionInfo.getUserId());
    
    // 2) 将旧会话标记为 KICKED（后续会在 blacklistKickedSessions() 中删除）
    List<LoginSessionInfo> kicked = new ArrayList<>();
    for (LoginSessionInfo oldSession : activeSessions) {
        // 跳过自己（如果新会话的 loginSessionId 与旧会话相同，说明是同一登录会话的 token 刷新）
        if (sessionInfo.getLoginSessionId() != null 
                && sessionInfo.getLoginSessionId().equals(oldSession.getLoginSessionId())) {
            continue; // 跳过，不踢掉
        }
        
        // 更新状态为 KICKED
        updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
        oldSession.setStatus(SessionStatus.KICKED);
        kicked.add(oldSession);
    }
    
    // 3) 确保新会话状态为 ACTIVE
    sessionInfo.setStatus(SessionStatus.ACTIVE);
    
    // 4) 登记当前会话
    registerLoginSession(sessionInfo, ttlSeconds);
    
    return kicked;
}
```

**关键逻辑**：
1. ✅ **查询 ACTIVE 会话**：只查询该 `userId` 的 ACTIVE 会话
2. ✅ **跳过同一 loginSessionId**：token 刷新场景，不踢掉自己
3. ✅ **标记为 KICKED**：旧会话标记为 KICKED（后续会在 `blacklistKickedSessions()` 中删除）
4. ✅ **注册新会话**：新会话状态为 ACTIVE

#### 4.5.2 单点登录流程图

```
用户 A 在设备 1 登录
  ↓
registerLoginSessionEnforceSingle()
  ├─ 查询 userId="user-A" 的 ACTIVE 会话 → []
  ├─ 没有旧会话，不踢掉
  └─ 注册新会话（status=ACTIVE）
  ↓
设备 1 登录成功

用户 A 在设备 2 登录
  ↓
registerLoginSessionEnforceSingle()
  ├─ 查询 userId="user-A" 的 ACTIVE 会话 → [设备1的会话]
  ├─ 设备1的会话 loginSessionId != 设备2的 loginSessionId
  ├─ 将设备1的会话标记为 KICKED
  ├─ 删除设备1的会话，并将 token 加入黑名单
  ├─ 发布 SESSION_KICKED 事件（设备1的 loginSessionId）
  └─ 注册新会话（设备2，status=ACTIVE）
  ↓
设备 2 登录成功，设备 1 被踢下线
```

---

### 4.6 错误处理

#### 4.6.1 错误处理策略

**原则**：**不阻塞登录流程**

**实现**：
```java
.onErrorResume(ex -> {
    log.error("登录会话管理失败", ex);
    // 即使失败，也继续执行默认的成功处理器，不阻塞登录流程
    return defaultSuccessHandler.onAuthenticationSuccess(exchange, authentication);
});
```

**错误场景**：
1. **获取 OAuth2AuthorizedClient 失败**：记录错误，继续登录
2. **解析 JWT 失败**：记录错误，继续登录
3. **注册会话失败**：记录错误，继续登录
4. **黑名单处理失败**：记录警告，继续登录
5. **事件发布失败**：记录错误，继续登录

**原因**：
- 登录流程不应该因为会话管理失败而中断
- 用户已经完成认证，应该能够登录成功
- 会话管理失败可以在后续请求中通过 JWT 校验发现

---

### 4.7 本章总结

**核心流程**：
1. OAuth2 授权码流程（Spring Security 自动处理）
2. 登录成功处理器（`LoginSessionKickHandler`）
3. 单点登录注册（`registerLoginSessionEnforceSingle`）
4. 黑名单处理（`blacklistKickedSessions`）
5. 事件发布（`publishKickedEvent`）
6. HTTP Session 存储（`storeLoginSessionIdInSession`）

**关键代码**：
- `LoginSessionKickHandler.onAuthenticationSuccess()`：主流程
- `extractJwtInfo()`：JWT 信息提取
- `extractSid()`：sid 提取
- `registerLoginSessionEnforceSingle()`：单点登录核心

**数据流转**：
- Redis 存储：按 `sessionId` 和 `loginSessionId` 双索引
- HTTP Session：存储 `loginSessionId`
- Kafka 事件：通知各服务断开 WebSocket

---

## 五、JWT校验流程完整实现

> **本章目标**：理解 JWT 校验的完整流程，掌握三层校验机制（签名、黑名单、状态）的实现细节。

---

### 5.1 JWT校验概述

#### 5.1.1 Spring Security JWT校验流程

**标准流程**：
1. 客户端请求携带 `Authorization: Bearer {token}`
2. Spring Security Filter Chain 拦截请求
3. 调用 `ReactiveJwtDecoder.decode(token)` 解析 JWT
4. 验证通过后，创建 `JwtAuthenticationToken`
5. 请求继续处理

#### 5.1.2 自定义校验逻辑

**三层校验机制**：
1. **第一层：Token 签名校验**（Spring Security 自动）
2. **第二层：黑名单校验**（自定义）
3. **第三层：会话状态校验**（自定义，核心）

---

### 5.2 代码调用链路（JWT校验）

#### 5.2.1 完整调用链路

```
客户端请求
  ↓
GET /api/users/me
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
  ↓
Spring Security Filter Chain
  ↓
OAuth2ResourceServerFilter（资源服务器过滤器）
  ↓
BearerTokenAuthenticationFilter
  ↓
提取 token: Authorization header → Bearer token
  ↓
调用 ReactiveJwtDecoder.decode(token)
  ↓
JwtDecoderConfig.jwtDecoder()（自定义解码器）
  ↓
  ├─ [第一层] 检查黑名单
  │     JwtBlacklistService.isBlacklisted(token)
  │     ├─ Redis EXISTS jwt:blacklist:{token}
  │     ├─ 命中 → 抛出 JwtException("Token has been revoked")
  │     └─ 未命中 → 继续
  │
  ├─ [第二层] Token 签名校验
  │     NimbusReactiveJwtDecoder.decode(token)
  │     ├─ 验证签名（使用 Keycloak 公钥）
  │     ├─ 验证过期时间（exp）
  │     ├─ 验证颁发者（iss）
  │     ├─ 验证受众（aud）
  │     ├─ 失败 → 抛出 JwtException
  │     └─ 成功 → 返回 Jwt 对象
  │
  └─ [第三层] 会话状态校验
        checkSessionStatus(jwt, token)
        ├─ 提取 loginSessionId（sid）
        ├─ 查询 SessionRegistry
        │     getLoginSessionByLoginSessionId(loginSessionId)
        ├─ 检查会话状态
        │     ├─ 不存在 → 跳过（向后兼容）
        │     ├─ ACTIVE → 通过
        │     ├─ KICKED → 抛出 JwtException("Session is not active: KICKED")
        │     └─ EXPIRED → 抛出 JwtException("Session is not active: EXPIRED")
        └─ 通过 → 返回 Jwt 对象
  ↓
创建 JwtAuthenticationToken
  ↓
设置到 SecurityContext
  ↓
请求继续处理
```

#### 5.2.2 关键节点说明

**节点1：黑名单检查**
- 最先执行，性能最高
- 立即拒绝已撤销的 token

**节点2：签名校验**
- Spring Security 自动完成
- 验证 token 的合法性

**节点3：会话状态校验**
- 核心机制
- 判断 loginSession 是否被踢

---

### 5.3 关键代码解析

#### 5.3.1 JwtDecoderConfig 类结构

**文件位置**：`apps/gateway/src/main/java/com/gamehub/gateway/config/JwtDecoderConfig.java`

**类定义**：
```java
@Slf4j
@Configuration
@RequiredArgsConstructor
public class JwtDecoderConfig {
    private final JwtBlacklistService jwtBlacklistService;
    private final SessionRegistry sessionRegistry;
    
    @Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri}")
    private String issuerUri;
}
```

**关键依赖**：
- `JwtBlacklistService`：JWT 黑名单服务
- `SessionRegistry`：会话注册表

#### 5.3.2 jwtDecoder Bean 方法

**方法签名**：
```java
@Bean
public ReactiveJwtDecoder jwtDecoder()
```

**完整实现**：
```java
@Bean
public ReactiveJwtDecoder jwtDecoder() {
    // 创建默认的 Nimbus JWT 解码器（用于签名校验）
    ReactiveJwtDecoder delegate = NimbusReactiveJwtDecoder
            .withIssuerLocation(issuerUri)
            .build();
    
    // 返回自定义的解码器（包装默认解码器）
    return token -> jwtBlacklistService.isBlacklisted(token)
            .flatMap(blacklisted -> {
                // [第一层] 黑名单检查
                if (Boolean.TRUE.equals(blacklisted)) {
                    log.warn("【JWT 校验】JWT 命中黑名单，拒绝访问。token={}...", shorten(token));
                    return Mono.error(new JwtException("Token has been revoked"));
                }
                
                // [第二层] 签名校验（委托给 Nimbus）
                return delegate.decode(token)
                        .flatMap(jwt -> {
                            // [第三层] 会话状态检查
                            return checkSessionStatus(jwt, token)
                                    .then(Mono.just(jwt))
                                    .doOnSuccess(j -> log.debug("【JWT 校验】JWT 验证通过，sub={}, token={}...", 
                                            j.getSubject(), shorten(token)));
                        });
            });
}
```

**关键点**：
- ✅ **三层校验顺序**：黑名单 → 签名 → 状态
- ✅ **链式调用**：使用 `flatMap` 链式处理
- ✅ **错误处理**：任何一层失败都抛出 `JwtException`

#### 5.3.3 checkSessionStatus 方法

**方法签名**：
```java
private Mono<Void> checkSessionStatus(Jwt jwt, String token)
```

**完整实现**：
```java
private Mono<Void> checkSessionStatus(Jwt jwt, String token) {
    try {
        // 1. 从 JWT 中提取 loginSessionId（优先使用 sid）
        String loginSessionId = extractLoginSessionId(jwt);
        
        log.info("【JWT 校验】开始检查会话状态: sub={}, loginSessionId={}, token前10位={}", 
                jwt.getSubject(), loginSessionId, shorten(token));
        
        // 2. 如果没有 loginSessionId，跳过状态检查（向后兼容）
        if (loginSessionId == null || loginSessionId.isBlank()) {
            log.warn("【JWT 校验】JWT 中没有 loginSessionId，跳过状态检查（向后兼容）: sub={}, jti={}", 
                    jwt.getSubject(), jwt.getId());
            return Mono.empty(); // 跳过，不拒绝
        }
        
        // 3. 查询 SessionRegistry，检查会话状态
        LoginSessionInfo sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
        
        // 4. 如果找不到会话，跳过状态检查（可能是旧 token 或首次登录）
        if (sessionInfo == null) {
            log.warn("【JWT 校验】SessionRegistry 中找不到会话，跳过状态检查: loginSessionId={}, sub={}, jti={}", 
                    loginSessionId, jwt.getSubject(), jwt.getId());
            return Mono.empty(); // 跳过，不拒绝
        }
        
        // 5. 验证查询到的会话是否匹配（防止查询到错误的会话）
        String jwtJti = jwt.getId(); // JWT 中的 jti
        String sessionJti = sessionInfo.getSessionId(); // SessionRegistry 中的 sessionId (jti)
        
        if (!jwtJti.equals(sessionJti)) {
            log.warn("【JWT 校验】⚠️ JWT 的 jti 与查询到的会话 sessionId 不匹配，可能查询到错误的会话: " +
                    "jwtJti={}, sessionJti={}, loginSessionId={}, sub={}", 
                    jwtJti, sessionJti, loginSessionId, jwt.getSubject());
            // 继续检查状态，但记录警告
        }
        
        // 6. 检查会话状态
        SessionStatus status = sessionInfo.getStatus();
        if (status == null) {
            // 向后兼容：如果状态为 null，默认为 ACTIVE
            status = SessionStatus.ACTIVE;
        }
        
        log.info("【JWT 校验】会话状态检查: loginSessionId={}, status={}, sub={}, sessionId={}, jwtJti={}, sessionJti={}", 
                loginSessionId, status, jwt.getSubject(), sessionInfo.getSessionId(), jwtJti, sessionJti);
        
        if (status != SessionStatus.ACTIVE) {
            log.warn("【JWT 校验】❌ 会话状态非 ACTIVE，拒绝访问: loginSessionId={}, status={}, sub={}, token前10位={}", 
                    loginSessionId, status, jwt.getSubject(), shorten(token));
            return Mono.error(new JwtException("Session is not active: " + status));
        }
        
        log.info("【JWT 校验】✅ 会话状态检查通过: loginSessionId={}, status={}, sub={}", 
                loginSessionId, status, jwt.getSubject());
        return Mono.empty(); // 通过
        
    } catch (Exception e) {
        // 如果检查过程中出现异常，记录日志但不阻塞（向后兼容）
        log.error("【JWT 校验】会话状态检查异常，跳过检查: sub={}", jwt.getSubject(), e);
        return Mono.empty(); // 跳过，不拒绝
    }
}
```

**关键逻辑**：

1. **提取 loginSessionId**
   - 优先使用 `sid`
   - 如果没有，使用 `session_state`（向后兼容）

2. **向后兼容处理**
   - 如果没有 `loginSessionId`，跳过检查
   - 如果找不到会话，跳过检查
   - 如果状态为 null，默认为 ACTIVE

3. **状态检查**
   - ACTIVE → 通过
   - KICKED → 拒绝
   - EXPIRED → 拒绝

4. **jti 匹配验证**
   - 验证 JWT 的 `jti` 与会话的 `sessionId` 是否匹配
   - 防止查询到错误的会话

#### 5.3.4 extractLoginSessionId 方法

**方法签名**：
```java
private String extractLoginSessionId(Jwt jwt)
```

**实现逻辑**：
```java
// 优先使用 sid
Object sidObj = jwt.getClaim("sid");
if (sidObj != null) {
    String sid = sidObj.toString();
    if (sid != null && !sid.isBlank()) {
        return sid;
    }
}

// 如果没有 sid，尝试使用 session_state（向后兼容）
Object sessionStateObj = jwt.getClaim("session_state");
if (sessionStateObj != null) {
    String sessionState = sessionStateObj.toString();
    if (sessionState != null && !sessionState.isBlank()) {
        return sessionState;
    }
}

return null;
```

**关键点**：
- ✅ **优先使用 sid**：Keycloak 原生会话 ID
- ✅ **向后兼容**：如果没有 sid，使用 session_state
- ✅ **返回 null**：如果都没有，返回 null（向后兼容）

---

### 5.4 拒绝访问的场景

#### 5.4.1 场景1：Token 在黑名单中

**触发条件**：
- Token 被加入黑名单（登出、被踢下线）

**处理逻辑**：
```java
if (Boolean.TRUE.equals(blacklisted)) {
    return Mono.error(new JwtException("Token has been revoked"));
}
```

**结果**：
- 返回 401 Unauthorized
- 错误信息：`Token has been revoked`

#### 5.4.2 场景2：会话状态为 KICKED

**触发条件**：
- 用户在其他设备登录，当前会话被标记为 KICKED

**处理逻辑**：
```java
if (status != SessionStatus.ACTIVE) {
    return Mono.error(new JwtException("Session is not active: " + status));
}
```

**结果**：
- 返回 401 Unauthorized
- 错误信息：`Session is not active: KICKED`

#### 5.4.3 场景3：会话状态为 EXPIRED

**触发条件**：
- 会话已过期或被用户主动注销

**处理逻辑**：
```java
if (status != SessionStatus.ACTIVE) {
    return Mono.error(new JwtException("Session is not active: " + status));
}
```

**结果**：
- 返回 401 Unauthorized
- 错误信息：`Session is not active: EXPIRED`

#### 5.4.4 场景4：会话不存在（向后兼容处理）

**触发条件**：
- SessionRegistry 中找不到会话（可能是旧 token 或首次登录）

**处理逻辑**：
```java
if (sessionInfo == null) {
    log.warn("SessionRegistry 中找不到会话，跳过状态检查");
    return Mono.empty(); // 跳过，不拒绝
}
```

**结果**：
- **不拒绝**：向后兼容，允许访问
- 记录警告日志

**原因**：
- 旧 token 可能没有在 SessionRegistry 中注册
- 首次登录时，SessionRegistry 可能还没有数据
- 向后兼容，避免影响现有功能

---

### 5.5 三层校验详细说明

#### 5.5.1 第一层：黑名单校验

**执行时机**：最先执行

**实现**：
```java
jwtBlacklistService.isBlacklisted(token)
    .flatMap(blacklisted -> {
        if (Boolean.TRUE.equals(blacklisted)) {
            return Mono.error(new JwtException("Token has been revoked"));
        }
        // 继续后续校验
    });
```

**作用**：
- ✅ 立即失效已撤销的 token
- ✅ 性能高（Redis 查询）

**使用场景**：
- 用户主动登出
- 用户在其他设备登录（旧 token 被加入黑名单）

#### 5.5.2 第二层：签名校验

**执行时机**：黑名单检查通过后

**实现**：
```java
ReactiveJwtDecoder delegate = NimbusReactiveJwtDecoder
        .withIssuerLocation(issuerUri)
        .build();

return delegate.decode(token);
```

**作用**：
- ✅ 验证 token 是否由合法的授权服务器签发
- ✅ 验证 token 是否过期
- ✅ 验证颁发者、受众等

**校验内容**：
- 签名是否有效（使用 Keycloak 公钥）
- 过期时间（exp）
- 颁发者（iss）
- 受众（aud）

#### 5.5.3 第三层：会话状态校验

**执行时机**：签名校验通过后

**实现**：
```java
return checkSessionStatus(jwt, token)
        .then(Mono.just(jwt));
```

**作用**：
- ✅ 判断 loginSession 是否被踢下线
- ✅ 实现单点登录（后连踢前）

**校验逻辑**：
1. 提取 `loginSessionId`（sid）
2. 查询 SessionRegistry
3. 检查会话状态是否为 ACTIVE

---

### 5.6 校验流程图

```
客户端请求（携带 token）
  ↓
[第一层] 黑名单校验
  ├─ 命中 → 401 Unauthorized（Token has been revoked）
  └─ 未命中 → 继续
  ↓
[第二层] 签名校验
  ├─ 签名无效 → 401 Unauthorized
  ├─ token 过期 → 401 Unauthorized
  └─ 通过 → 继续
  ↓
[第三层] 会话状态校验
  ├─ 没有 loginSessionId → 跳过（向后兼容）
  ├─ 找不到会话 → 跳过（向后兼容）
  ├─ 状态为 KICKED → 401 Unauthorized（Session is not active: KICKED）
  ├─ 状态为 EXPIRED → 401 Unauthorized（Session is not active: EXPIRED）
  └─ 状态为 ACTIVE → 通过
  ↓
创建 JwtAuthenticationToken
  ↓
请求继续处理
```

---

### 5.7 向后兼容处理

#### 5.7.1 为什么需要向后兼容

**原因**：
- 旧 token 可能没有 `loginSessionId`
- 旧 token 可能没有在 SessionRegistry 中注册
- 首次登录时，SessionRegistry 可能还没有数据

#### 5.7.2 向后兼容策略

**策略1：没有 loginSessionId**
```java
if (loginSessionId == null || loginSessionId.isBlank()) {
    return Mono.empty(); // 跳过，不拒绝
}
```

**策略2：找不到会话**
```java
if (sessionInfo == null) {
    return Mono.empty(); // 跳过，不拒绝
}
```

**策略3：状态为 null**
```java
if (status == null) {
    status = SessionStatus.ACTIVE; // 默认为 ACTIVE
}
```

**策略4：异常处理**
```java
catch (Exception e) {
    log.error("会话状态检查异常，跳过检查", e);
    return Mono.empty(); // 跳过，不拒绝
}
```

---

### 5.8 本章总结

**核心流程**：
1. 黑名单校验（第一层）
2. 签名校验（第二层）
3. 会话状态校验（第三层）

**关键代码**：
- `JwtDecoderConfig.jwtDecoder()`：自定义解码器
- `checkSessionStatus()`：会话状态检查
- `extractLoginSessionId()`：loginSessionId 提取

**拒绝访问的场景**：
- Token 在黑名单中
- 会话状态为 KICKED
- 会话状态为 EXPIRED

**向后兼容**：
- 没有 loginSessionId → 跳过
- 找不到会话 → 跳过
- 状态为 null → 默认为 ACTIVE

**下一步**：理解了 JWT 校验流程后，我们可以继续学习登出流程，了解如何清理会话和发布事件。

---

## 六、Token获取接口实现

> **本章目标**：理解 `/token` 接口的实现细节，掌握为什么需要多层验证来防止返回错误的 token，以及如何解决 OAuth2AuthorizedClientService 覆盖问题。

---

### 6.1 TokenController 概述

#### 6.1.1 /token 接口的作用

**功能**：
- 提供给前端获取当前登录用户的 `access_token`
- 支持自动刷新（如果 token 已过期且有 `refresh_token`）

**使用场景**：
- 前端需要 token 来调用后端 API
- 前端需要 token 来建立 WebSocket 连接（在连接时传递 token）

#### 6.1.2 为什么需要这个接口

**问题**：
- Gateway 使用 WebFlux，OAuth2 登录后的 token 保存在服务器端 Session 中
- 前端无法直接访问服务器端 Session
- 前端调用 `/token` 时必须带上登录后浏览器里保存的 `JSESSIONID` cookie，才能让服务器找到正确的 Session
- 需要通过接口获取 token

**解决方案**：
- 提供 `/token` 接口
- 前端附带 cookie 请求，后端通过 cookie 中的 `JSESSIONID` 定位 Session，再从 Session 中获取 token
- 返回给前端

---

### 6.2 代码调用链路（获取Token）

#### 6.2.1 前后端交互流程

**前端调用**：
```javascript
// authService.js
export async function getTokenFromGateway() {
  const res = await fetch('/token', {
    credentials: 'include',  // 重要：必须带cookie（JSESSIONID）
  })
  
  if (!res.ok) {
    if (res.status === 401) {
      handleAuthExpiredResponse(res, 'GET /token 返回 401')
      return null
    }
    throw new Error(`获取 token 失败 (HTTP ${res.status})`)
  }
  
  const data = await res.json()
  const token = data?.access_token
  saveToken(token)  // 保存到localStorage
  return token
}
```

**后端处理**：

#### 6.2.2 完整调用链路

```
前端调用 GET /token（带cookie: JSESSIONID）
  ↓
TokenController.getToken()
  ↓
  ├─ 1. 检查 Authentication
  │     ├─ 未认证 → 返回 401
  │     └─ 已认证 → 继续
  │
  ├─ 2. 调用 authorizedClientManager.authorize()
  │     └─ 从 Session 中获取 OAuth2AuthorizedClient
  │
  ├─ 3. 获取 access_token
  │     └─ authorizedClient.getAccessToken()
  │
  ├─ 4. 解析 JWT
  │     jwtDecoder.decode(tokenValue)
  │     ├─ 提取 userId (sub)
  │     ├─ 提取 jti
  │     └─ 提取 loginSessionId (sid)
  │
  ├─ 5. 验证 loginSessionId 与 HTTP Session 匹配
  │     ├─ 从 HTTP Session 获取 loginSessionId
  │     ├─ 比较 token 的 loginSessionId 与 Session 的 loginSessionId
  │     ├─ 不匹配 → 返回 401（token 已被覆盖）
  │     └─ 匹配 → 继续
  │
  ├─ 6. 验证会话状态为 ACTIVE
  │     sessionRegistry.getLoginSessionByLoginSessionId()
  │     ├─ 状态非 ACTIVE → 返回 401
  │     └─ 状态为 ACTIVE → 继续
  │
  ├─ 7. 验证 token 的 jti 与会话的 sessionId 匹配
  │     ├─ 比较 jwt.getId() 与 sessionInfo.getSessionId()
  │     ├─ 不匹配 → 调用 refreshLoginSession 更新 SessionRegistry（token 刷新）
  │     └─ 匹配 → 继续
  │
  └─ 8. 返回 token
        └─ 返回 access_token 和 refresh_token
```

#### 6.2.2 关键节点说明

**节点1：Authentication 检查**
- 确保用户已登录
- 未登录返回 401

**节点2：获取 OAuth2AuthorizedClient**
- 从 Session 中获取
- 如果 token 已过期，会自动刷新

**节点3-4：解析 JWT**
- 提取关键信息
- 用于后续验证

**节点5-7：多层验证**
- 防止返回错误的 token
- 解决 OAuth2AuthorizedClientService 覆盖问题

---

### 6.3 关键代码解析

#### 6.3.1 TokenController 类结构

**文件位置**：`apps/gateway/src/main/java/com/gamehub/gateway/controller/TokenController.java`

**类定义**：
```java
@Slf4j
@RestController
public class TokenController {
    private static final String SESSION_LOGIN_SESSION_ID_KEY = "LOGIN_SESSION_ID";
    
    private final ReactiveOAuth2AuthorizedClientManager authorizedClientManager;
    private final ReactiveJwtDecoder jwtDecoder;
    private final SessionRegistry sessionRegistry;
}
```

**关键依赖**：
- `ReactiveOAuth2AuthorizedClientManager`：获取 OAuth2 授权客户端
- `ReactiveJwtDecoder`：解析 JWT
- `SessionRegistry`：查询会话状态

#### 6.3.2 getToken 方法

**方法签名**：
```java
@GetMapping("/token")
public Mono<ResponseEntity<Map<String, Object>>> getToken(Authentication authentication, ServerWebExchange exchange)
```

**完整实现流程**：

**步骤1：检查 Authentication**
```java
if (authentication == null || !authentication.isAuthenticated()) {
    return Mono.just(ResponseEntity.status(401).body(
            Map.<String, Object>of("error", "未登录", "message", "请先通过 /oauth2/authorization/keycloak 登录")
    ));
}
```

**步骤2：获取 OAuth2AuthorizedClient**
```java
OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest
        .withClientRegistrationId("keycloak")
        .principal(authentication)
        .build();

return authorizedClientManager.authorize(authorizeRequest)
        .flatMap(authorizedClient -> {
            // authorizedClient 包含 access_token 和 refresh_token
        });
```

**步骤3-4：解析 JWT**
```java
OAuth2AccessToken accessToken = authorizedClient.getAccessToken();
String tokenValue = accessToken.getTokenValue();

return jwtDecoder.decode(tokenValue)
        .flatMap(jwt -> {
            String loginSessionId = extractLoginSessionId(jwt);
            String jwtJti = jwt.getId();
            String userId = jwt.getSubject();
        });
```

**步骤5：验证 loginSessionId 与 HTTP Session 匹配**
```java
if (loginSessionId != null && !loginSessionId.isBlank()) {
    return exchange.getSession()
            .flatMap((WebSession session) -> {
                String sessionLoginSessionId = (String) session.getAttributes().get(SESSION_LOGIN_SESSION_ID_KEY);
                
                // 如果 Session 中没有 loginSessionId，跳过验证（向后兼容）
                if (sessionLoginSessionId == null || sessionLoginSessionId.isBlank()) {
                    // 跳过验证
                } else if (!loginSessionId.equals(sessionLoginSessionId)) {
                    // Token 的 loginSessionId 与 Session 中的不匹配，说明 token 已被覆盖
                    return Mono.just(ResponseEntity.status(401).body(
                            Map.<String, Object>of("error", "Token 已失效", "message", "请重新登录")
                    ));
                }
            });
}
```

**关键点**：
- ✅ **防止 token 被覆盖**：如果 token 的 `loginSessionId` 与 Session 中的不匹配，说明 token 已被其他登录覆盖
- ✅ **向后兼容**：如果 Session 中没有 `loginSessionId`，跳过验证

**步骤6：验证会话状态为 ACTIVE**
```java
var sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
if (sessionInfo != null) {
    if (sessionInfo.getStatus() != null 
            && sessionInfo.getStatus() != SessionStatus.ACTIVE) {
        // 会话状态非 ACTIVE，拒绝返回 token
        return Mono.just(ResponseEntity.status(401).body(
                Map.<String, Object>of("error", "会话已失效", "message", "请重新登录")
        ));
    }
}
```

**关键点**：
- ✅ **检查会话状态**：确保会话状态为 ACTIVE
- ✅ **防止使用被踢的会话**：如果会话状态为 KICKED 或 EXPIRED，拒绝返回 token

**步骤7：验证 token 的 jti 与会话的 sessionId 匹配，如果 token 刷新则更新 SessionRegistry**
```java
String sessionJti = sessionInfo.getSessionId();
if (!jwtJti.equals(sessionJti)) {
    // Token 的 jti 与会话的 sessionId 不匹配，说明 token 已刷新
    // 更新 SessionRegistry 中的 sessionId、token、issuedAt、expiresAt
    log.info("检测到 token 刷新，更新 SessionRegistry: userId={}, loginSessionId={}, oldJti={}, newJti={}",
            userId, loginSessionId, sessionJti, jwtJti);
    
    sessionInfo.setSessionId(jwtJti);
    sessionInfo.setToken(tokenValue);
    sessionInfo.setIssuedAt(issuedAtMillis);
    sessionInfo.setExpiresAt(expiresAtMillis);
    
    long refreshTtlSeconds = resolveRefreshTtlSeconds(refreshToken);
    sessionRegistry.refreshLoginSession(sessionInfo, sessionJti, refreshTtlSeconds);
}
```

**关键点**：
- ✅ **检测 token 刷新**：如果 token 的 `jti` 与会话的 `sessionId` 不匹配，说明 token 已刷新
- ✅ **更新 SessionRegistry**：调用 `refreshLoginSession()` 更新会话信息（删除旧的 sessionId 记录，添加新的 sessionId 记录）
- ✅ **保持 loginSessionId 不变**：token 刷新时 `loginSessionId` 保持不变，确保会话关联正确

**步骤8：返回 token**
```java
Map<String, Object> result = new HashMap<>();
result.put("access_token", tokenValue);
result.put("token_type", accessToken.getTokenType().getValue());
if (accessToken.getExpiresAt() != null) {
    result.put("expires_at", accessToken.getExpiresAt().toEpochMilli());
}
OAuth2RefreshToken refreshToken = authorizedClient.getRefreshToken();
if (refreshToken != null) {
    result.put("refresh_token", refreshToken.getTokenValue());
    if (refreshToken.getExpiresAt() != null) {
        result.put("refresh_token_expires_at", refreshToken.getExpiresAt().toEpochMilli());
    }
}
return Mono.just(ResponseEntity.ok(result));
```

---

### 6.4 为什么需要验证

#### 6.4.1 OAuth2AuthorizedClientService 覆盖问题

**问题描述**：

`OAuth2AuthorizedClientService` 存储 `OAuth2AuthorizedClient` 时，使用 `userId` 作为 key。这意味着：

```
用户 A 在设备 1 登录
  ↓
OAuth2AuthorizedClientService 存储：
  key: userId="user-A"
  value: OAuth2AuthorizedClient(token1, loginSessionId="sid-001")

用户 A 在设备 2 登录
  ↓
OAuth2AuthorizedClientService 存储：
  key: userId="user-A"
  value: OAuth2AuthorizedClient(token2, loginSessionId="sid-002")
  ↓
设备 1 的 token1 被覆盖！
```

**结果**：
- 设备 1 调用 `/token` 接口时，可能获取到设备 2 的 token
- 设备 1 使用错误的 token 访问资源，导致访问控制混乱

#### 6.4.2 解决方案：多层验证

**验证1：loginSessionId 与 HTTP Session 匹配**
```java
String sessionLoginSessionId = (String) session.getAttributes().get(SESSION_LOGIN_SESSION_ID_KEY);
if (!loginSessionId.equals(sessionLoginSessionId)) {
    // Token 的 loginSessionId 与 Session 中的不匹配，说明 token 已被覆盖
    return 401;
}
```

**原理**：
- 登录时，将 `loginSessionId` 存储到 HTTP Session
- 获取 token 时，验证 token 的 `loginSessionId` 与 Session 中的是否匹配
- 如果不匹配，说明 token 已被其他登录覆盖

**验证2：会话状态为 ACTIVE**
```java
if (sessionInfo.getStatus() != SessionStatus.ACTIVE) {
    // 会话状态非 ACTIVE，拒绝返回 token
    return 401;
}
```

**原理**：
- 如果会话状态为 KICKED 或 EXPIRED，说明会话已失效
- 拒绝返回 token，强制用户重新登录

**验证3：token 的 jti 与会话的 sessionId 匹配（token 刷新时更新 SessionRegistry）**
```java
if (!jwtJti.equals(sessionJti)) {
    // Token 的 jti 与会话的 sessionId 不匹配，说明 token 已刷新
    // 更新 SessionRegistry 中的会话信息
    sessionInfo.setSessionId(jwtJti);
    sessionInfo.setToken(tokenValue);
    sessionInfo.setIssuedAt(issuedAtMillis);
    sessionInfo.setExpiresAt(expiresAtMillis);
    
    long refreshTtlSeconds = resolveRefreshTtlSeconds(refreshToken);
    sessionRegistry.refreshLoginSession(sessionInfo, sessionJti, refreshTtlSeconds);
}
```

**resolveRefreshTtlSeconds 方法**：
```java
private long resolveRefreshTtlSeconds(OAuth2RefreshToken refreshToken) {
    if (refreshToken != null && refreshToken.getExpiresAt() != null) {
        long ttl = Duration.between(Instant.now(), refreshToken.getExpiresAt()).getSeconds();
        return Math.max(ttl, 0);
    }
    return 0;
}
```

**原理**：
- 如果 `jti` 不匹配，说明 token 已刷新（`jti` 在刷新时会变化）
- 调用 `refreshLoginSession()` 更新 SessionRegistry：
  - 删除旧的 `sessionId` 记录
  - 添加新的 `sessionId` 记录
  - 更新 `loginSessionId` 索引（保持 `loginSessionId` 不变）
- TTL 计算：使用 `refresh_token` 的过期时间计算 TTL，确保会话生命周期与 refresh_token 一致
- 确保 SessionRegistry 中的会话信息与当前 token 一致

#### 6.4.3 验证流程图

```
设备 1 调用 /token
  ↓
获取 OAuth2AuthorizedClient（可能被设备 2 覆盖）
  ↓
解析 JWT，提取 loginSessionId="sid-002"（设备 2 的）
  ↓
从 HTTP Session 获取 loginSessionId="sid-001"（设备 1 的）
  ↓
比较：sid-002 != sid-001
  ↓
返回 401（Token 已失效，请重新登录）
  ↓
设备 1 重新登录
```

---

### 6.5 向后兼容处理

#### 6.5.1 没有 loginSessionId 的情况

**处理逻辑**：
```java
if (loginSessionId == null || loginSessionId.isBlank()) {
    // 没有 loginSessionId，直接返回 token（向后兼容）
    return Mono.just(ResponseEntity.ok(result));
}
```

**原因**：
- 旧 token 可能没有 `loginSessionId`
- 向后兼容，避免影响现有功能

#### 6.5.2 Session 中没有 loginSessionId 的情况

**处理逻辑**：
```java
if (sessionLoginSessionId == null || sessionLoginSessionId.isBlank()) {
    // 跳过验证（向后兼容）
}
```

**原因**：
- 旧登录可能没有在 Session 中存储 `loginSessionId`
- 向后兼容，避免影响现有功能

---

### 6.6 本章总结

**核心功能**：
1. 提供给前端获取 token 的接口
2. 支持自动刷新 token
3. 多层验证防止返回错误的 token

**关键验证**：
1. **loginSessionId 与 HTTP Session 匹配**：防止 token 被覆盖
2. **会话状态为 ACTIVE**：防止使用被踢的会话
3. **token 的 jti 与会话的 sessionId 匹配**：确保返回的 token 属于当前会话

**解决的问题**：
- ✅ **OAuth2AuthorizedClientService 覆盖问题**：通过多层验证，确保返回的 token 属于当前会话
- ✅ **单点登录问题**：如果 token 已被其他登录覆盖，拒绝返回 token



---

## 七、登出流程完整实现

> **本章目标**：理解完整的登出流程，掌握如何清理会话、加入黑名单、发布事件，以及为什么登出时加入黑名单的是 JWT token。

---

### 7.1 登出流程概述

#### 7.1.1 用户登出流程

**标准流程**：
1. 用户点击登出按钮
2. 前端调用 `/logout` 接口
3. Spring Security Logout Filter 拦截请求
4. 执行自定义登出处理器
5. 调用 Keycloak OIDC 登出接口
6. 重定向到登录页面或首页

#### 7.1.2 登出处理逻辑

**自定义处理逻辑**（`jwtBlacklistLogoutHandler`）：
1. 获取 `OAuth2AuthorizedClient`（包含 access_token）
2. 将 `access_token` 加入黑名单
3. 从 JWT 中提取 `loginSessionId`
4. 发布 SESSION_INVALIDATED 事件（包含 `loginSessionId`）
5. 清理 SessionRegistry 中的登录会话（调用 `removeAllSessions(userId)`）
6. 移除 `OAuth2AuthorizedClient`
7. 调用 Keycloak OIDC 登出接口

---

### 7.2 代码调用链路（登出）

#### 7.2.1 前后端交互流程

**前端调用**：
```javascript
// authService.js
export async function logoutFromGateway(redirectUri = window.location.origin) {
  try {
    await fetch('/logout', {
      method: 'POST',
      credentials: 'include',  // 重要：必须带cookie（JSESSIONID）
    })
  } catch (error) {
    console.warn('调用 /logout 失败，直接清理本地状态', error)
  } finally {
    clearToken()  // 清除localStorage中的token
    sessionLoggingOut = false
    if (redirectUri) {
      window.location.href = redirectUri  // 重定向到首页
    }
  }
}
```

**后端处理**：

#### 7.2.2 完整调用链路

```
用户点击登出按钮
  ↓
前端调用 POST /logout（带cookie: JSESSIONID）
  ↓
Spring Security Logout Filter
  ↓
SecurityConfig.logout() 配置
  ↓
执行 jwtBlacklistLogoutHandler（自定义登出处理器）
  ↓
  ├─ 1. 获取 OAuth2AuthorizedClient
  │     authorizedClientRepository.loadAuthorizedClient()
  │
  ├─ 2. 将 access_token 加入黑名单
  │     addTokenToBlacklist()
  │     └─ JwtBlacklistService.addToBlacklist(token, ttl)
  │         └─ Redis SET jwt:blacklist:{token} "1" EX {ttl}
  │
  ├─ 3. 从 JWT 中提取 loginSessionId
  │     publishSessionInvalidatedEvent()
  │     ├─ 从 Authentication 获取 JWT
  │     └─ 提取 loginSessionId（sid）
  │
  ├─ 4. 发布 SESSION_INVALIDATED 事件
  │     SessionEventPublisher.publishSessionInvalidated()
  │     └─ Kafka 发送事件（包含 loginSessionId）
  │
  ├─ 5. 清理 SessionRegistry 中的登录会话
  │     sessionRegistry.removeAllSessions(userId)
  │     └─ 删除该用户的所有登录会话记录
  │
  └─ 6. 移除 OAuth2AuthorizedClient
        authorizedClientRepository.removeAuthorizedClient()
  ↓
调用 OIDC 登出成功处理器
  ↓
OidcClientInitiatedServerLogoutSuccessHandler
  ↓
调用 Keycloak OIDC 登出接口
  ↓
重定向到前端首页（http://localhost:5173/）
  ↓
登出完成
```

#### 7.2.2 关键节点说明

**节点1：获取 OAuth2AuthorizedClient**
- 从 Session 中获取已保存的授权客户端
- 包含 access_token 和 refresh_token

**节点2：加入黑名单**
- 将 access_token 加入黑名单
- 立即失效 token

**节点3：发布事件**
- 发布 SESSION_INVALIDATED 事件
- 通知各服务断开 WebSocket 连接

**节点5：清理 SessionRegistry**
- 调用 `removeAllSessions(userId)` 清除该用户的所有登录会话
- 确保会话数据完全清理

**节点6：移除授权客户端**
- 清除 Session 中的授权客户端
- 防止 token 被重复使用

---

### 7.3 关键代码解析

#### 7.3.1 SecurityConfig.logout 配置

**文件位置**：`apps/gateway/src/main/java/com/gamehub/gateway/config/SecurityConfig.java`

**配置代码**：
```java
http.logout(l -> {
    // 添加自定义登出处理器（负责黑名单和事件发布）
    l.logoutHandler(jwtBlacklistLogoutHandler(blacklistService, authorizedClientRepository, sessionEventPublisher));
    
    // 设置 OIDC 登出成功处理器（调用 Keycloak 登出接口）
    l.logoutSuccessHandler(oidcLogoutSuccessHandler(clientRegistrationRepository));
});
```

**关键点**：
- ✅ **登出处理器**：执行黑名单和事件发布
- ✅ **登出成功处理器**：调用 Keycloak 登出接口

#### 7.3.2 jwtBlacklistLogoutHandler 方法

**方法签名**：
```java
@Bean
public ServerLogoutHandler jwtBlacklistLogoutHandler(
        JwtBlacklistService blacklistService,
        ServerOAuth2AuthorizedClientRepository authorizedClientRepository,
        @Autowired(required = false) SessionEventPublisher sessionEventPublisher)
```

**完整实现**：
```java
@Bean
public ServerLogoutHandler jwtBlacklistLogoutHandler(...) {
    return (WebFilterExchange exchange, Authentication authentication) -> {
        if (authentication == null) {
            return Mono.empty();
        }
        
        return authorizedClientRepository
                .loadAuthorizedClient(REGISTRATION_ID, authentication, exchange.getExchange())
                .flatMap(client -> {
                    // 1. 写入黑名单
                    Mono<Void> blacklistMono = addTokenToBlacklist(client, blacklistService);
                    
                    // 2. 发布会话失效事件（从 JWT 中提取用户 ID，如果 SessionEventPublisher 可用）
                    Mono<Void> publishMono = (sessionEventPublisher != null) 
                            ? publishSessionInvalidatedEvent(authentication, sessionEventPublisher)
                            : Mono.empty();
                    
                    // 3. 清理 SessionRegistry 中的登录会话
                    Mono<Void> cleanupMono = Mono.fromRunnable(() -> {
                        try {
                            String userId = null;
                            if (authentication.getPrincipal() instanceof Jwt jwt) {
                                userId = jwt.getSubject();
                            } else if (authentication.getPrincipal() instanceof org.springframework.security.oauth2.core.OAuth2AuthenticatedPrincipal principal) {
                                userId = principal.getName();
                            } else {
                                userId = authentication.getName();
                            }
                            if (userId != null && !userId.isBlank()) {
                                sessionRegistry.removeAllSessions(userId);
                                log.info("登出时清理 SessionRegistry: userId={}", userId);
                            }
                        } catch (Exception e) {
                            log.warn("登出时清理 SessionRegistry 失败", e);
                        }
                    });
                    
                    // 并行执行，不阻塞
                    return Mono.when(blacklistMono, publishMono, cleanupMono);
                })
                .then(authorizedClientRepository.removeAuthorizedClient(REGISTRATION_ID, authentication, exchange.getExchange()))
                .doOnError(ex -> log.error("登出处理失败", ex))
                .onErrorResume(ex -> Mono.empty());
    };
}
```

**关键逻辑**：
1. ✅ **获取授权客户端**：从 Session 中获取
2. ✅ **并行执行**：黑名单和事件发布并行执行
3. ✅ **移除授权客户端**：清除 Session 中的授权客户端
4. ✅ **错误处理**：记录错误，不阻塞登出流程

#### 7.3.3 addTokenToBlacklist 方法

**方法签名**：
```java
private Mono<Void> addTokenToBlacklist(OAuth2AuthorizedClient client, JwtBlacklistService blacklistService)
```

**完整实现**：
```java
private Mono<Void> addTokenToBlacklist(OAuth2AuthorizedClient client, JwtBlacklistService blacklistService) {
    if (client == null || client.getAccessToken() == null) {
        return Mono.empty();
    }
    
    String token = client.getAccessToken().getTokenValue();
    Instant expiresAt = client.getAccessToken().getExpiresAt();
    
    // 计算剩余 TTL（秒）
    long expiresIn = 0;
    if (expiresAt != null) {
        expiresIn = Duration.between(Instant.now(), expiresAt).getSeconds();
    }
    expiresIn = Math.max(expiresIn, 0);
    
    // 加入黑名单
    return blacklistService.addToBlacklist(token, expiresIn);
}
```

**关键点**：
- ✅ **计算 TTL**：使用 token 剩余有效期作为黑名单 TTL
- ✅ **立即失效**：token 加入黑名单后立即失效

#### 7.3.4 publishSessionInvalidatedEvent 方法

**方法签名**：
```java
private Mono<Void> publishSessionInvalidatedEvent(Authentication authentication, SessionEventPublisher sessionEventPublisher)
```

**完整实现**：
```java
private Mono<Void> publishSessionInvalidatedEvent(Authentication authentication, 
                                                   SessionEventPublisher sessionEventPublisher) {
    return Mono.fromRunnable(() -> {
        try {
            String userId = null;
            String loginSessionId = null;
            
            // 从 Authentication 中提取用户 ID 和 loginSessionId
            if (authentication.getPrincipal() instanceof Jwt jwt) {
                userId = jwt.getSubject();
                
                // 从 JWT 中提取 loginSessionId（优先使用 sid）
                Object sidObj = jwt.getClaim("sid");
                if (sidObj != null) {
                    String sid = sidObj.toString();
                    if (sid != null && !sid.isBlank()) {
                        loginSessionId = sid;
                    }
                }
                
                // 如果没有 sid，尝试使用 session_state（向后兼容）
                if (loginSessionId == null) {
                    Object sessionStateObj = jwt.getClaim("session_state");
                    if (sessionStateObj != null) {
                        String sessionState = sessionStateObj.toString();
                        if (sessionState != null && !sessionState.isBlank()) {
                            loginSessionId = sessionState;
                        }
                    }
                }
            } else {
                userId = authentication.getName();
            }
            
            if (userId != null && !userId.isBlank()) {
                // 如果提取到了 loginSessionId，使用包含 loginSessionId 的工厂方法
                SessionInvalidatedEvent event;
                if (loginSessionId != null && !loginSessionId.isBlank()) {
                    event = SessionInvalidatedEvent.of(userId, loginSessionId, 
                            SessionInvalidatedEvent.EventType.LOGOUT, "用户主动登出");
                } else {
                    // 如果没有 loginSessionId，使用不包含 loginSessionId 的工厂方法（向后兼容）
                    event = SessionInvalidatedEvent.of(userId, 
                            SessionInvalidatedEvent.EventType.LOGOUT, "用户主动登出");
                }
                sessionEventPublisher.publishSessionInvalidated(event);
            }
        } catch (Exception e) {
            log.error("发布会话失效事件失败", e);
            // 不抛出异常，避免影响登出流程
        }
    });
}
```

**关键点**：
- ✅ **提取 loginSessionId**：从 JWT 中提取（优先使用 sid）
- ✅ **发布事件**：包含 `loginSessionId`，用于精确断开 WebSocket
- ✅ **错误处理**：记录错误，不阻塞登出流程

---

### 7.4 登出时的黑名单机制

#### 7.4.1 为什么登出时加入黑名单的是 JWT token

**问题**：为什么加入黑名单的是 JWT token，而不是 `loginSessionId`？

**答案**：

1. **JWT token 是访问凭证**
   - 客户端使用 JWT token 访问资源
   - 黑名单的目的是立即失效已发出的 token
   - 加入黑名单后，该 token 立即无法使用

2. **loginSessionId 是会话标识**
   - `loginSessionId` 用于标识整个登录会话
   - 一个 `loginSessionId` 可以对应多个 token（token 刷新）
   - 如果只将 `loginSessionId` 加入黑名单，无法立即失效已发出的 token

3. **两者配合使用**
   - **黑名单**：立即失效已发出的 token
   - **会话状态**：管理整个登录会话的状态

**示例**：
```
用户登出：
  Token: jti="jti-001", loginSessionId="sid-001"
  
加入黑名单：
  jwt:blacklist:{token} → "1"  ← 加入的是完整的 token 字符串
  
结果：
  - 该 token 立即失效（黑名单检查）
  - 该 loginSessionId 的会话状态可以标记为 EXPIRED（可选）
```

#### 7.4.2 JWT vs loginSessionId

**对比**：

| 特性 | JWT token | loginSessionId |
|------|-----------|----------------|
| **作用** | 访问凭证 | 会话标识 |
| **加入黑名单** | ✅ 是（立即失效） | ❌ 否（不是访问凭证） |
| **作用范围** | 单个 token | 整个登录会话 |
| **失效方式** | 黑名单检查 | 会话状态检查 |

**关系**：
```
LoginSession (loginSessionId: "sid-001")
  ├── Token 1 (jti: "jti-001") → 加入黑名单
  ├── Token 2 (jti: "jti-002") → 未加入黑名单（如果已刷新）
  └── Token 3 (jti: "jti-003") → 未加入黑名单（如果已刷新）
```

**登出时**：
- ✅ 将当前 token 加入黑名单（立即失效）
- ✅ 发布 SESSION_INVALIDATED 事件（包含 `loginSessionId`）
- ✅ 各服务收到事件后，断开该 `loginSessionId` 的所有 WebSocket 连接

#### 7.4.3 TTL 计算

**计算逻辑**：
```java
Instant expiresAt = client.getAccessToken().getExpiresAt();
long expiresIn = 0;
if (expiresAt != null) {
    expiresIn = Duration.between(Instant.now(), expiresAt).getSeconds();
}
expiresIn = Math.max(expiresIn, 0);
```

**关键点**：
- ✅ **使用 token 剩余有效期**：作为黑名单 TTL
- ✅ **自动过期**：token 过期后，黑名单记录自动删除
- ✅ **节省空间**：不需要手动清理过期的黑名单记录

**示例**：
```
Token 过期时间：2024-01-01 12:00:00
当前时间：2024-01-01 11:45:00
剩余时间：15 分钟 = 900 秒

加入黑名单：
  Redis SET jwt:blacklist:{token} "1" EX 900
```

---

### 7.5 登出流程图

```
用户点击登出
  ↓
调用 /logout 接口
  ↓
Spring Security Logout Filter
  ↓
jwtBlacklistLogoutHandler
  ├─ 获取 OAuth2AuthorizedClient
  ├─ 将 access_token 加入黑名单
  ├─ 提取 loginSessionId
  ├─ 发布 SESSION_INVALIDATED 事件
  └─ 移除 OAuth2AuthorizedClient
  ↓
OIDC 登出成功处理器
  ↓
调用 Keycloak OIDC 登出接口
  ↓
重定向到首页
  ↓
登出完成

同时：
Kafka 事件 → 各服务监听器
  ↓
SessionInvalidatedListener.onSessionInvalidated()
  ↓
基于 loginSessionId 查询 WebSocket 会话
  ↓
断开所有 WebSocket 连接
```

---

### 7.6 登出时的数据清理

#### 7.6.1 清理内容

**清理项**：
1. ✅ **OAuth2AuthorizedClient**：从 Session 中移除
2. ✅ **Token 加入黑名单**：立即失效
3. ✅ **发布事件**：通知各服务断开 WebSocket
4. ✅ **SessionRegistry 中的会话记录**：调用 `removeAllSessions(userId)` 清除该用户的所有登录会话

**单点登录被踢时的清理**：
- ✅ **被踢掉的旧会话**：调用 `unregisterLoginSession(sessionId)` 从 SessionRegistry 中删除旧会话记录

---

### 7.7 本章总结

**核心流程**：
1. 获取 OAuth2AuthorizedClient
2. 将 access_token 加入黑名单
3. 提取 loginSessionId
4. 发布 SESSION_INVALIDATED 事件
5. 清理 SessionRegistry 中的登录会话（`removeAllSessions(userId)`）
6. 移除 OAuth2AuthorizedClient
7. 调用 Keycloak OIDC 登出接口

**关键代码**：
- `SecurityConfig.jwtBlacklistLogoutHandler()`：登出处理器
- `addTokenToBlacklist()`：黑名单处理
- `publishSessionInvalidatedEvent()`：事件发布

**黑名单机制**：
- ✅ 加入黑名单的是 **JWT token**（完整的 token 字符串）
- ✅ 不是 `loginSessionId`（`loginSessionId` 用于会话管理）
- ✅ TTL 使用 token 剩余有效期



---

## 七点五、前端认证实现

> **本章目标**：理解前端认证的完整实现，掌握前端如何与Gateway交互获取token、如何管理认证状态、如何建立WebSocket连接，以及前后端交互使用的API。

---

### 7.5.1 前端认证架构概述

#### 7.5.1.1 前端认证流程

**核心组件**：
- **AuthContext**：React Context，管理全局认证状态
- **authService**：认证服务，封装与Gateway的交互
- **apiClient**：HTTP客户端，自动携带token
- **gomokuSocket**：WebSocket服务，建立连接时传递token

**认证流程**：
1. 应用启动时，`AuthProvider` 初始化，调用 `ensureAuthenticated()`
2. 优先从Gateway获取最新token（`GET /token`，自动刷新）
3. 验证token有效性（调用 `/game-service/me`）
4. 如果token无效或不存在，跳转到登录页面（`/oauth2/authorization/keycloak`）
5. 登录成功后，Gateway重定向回前端，前端再次获取token
6. 保存token到localStorage，供后续使用

#### 7.5.1.2 前端与后端交互的API

**Gateway提供的API**：
- `GET /token`：获取当前登录用户的access_token（支持自动刷新）
- `GET /oauth2/authorization/keycloak`：触发OAuth2登录流程
- `POST /logout`：登出接口

**应用服务提供的API**（用于验证token）：
- `GET /game-service/me`：获取当前用户信息（用于验证token有效性）
- `GET /system-service/api/users/me`：获取用户详细信息（备用）

---

### 7.5.2 前端认证服务（authService）

#### 7.5.2.1 核心方法

**文件位置**：`game-hub-web/src/services/auth/authService.js`

**关键常量**：
```javascript
const TOKEN_STORAGE_KEY = 'access_token'  // localStorage中的token键名
const GATEWAY_LOGIN_URL = '/oauth2/authorization/keycloak'  // 登录入口
const GATEWAY_TOKEN_URL = '/token'  // Token获取接口
```

**核心方法**：

1. **`getTokenFromGateway()`**：从Gateway获取token
   - 调用 `GET /token`（带cookie，credentials: 'include'）
   - Gateway通过cookie中的JSESSIONID定位Session，返回token
   - 如果返回401，说明未登录，触发登录流程
   - 成功后将token保存到localStorage

2. **`ensureAuthenticated(autoLogin = true)`**：确保已认证
   - **autoLogin=true**：优先从Gateway获取最新token（可自动刷新）
     - 调用 `getTokenFromGateway()`
     - 验证token有效性（`validateToken()`）
     - 如果有效，返回token
     - 如果无效，清除本地token
   - 其次尝试使用本地保存的token
     - 从localStorage读取token
     - 验证token有效性
     - 如果有效，返回token
   - 最后触发登录流程（如果autoLogin=true）
     - 调用 `initAndLogin()`，跳转到登录页面

3. **`validateToken(token)`**：验证token有效性
   - 调用 `GET /game-service/me`（携带token）
   - 如果返回401，说明token无效，触发登录流程
   - 如果返回200，说明token有效

4. **`getUserInfo()`**：获取用户信息
   - 优先调用 `GET /system-service/api/users/me`（获取详细用户信息，包含id、username、nickname、email等）
   - 如果失败（返回非200），降级调用 `GET /game-service/me`（从JWT提取用户信息，包含sub、username、email等）
   - 如果两个都失败，返回null

5. **`initAndLogin()`**：初始化并登录
   - 先尝试从Gateway获取token
   - 如果获取失败，跳转到 `/oauth2/authorization/keycloak`

6. **`logoutFromGateway()`**：登出
   - 调用 `POST /logout`（带cookie）
   - Gateway执行登出处理（黑名单、事件发布、清理Session）
   - 清除本地token
   - 重定向到首页

#### 7.5.2.2 认证过期处理

**认证过期场景**：
- HTTP请求返回401
- WebSocket连接被拒绝（401）
- Token验证失败

**处理机制**：
- 显示认证过期弹窗（`showAuthModal()`）
- 提供"重新登录"按钮，跳转到登录页面
- 清除本地token

**关键代码**：
```javascript
export function handleAuthExpiredResponse(res, context) {
  // 检查响应头中是否有 X-Auth-Redirect-To
  const redirect = res.headers.get('X-Auth-Redirect-To')
  if (redirect) {
    showAuthModal('登录状态已过期，请重新登录。')
    return
  }
  performSessionLogout(context)
}

export function performSessionLogout(reason = '') {
  clearToken()
  showAuthModal(reason || '会话已失效，请点击"重新登录"再次进入游戏。')
}
```

---

### 7.5.3 前端认证上下文（AuthContext）

#### 7.5.3.1 AuthProvider组件

**文件位置**：`game-hub-web/src/contexts/AuthContext.jsx`

**职责**：
- 管理全局认证状态（`isAuthenticated`、`isLoading`、`user`）
- 应用启动时自动初始化认证状态
- 提供登录、登出、刷新用户信息的方法

**初始化流程**：
```javascript
useEffect(() => {
  async function bootstrap() {
    // 1. 确保已认证（非公开路由会触发登录）
    const token = await ensureAuthenticated(!isPublicRoute)
    
    // 2. 如果获取到token，设置认证状态
    if (token) {
      setIsAuthenticated(true)
      await loadUserProfile()  // 加载用户信息
    } else {
      setIsAuthenticated(false)
    }
    
    setIsLoading(false)
  }
  bootstrap()
}, [isPublicRoute, loadUserProfile])
```

**公开路由**：
- `/sessions`：会话监控页面（调试用，不需要认证）

**关键方法**：
- `login()`：调用 `initAndLogin()`，跳转到登录页面
- `logout()`：调用 `logoutFromGateway()`，执行登出
- `refreshUser()`：重新加载用户信息

#### 7.5.3.2 useAuth Hook

**文件位置**：`game-hub-web/src/hooks/useAuth.js`（重新导出自 `AuthContext.jsx`）

**作用**：从AuthContext中提取认证状态和方法

**实现**：
```javascript
// hooks/useAuth.js 只是重新导出，实际实现在 AuthContext.jsx 中
export { useAuth } from '../contexts/AuthContext.jsx'
```

**使用示例**：
```javascript
const { isAuthenticated, isLoading, user, login, logout } = useAuth()
```

---

### 7.5.4 路由保护（ProtectedRoute）

#### 7.5.4.1 ProtectedRoute组件

**文件位置**：`game-hub-web/src/components/common/ProtectedRoute.jsx`

**职责**：
- 保护需要认证的路由
- 未认证时重定向到首页

**实现**：
```javascript
import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '../../hooks/useAuth.js'

const ProtectedRoute = ({ children }) => {
  const location = useLocation()
  const { isAuthenticated, isLoading } = useAuth()
  
  if (isLoading) {
    return <div className="page page--centered">正在检查登录状态...</div>
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/" replace state={{ from: location }} />
  }
  
  return children
}
```

**使用**：
```javascript
<Route
  path="/lobby"
  element={
    <ProtectedRoute>
      <LobbyPage />
    </ProtectedRoute>
  }
/>
```

---

### 7.5.5 HTTP请求认证（apiClient）

#### 7.5.5.1 authenticatedFetch方法

**文件位置**：`game-hub-web/src/services/api/apiClient.js`

**职责**：
- 封装HTTP请求，自动携带token
- 统一处理401错误

**实现**：
```javascript
export async function authenticatedFetch(url, options = {}) {
  // 1. 确保已认证，获取token
  const token = await ensureAuthenticated()
  if (!token) {
    throw new Error('未登录')
  }
  
  // 2. 在请求头中添加Authorization
  const headers = new Headers(options.headers || {})
  headers.set('Authorization', `Bearer ${token}`)
  
  // 3. 发送请求
  const response = await fetch(url, {
    ...options,
    headers,
  })
  
  // 4. 如果返回401，触发认证过期处理
  if (response.status === 401) {
    handleAuthExpiredResponse(response, `${options.method || 'GET'} ${url} 返回 401`)
    throw new Error('认证失败')
  }
  
  return response
}
```

**使用**：
```javascript
// GET请求
const data = await get('/game-service/api/gomoku/rooms')

// POST请求
const result = await post('/game-service/api/gomoku/new', { mode: 'PVE' })
```

---

### 7.5.6 WebSocket连接认证（gomokuSocket）

#### 7.5.6.1 connectWebSocket方法

**文件位置**：`game-hub-web/src/services/ws/gomokuSocket.js`

**职责**：
- 建立WebSocket连接
- 在连接时传递token

**实现**：
```javascript
export async function connectWebSocket(callbacks = {}) {
  // 1. 确保已认证，获取token
  const token = await ensureAuthenticated()
  if (!token) {
    throw new Error('未登录')
  }
  
  // 2. 通过URL参数传递token（SockJS握手请求无法在请求头中传递自定义header）
  const wsUrl = `/game-service/ws?access_token=${encodeURIComponent(token)}`
  
  // 3. 建立SockJS连接
  socket = new SockJS(wsUrl)
  
  // 4. 使用STOMP协议
  stomp = Stomp.over(socket)
  
  // 5. 在STOMP CONNECT帧中传递token（作为Authorization header）
  const headers = { Authorization: 'Bearer ' + token }
  
  // 6. 建立连接
  stomp.connect(headers, (frame) => {
    callbacks.onConnect?.()
  }, (error) => {
    // 如果是401，触发认证过期处理
    if (isUnauthorizedWebSocketError(error)) {
      performSessionLogout('WebSocket 会话已失效，请重新登录')
      return
    }
    callbacks.onError?.(error)
  })
}
```

**关键点**：
- ✅ **URL参数传递token**：SockJS握手请求无法在请求头中传递自定义header，所以通过URL参数传递
- ✅ **STOMP CONNECT帧传递token**：在STOMP CONNECT帧的header中传递Authorization，后端通过`WebSocketAuthChannelInterceptor`验证
- ✅ **401错误处理**：如果连接被拒绝（401），自动触发登出流程

---

### 7.5.7 前后端交互API总结

#### 7.5.7.1 Gateway提供的认证API

| 方法 | 路径 | 说明 | 请求/响应 |
|------|------|------|----------|
| GET | `/oauth2/authorization/keycloak` | 触发OAuth2登录流程 | 重定向到Keycloak登录页面 |
| GET | `/token` | 获取当前登录用户的access_token | 请求：带cookie（JSESSIONID）<br>响应：`{ access_token: string, refresh_token?: string }` |
| POST | `/logout` | 登出接口 | 请求：带cookie（JSESSIONID）<br>响应：重定向到首页 |

#### 7.5.7.2 应用服务提供的验证API

| 方法 | 路径 | 说明 | 请求/响应 |
|------|------|------|----------|
| GET | `/game-service/me` | 获取当前用户信息（从JWT提取） | 请求：`Authorization: Bearer {token}`<br>响应：`{ code, message, data: { sub, username, nickname, email, ... } }` |
| GET | `/system-service/api/users/me` | 获取用户详细信息 | 请求：`Authorization: Bearer {token}`<br>响应：`{ code, message, data: { id, username, nickname, email, ... } }` |

#### 7.5.7.3 WebSocket连接

| 连接地址 | 说明 | 认证方式 |
|---------|------|---------|
| `/game-service/ws?access_token={token}` | WebSocket连接地址 | URL参数传递token，STOMP CONNECT帧header中传递Authorization |

---

### 7.5.8 前端认证数据流

#### 7.5.8.1 应用启动流程

```
应用启动（main.jsx）
  ↓
AuthProvider 初始化
  ↓
ensureAuthenticated(!isPublicRoute)
  ↓
1. 优先从Gateway获取token
   GET /token (credentials: 'include')
   ↓
   Gateway通过cookie定位Session，返回token
   ↓
   保存token到localStorage
  ↓
2. 验证token有效性
   GET /game-service/me (Authorization: Bearer {token})
   ↓
   如果返回200，token有效
   如果返回401，token无效，清除本地token
  ↓
3. 如果token无效且autoLogin=true
   跳转到 /oauth2/authorization/keycloak
  ↓
4. 登录成功后，Gateway重定向回前端
  ↓
5. 前端再次调用ensureAuthenticated()
  ↓
6. 获取token，设置认证状态
  ↓
7. 加载用户信息
   getUserInfo() → GET /system-service/api/users/me
  ↓
8. 渲染应用
```

#### 7.5.8.2 HTTP请求流程

```
前端调用API
  ↓
authenticatedFetch(url, options)
  ↓
1. ensureAuthenticated() → 获取token
   - 优先从Gateway获取（自动刷新）
   - 其次从localStorage读取
   - 如果无效，触发登录
  ↓
2. 在请求头中添加Authorization
   Authorization: Bearer {token}
  ↓
3. 发送请求
  ↓
4. 如果返回401
   handleAuthExpiredResponse()
   ↓
   显示认证过期弹窗
   ↓
   用户点击"重新登录"
   ↓
   跳转到 /oauth2/authorization/keycloak
```

#### 7.5.8.3 WebSocket连接流程

```
前端建立WebSocket连接
  ↓
connectWebSocket(callbacks)
  ↓
1. ensureAuthenticated() → 获取token
  ↓
2. 构建WebSocket URL
   /game-service/ws?access_token={token}
  ↓
3. 建立SockJS连接
  ↓
4. 使用STOMP协议
  ↓
5. 发送STOMP CONNECT帧
   headers: { Authorization: 'Bearer {token}' }
  ↓
6. 后端验证token（WebSocketAuthChannelInterceptor）
  ↓
7. 如果验证成功，连接建立
   如果验证失败（401），连接被拒绝
  ↓
8. 如果连接被拒绝
   performSessionLogout('WebSocket 会话已失效')
   ↓
   显示认证过期弹窗
```

---

### 7.5.9 前端认证状态管理

#### 7.5.9.1 Token存储

**存储位置**：`localStorage`

**键名**：`access_token`

**存储时机**：
- 从Gateway获取token成功后
- 登录成功后

**清除时机**：
- 登出时
- Token验证失败时
- 认证过期时

#### 7.5.9.2 认证状态

**全局状态**（AuthContext）：
- `isAuthenticated`：是否已认证
- `isLoading`：是否正在加载认证状态
- `user`：当前用户信息

**状态更新时机**：
- 应用启动时：初始化认证状态
- 登录成功后：设置 `isAuthenticated = true`，加载用户信息
- 登出时：设置 `isAuthenticated = false`，清除用户信息
- Token验证失败时：设置 `isAuthenticated = false`

---

### 7.5.10 前端认证关键代码

#### 7.5.10.1 authService.js 核心方法

**getTokenFromGateway**：
```javascript
export async function getTokenFromGateway() {
  const res = await fetch(GATEWAY_TOKEN_URL, {
    credentials: 'include',  // 重要：必须带cookie
  })
  
  if (!res.ok) {
    if (res.status === 401) {
      handleAuthExpiredResponse(res, 'GET /token 返回 401')
      return null
    }
    throw new Error(`获取 token 失败 (HTTP ${res.status})`)
  }
  
  const data = await res.json()
  const token = data?.access_token
  if (!token) {
    throw new Error('Gateway 返回的 token 为空')
  }
  
  saveToken(token)  // 保存到localStorage
  return token
}
```

**ensureAuthenticated**：
```javascript
export async function ensureAuthenticated(autoLogin = true) {
  // autoLogin 模式下优先从网关获取最新 token（可自动刷新）
  if (autoLogin) {
    let token = await getTokenFromGateway()
    if (token) {
      const isValid = await validateToken(token)
      if (isValid) {
        return token
      }
      clearToken()
    }
  }
  
  // 其次尝试使用本地保存的 token
  let localToken = getToken()
  if (localToken) {
    const isLocalValid = await validateToken(localToken)
    if (isLocalValid) {
      return localToken
    }
    clearToken()
  }
  
  // 非 autoLogin 模式不触发跳转登录
  if (!autoLogin) {
    return null
  }
  
  // 最后触发登录流程
  const token = await initAndLogin()
  return token
}
```

#### 7.5.10.2 AuthContext.jsx 初始化

```javascript
export function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [user, setUser] = useState(null)
  const location = useLocation()
  const isPublicRoute = PUBLIC_ROUTES.some((path) => location.pathname.startsWith(path))
  
  useEffect(() => {
    async function bootstrap() {
      try {
        // 确保已认证（非公开路由会触发登录）
        const token = await ensureAuthenticated(!isPublicRoute)
        
        if (token) {
          setIsAuthenticated(true)
          await loadUserProfile()  // 加载用户信息
        } else {
          setIsAuthenticated(false)
        }
      } catch (error) {
        console.warn('初始化认证状态失败', error)
        setIsAuthenticated(false)
      } finally {
        setIsLoading(false)
      }
    }
    
    bootstrap()
  }, [isPublicRoute, loadUserProfile])
  
  // ...
}
```

#### 7.5.10.3 gomokuSocket.js WebSocket连接

```javascript
export async function connectWebSocket(callbacks = {}) {
  // 确保已认证
  const token = await ensureAuthenticated()
  if (!token) {
    throw new Error('未登录')
  }
  
  // 通过URL参数传递token（SockJS握手请求无法在请求头中传递自定义header）
  const wsUrl = `/game-service/ws?access_token=${encodeURIComponent(token)}`
  socket = new SockJS(wsUrl)
  stomp = Stomp.over(socket)
  
  // 在STOMP CONNECT帧中传递token
  const headers = { Authorization: 'Bearer ' + token }
  
  stomp.connect(headers, (frame) => {
    callbacks.onConnect?.()
  }, (error) => {
    // 如果是401，触发认证过期处理
    if (isUnauthorizedWebSocketError(error)) {
      performSessionLogout('WebSocket 会话已失效，请重新登录')
      return
    }
    callbacks.onError?.(error)
  })
}
```

---

### 7.5.11 前端认证与后端流程对接

#### 7.5.11.1 登录流程对接

**前端**：
1. 用户访问需要认证的页面
2. `AuthProvider` 初始化，调用 `ensureAuthenticated(true)`
3. 如果未登录，跳转到 `/oauth2/authorization/keycloak`
4. Gateway重定向到Keycloak登录页面
5. 用户在Keycloak登录
6. Keycloak回调Gateway，Gateway处理登录（单点登录、黑名单、事件发布）
7. Gateway重定向回前端
8. 前端再次调用 `ensureAuthenticated()`，获取token
9. 保存token，设置认证状态，加载用户信息

**后端**（Gateway）：
- 处理OAuth2授权码流程
- 调用 `LoginSessionKickHandler` 实现单点登录
- 存储 `loginSessionId` 到HTTP Session
- 重定向回前端

#### 7.5.11.2 Token获取流程对接

**前端**：
1. 调用 `GET /token`（带cookie）
2. Gateway通过cookie定位Session
3. Gateway从Session中获取token
4. Gateway验证token（多层验证：Session、SessionRegistry、状态）
5. Gateway返回token
6. 前端保存token到localStorage

**后端**（Gateway - TokenController）：
- 从Session中获取 `OAuth2AuthorizedClient`
- 验证 `loginSessionId` 与Session匹配
- 验证会话状态为ACTIVE
- 验证token的jti与会话的sessionId匹配
- 返回token

#### 7.5.11.3 登出流程对接

**前端**：
1. 用户点击登出按钮
2. 调用 `logoutFromGateway()`
3. 发送 `POST /logout`（带cookie）
4. Gateway执行登出处理（黑名单、事件发布、清理SessionRegistry）
5. Gateway调用Keycloak OIDC登出接口
6. Gateway重定向到首页
7. 前端清除本地token

**后端**（Gateway - SecurityConfig）：
- `jwtBlacklistLogoutHandler`：将token加入黑名单，发布事件，清理SessionRegistry
- `OidcClientInitiatedServerLogoutSuccessHandler`：调用Keycloak登出接口

#### 7.5.11.4 WebSocket连接流程对接

**前端**：
1. 建立WebSocket连接：`/game-service/ws?access_token={token}`
2. 发送STOMP CONNECT帧，header中传递 `Authorization: Bearer {token}`
3. 后端验证token，建立连接
4. 如果验证失败（401），连接被拒绝，前端触发登出

**后端**（game-service）：
- `WebSocketAuthChannelInterceptor`：验证STOMP CONNECT帧中的token
- `WebSocketSessionManager`：注册WebSocket会话，实现单点登录（踢旧连接）

---

### 7.5.12 前端认证错误处理

#### 7.5.12.1 认证过期处理

**场景**：
- HTTP请求返回401
- WebSocket连接被拒绝（401）
- Token验证失败

**处理**：
1. 显示认证过期弹窗（`showAuthModal()`）
2. 提供"重新登录"按钮
3. 清除本地token
4. 用户点击"重新登录"，跳转到 `/oauth2/authorization/keycloak`

**弹窗实现**：
```javascript
export function showAuthModal(message) {
  // 动态创建弹窗DOM
  const modal = document.createElement('div')
  modal.id = AUTH_MODAL_ID
  modal.innerHTML = `
    <div class="auth-modal-backdrop">
      <div class="auth-modal-card">
        <h3>登录状态失效</h3>
        <p>${message || '很抱歉，您的登录已过期或被其他设备挤下线，请重新登录后继续。'}</p>
        <div class="auth-modal-actions">
          <button id="auth-modal-retry" class="auth-modal-btn primary">重新登录</button>
          <button id="auth-modal-cancel" class="auth-modal-btn secondary">稍后</button>
        </div>
      </div>
    </div>
  `
  document.body.appendChild(modal)
  
  // 绑定事件
  document.getElementById('auth-modal-retry').addEventListener('click', () => {
    window.location.href = `${GATEWAY_LOGIN_URL}?redirect_uri=${encodeURIComponent(window.location.href)}`
  })
}
```

#### 7.5.12.2 网络错误处理

**场景**：
- 网络连接失败
- Gateway服务不可用

**处理**：
- 记录错误日志
- 触发认证过期处理（`performSessionLogout()`）
- 显示错误提示

---

### 7.5.13 前端认证最佳实践

#### 7.5.13.1 Token管理

**存储**：
- ✅ 使用localStorage存储token（持久化）
- ✅ Token键名：`access_token`

**刷新**：
- ✅ 优先从Gateway获取最新token（`GET /token`，支持自动刷新）
- ✅ 如果Gateway返回的token无效，再尝试使用本地token

**清除**：
- ✅ 登出时清除
- ✅ Token验证失败时清除
- ✅ 认证过期时清除

#### 7.5.13.2 认证状态管理

**全局状态**：
- ✅ 使用React Context管理全局认证状态
- ✅ 应用启动时自动初始化
- ✅ 路由变化时检查认证状态

**状态更新**：
- ✅ 登录成功后立即更新
- ✅ 登出时立即更新
- ✅ Token验证失败时立即更新

#### 7.5.13.3 错误处理

**统一处理**：
- ✅ HTTP请求统一使用 `authenticatedFetch`，自动处理401
- ✅ WebSocket连接统一处理401错误
- ✅ 认证过期统一显示弹窗

**用户提示**：
- ✅ 认证过期时显示友好的提示信息
- ✅ 提供"重新登录"按钮，方便用户操作

---

### 7.5.14 本章总结

**前端认证核心要点**：

1. **Token获取**：
   - 优先从Gateway获取（`GET /token`，支持自动刷新）
   - 其次使用本地保存的token
   - 如果都无效，触发登录流程

2. **Token验证**：
   - 通过调用 `/game-service/me` 验证token有效性
   - 如果返回401，说明token无效，触发登录流程

3. **HTTP请求**：
   - 使用 `authenticatedFetch` 封装请求，自动携带token
   - 统一处理401错误

4. **WebSocket连接**：
   - 通过URL参数传递token（SockJS握手限制）
   - 在STOMP CONNECT帧header中传递Authorization
   - 统一处理401错误

5. **认证状态管理**：
   - 使用React Context管理全局状态
   - 应用启动时自动初始化
   - 路由保护使用 `ProtectedRoute`

6. **错误处理**：
   - 统一显示认证过期弹窗
   - 提供"重新登录"按钮

---

## 八、WebSocket连接管理

> **本章目标**：理解 WebSocket 连接管理的完整实现，掌握如何从 JWT 中提取 `loginSessionId`、如何实现 WebSocket 单点登录、如何踢掉旧连接。

---

### 8.1 WebSocket 连接概述

#### 8.1.1 STOMP 协议

**STOMP（Simple Text Oriented Messaging Protocol）**：
- 基于 WebSocket 的文本消息协议
- Spring WebSocket 支持 STOMP
- 提供订阅/发布模式

**连接流程（前后端交互）**：
1. **前端建立连接**：前端调用 `connectWebSocket()`
   - 确保已认证，获取token
   - 构建WebSocket URL：`/game-service/ws?access_token={token}`（通过URL参数传递token，因为SockJS握手请求无法在请求头中传递自定义header）
   - 建立SockJS连接
2. **前端发送STOMP CONNECT帧**：在STOMP CONNECT帧的header中传递 `Authorization: Bearer {token}`
3. **后端验证token**：`WebSocketAuthChannelInterceptor` 拦截CONNECT帧，验证token
4. **后端建立连接**：验证成功后，建立WebSocket连接
5. **后端注册会话**：`WebSocketSessionManager` 注册WebSocket会话到SessionRegistry，实现单点登录（踢旧连接）
6. **客户端订阅目标地址**：前端订阅 `/topic/room.{roomId}` 等
7. **服务器推送消息**：后端通过 `SimpMessagingTemplate` 推送消息

#### 8.1.2 WebSocket 会话注册

**会话管理**：
- 连接建立时，注册 WebSocket 会话到 `SessionRegistry`
- 连接断开时，从 `SessionRegistry` 注销会话
- 支持单点登录：新连接踢掉旧连接

---

### 8.2 代码调用链路（WebSocket连接）

#### 8.2.1 前后端交互流程

**前端建立连接**：
```javascript
// gomokuSocket.js
export async function connectWebSocket(callbacks = {}) {
  // 1. 确保已认证，获取token
  const token = await ensureAuthenticated()
  if (!token) {
    throw new Error('未登录')
  }
  
  // 2. 通过URL参数传递token（SockJS握手请求无法在请求头中传递自定义header）
  const wsUrl = `/game-service/ws?access_token=${encodeURIComponent(token)}`
  socket = new SockJS(wsUrl)
  stomp = Stomp.over(socket)
  
  // 3. 在STOMP CONNECT帧中传递token
  const headers = { Authorization: 'Bearer ' + token }
  
  stomp.connect(headers, (frame) => {
    callbacks.onConnect?.()
  }, (error) => {
    // 如果是401，触发认证过期处理
    if (isUnauthorizedWebSocketError(error)) {
      performSessionLogout('WebSocket 会话已失效，请重新登录')
      return
    }
    callbacks.onError?.(error)
  })
}
```

**后端处理**：

#### 8.2.2 完整调用链路

```
前端建立 WebSocket 连接
  ↓
ws://localhost:8080/game-service/ws?access_token=xxx
  ↓
Gateway: WebSocketTokenFilter（如果Gateway代理WebSocket）
  ↓
从 URL 参数提取 token，放入 Authorization header
  ↓
Spring WebSocket 握手
  ↓
STOMP CONNECT 命令到达
  ↓
WebSocketAuthChannelInterceptor.preSend()
  ↓
从 STOMP header 提取 token，验证并设置用户身份到会话
  ↓
验证通过，建立连接
  ↓
触发 SessionConnectEvent
  ↓
WebSocketSessionManager.handleSessionConnect()
  ↓
  ├─ 1. 从 Principal 提取信息（Principal 从 WebSocket 会话中获取）
  │     ├─ userId (principal.getName())
  │     ├─ sessionId (accessor.getSessionId())
  │     └─ loginSessionId (extractLoginSessionId(principal))
  │
  ├─ 2. 构建 WebSocketSessionInfo
  │     WebSocketSessionInfo.builder()
  │     ├─ sessionId
  │     ├─ userId
  │     ├─ loginSessionId
  │     └─ service = "game-service"
  │
  ├─ 3. 调用 registerWebSocketSessionEnforceSingle()
  │     SessionRegistry.registerWebSocketSessionEnforceSingle()
  │     ├─ 查询该用户的所有 WebSocket 会话
  │     ├─ 删除旧会话（返回被踢掉的旧连接列表）
  │     └─ 注册新会话
  │
  ├─ 4. 处理被踢掉的旧连接
  │     ├─ 发送踢人通知
  │     │     WebSocketDisconnectHelper.sendKickMessage()
  │     │     └─ 发送到 /queue/system.kick
  │     │
  │     └─ 强制断开连接
  │           WebSocketDisconnectHelper.forceDisconnect()
  │           └─ 发送 DISCONNECT 命令
  │
  └─ 5. 连接建立完成
```

#### 8.2.2 连接断开流程

```
客户端断开 WebSocket 连接
  ↓
触发 SessionDisconnectEvent
  ↓
WebSocketSessionManager.handleSessionDisconnect()
  ↓
SessionRegistry.unregisterWebSocketSession(sessionId)
  ↓
从 Redis 中删除会话记录
  ↓
连接断开完成
```

**断开检测机制**：

系统通过 Spring WebSocket 的 `SessionDisconnectEvent` 自动检测所有类型的 WebSocket 连接断开，包括：

1. ✅ **正常关闭浏览器/页签**：用户关闭浏览器或标签页时，TCP 连接断开，触发 `SessionDisconnectEvent`
2. ✅ **强制关闭浏览器**：任务管理器强制结束浏览器进程时，TCP 连接断开，触发事件
3. ✅ **网络中断**：网络连接中断时，TCP 连接断开，触发事件
4. ✅ **系统崩溃**：浏览器或系统崩溃时，TCP 连接断开，触发事件

**关键点**：
- ✅ **基于 TCP 连接检测**：比浏览器端 JavaScript 事件更可靠，不依赖前端代码
- ✅ **自动清理 Redis**：断开时自动调用 `unregisterWebSocketSession()`，清理 Redis 中的会话记录
- ✅ **无需前端配合**：即使前端没有发送断开消息，后端也能检测到连接断开
- ✅ **实时响应**：TCP 连接断开后立即触发事件，延迟极低

**注意**：
- 此机制仅清理 WebSocket 会话记录，不影响登录会话（loginSession）
- 登录会话的生命周期与 refresh_token 一致，不会因为 WebSocket 断开而失效

---

### 8.3 WebSocket 认证拦截器

#### 8.3.1 WebSocketAuthChannelInterceptor 概述

**作用**：在 STOMP CONNECT 阶段验证 JWT token 并设置用户身份到 WebSocket 会话中，供后续消息处理使用。

**触发时机**：
- 拦截所有进入 `clientInboundChannel` 的 STOMP 消息
- 仅处理 `CONNECT` 命令（连接建立时），其他消息（SEND、SUBSCRIBE 等）直接放行

**工作流程**：
1. 从 STOMP header 提取 token（支持 `Authorization` 或 `access_token`）
2. 使用 `JwtDecoder` 验证 token（签名、过期等）
3. 从 JWT 提取用户信息
4. 通过 `accessor.setUser()` 设置用户身份到 WebSocket 会话

**文件位置**：`apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/WebSocketAuthChannelInterceptor.java`

#### 8.3.2 WebSocketAuthChannelInterceptor 类结构

**类定义**：
```java
@Component
public class WebSocketAuthChannelInterceptor implements ChannelInterceptor {
    private final JwtDecoder jwtDecoder;
    private final JwtGrantedAuthoritiesConverter authoritiesConverter;
}
```

**关键依赖**：
- `JwtDecoder`：JWT 解码器，用于验证 token
- `JwtGrantedAuthoritiesConverter`：JWT 信息转换器，从 JWT 提取用户信息（本文档不涉及权限控制，仅用于提取用户身份）

#### 8.3.3 preSend 方法

**方法签名**：
```java
@Override
public Message<?> preSend(Message<?> message, MessageChannel channel)
```

**完整实现**：
```java
@Override
public Message<?> preSend(Message<?> message, MessageChannel channel) {
    StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
    
    // 仅处理 CONNECT 命令
    if (StompCommand.CONNECT.equals(accessor.getCommand())) {
        // 从 header 提取 token（支持多种格式）
        String auth = firstHeader(accessor, "Authorization");
        if (auth == null) auth = firstHeader(accessor, "authorization");
        if (auth == null) {
            String tokenOnly = firstHeader(accessor, "access_token");
            if (tokenOnly != null && !tokenOnly.isBlank()) 
                auth = "Bearer " + tokenOnly.trim();
        }
        
        // 验证 token 并设置用户身份
        if (auth != null && auth.toLowerCase().startsWith("bearer ")) {
            String token = auth.substring(7).trim();
            try {
                Jwt jwt = jwtDecoder.decode(token);
                Collection<GrantedAuthority> authorities = authoritiesConverter.convert(jwt);
                String name = Objects.requireNonNullElse(
                        jwt.getClaimAsString("preferred_username"), 
                        jwt.getSubject()
                );
                accessor.setUser(new JwtAuthenticationToken(jwt, authorities, name));
            } catch (Exception ignore) {
                // 验证失败不设置用户，后续操作会因缺少用户而失败
            }
        }
    }
    return message;
}
```

**关键逻辑**：
1. ✅ **拦截 CONNECT 命令**：仅处理 STOMP CONNECT 消息
2. ✅ **提取 token**：从 STOMP header 中提取 token（支持多种格式）
3. ✅ **验证 token**：使用 `JwtDecoder` 验证 token 的签名和有效性
4. ✅ **设置用户身份**：通过 `accessor.setUser()` 将用户身份存储到 WebSocket 会话中

#### 8.3.4 setUser() 的工作原理

**`accessor.setUser()` 的作用**：
- 将 `JwtAuthenticationToken` 存储到消息的 header 中
- Spring 框架自动将这个 Principal 保存到 WebSocket 会话存储中
- 会话以 `sessionId` 为 key，存储用户身份

**会话存储机制**：
```
WebSocket Session Store (Spring 框架管理)
├─ sessionId: "abc123"
│  └─ Principal: JwtAuthenticationToken(userId="user1", ...)
├─ sessionId: "def456"
│  └─ Principal: JwtAuthenticationToken(userId="user2", ...)
└─ ...
```

**关键点**：
- ✅ 用户身份存储在 WebSocket 会话中，而不是消息 header 中
- ✅ 后续消息可以从会话中获取用户身份，无需再次传递 token
- ✅ 会话在连接断开时自动清理

#### 8.3.5 后续消息如何获取用户身份

**流程**：
```
1. 客户端发送 STOMP SEND 消息（如 /app/gomoku.place）
   ↓
2. 消息包含 sessionId: "abc123"
   ↓
3. Spring 框架从 WebSocket 会话中获取用户身份：
   Principal = Session["abc123"].Principal
   ↓
4. 将用户身份设置到消息 header 中
   ↓
5. @MessageMapping 方法通过 sha.getUser() 获取用户身份
```

**代码示例**：
```java
@MessageMapping("/gomoku.place")
public void place(PlaceCmd cmd, SimpMessageHeaderAccessor sha) {
    // 从消息 header 中获取用户身份（Spring 框架已从会话中设置）
    final String userId = Objects.requireNonNull(sha.getUser(), "user is null").getName();
    // 使用 userId 进行服务逻辑处理
}
```

**关键点**：
- ✅ 后续消息不再需要携带 token
- ✅ Spring 框架自动从会话中获取用户身份
- ✅ 应用服务逻辑通过 `sha.getUser()` 获取用户身份

#### 8.3.6 ChannelInterceptor 注册

**注册位置**：`WebSocketStompConfig.java`

**注册代码**：
```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(authInterceptor);
}
```

**作用**：
- 将 `WebSocketAuthChannelInterceptor` 注册到 `clientInboundChannel`（客户端入站通道）
- 所有进入该通道的 STOMP 消息都会被拦截

---

### 8.4 关键代码解析

#### 8.4.1 WebSocketSessionManager 类结构

**文件位置**：`apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/WebSocketSessionManager.java`

**类定义**：
```java
@Slf4j
@Component
public class WebSocketSessionManager {
    private final SessionRegistry sessionRegistry;
    private final WebSocketDisconnectHelper disconnectHelper;
}
```

**关键依赖**：
- `SessionRegistry`：会话注册表，管理 WebSocket 会话
- `WebSocketDisconnectHelper`：WebSocket 断连工具类

#### 8.3.2 handleSessionConnect 方法

**方法签名**：
```java
@EventListener
public void handleSessionConnect(SessionConnectEvent event)
```

**完整实现**：
```java
@EventListener
public void handleSessionConnect(SessionConnectEvent event) {
    StompHeaderAccessor accessor = StompHeaderAccessor.wrap(event.getMessage());
    Principal principal = accessor.getUser();
    if (principal == null) {
        log.warn("收到 SessionConnectEvent 但缺少用户信息，session={}", accessor.getSessionId());
        return; // 未认证用户忽略
    }
    
    String sessionId = accessor.getSessionId();
    if (sessionId == null) {
        log.warn("SessionConnectEvent 缺少 sessionId，user={}", principal.getName());
        return;
    }
    
    String userId = principal.getName();
    
    // 从 JWT 中提取 loginSessionId（如果 Principal 是 JwtAuthenticationToken）
    String loginSessionId = extractLoginSessionId(principal);
    
    WebSocketSessionInfo info = WebSocketSessionInfo.builder()
            .sessionId(sessionId)
            .userId(userId)
            .loginSessionId(loginSessionId) // 可能为 null（向后兼容）
            .service("game-service")
            .build();
    
    List<WebSocketSessionInfo> kicked = sessionRegistry.registerWebSocketSessionEnforceSingle(info, 0);
    if (!CollectionUtils.isEmpty(kicked)) {
        log.info("用户 {} WebSocket 单点登录，新连接 {} 踢掉旧连接 {} 个, loginSessionId={}", 
                userId, sessionId, kicked.size(), loginSessionId);
        kicked.forEach(old -> {
            disconnectHelper.sendKickMessage(userId, old.getSessionId(), "账号已在其他终端登录");
            disconnectHelper.forceDisconnect(old.getSessionId());
        });
    } else {
        log.debug("用户 {} WebSocket 连接 {} 注册完成，无旧连接, loginSessionId={}", 
                userId, sessionId, loginSessionId);
    }
}
```

**关键逻辑**：
1. ✅ **提取用户信息**：从 `Principal` 中提取 `userId` 和 `sessionId`
   - **注意**：`Principal` 是在 STOMP CONNECT 时由 `WebSocketAuthChannelInterceptor` 设置的
   - Spring 框架从 WebSocket 会话中获取 `Principal`，并设置到消息 header 中
2. ✅ **提取 loginSessionId**：从 JWT 中提取（如果 Principal 是 `JwtAuthenticationToken`）
3. ✅ **构建会话信息**：创建 `WebSocketSessionInfo` 对象
4. ✅ **单点登录注册**：调用 `registerWebSocketSessionEnforceSingle()`，返回被踢掉的旧连接
5. ✅ **处理旧连接**：发送踢人通知并强制断开

#### 8.4.2 extractLoginSessionId 方法

**方法签名**：
```java
private String extractLoginSessionId(Principal principal)
```

**完整实现**：
```java
private String extractLoginSessionId(Principal principal) {
    if (principal instanceof JwtAuthenticationToken jwtAuth) {
        Jwt jwt = jwtAuth.getToken();
        // 优先使用 sid
        Object sidObj = jwt.getClaim("sid");
        if (sidObj != null) {
            String sid = sidObj.toString();
            if (sid != null && !sid.isBlank()) {
                return sid;
            }
        }
        // 如果没有 sid，尝试使用 session_state（向后兼容）
        Object sessionStateObj = jwt.getClaim("session_state");
        if (sessionStateObj != null) {
            String sessionState = sessionStateObj.toString();
            if (sessionState != null && !sessionState.isBlank()) {
                return sessionState;
            }
        }
    }
    return null;
}
```

**关键点**：
- ✅ **类型检查**：检查 Principal 是否是 `JwtAuthenticationToken`
- ✅ **优先使用 sid**：从 JWT claim 中提取 `sid`
- ✅ **向后兼容**：如果没有 `sid`，尝试使用 `session_state`
- ✅ **返回 null**：如果都无法提取，返回 null（向后兼容）

#### 8.4.3 handleSessionDisconnect 方法

**方法签名**：
```java
@EventListener
public void handleSessionDisconnect(SessionDisconnectEvent event)
```

**完整实现**：
```java
/**
 * 连接断开时清理会话。
 * 
 * 重要：此方法会检测到所有类型的断开，包括：
 * - 正常关闭浏览器/页签
 * - 强制关闭浏览器
 * - 网络中断
 * - 系统崩溃
 * 
 * 因为这是基于 TCP 连接断开的检测，比浏览器端事件更可靠。
 */
@EventListener
public void handleSessionDisconnect(SessionDisconnectEvent event) {
    String sessionId = event.getSessionId();
    if (sessionId == null) {
        log.warn("【WebSocket断开检测】收到 SessionDisconnectEvent 但缺少 sessionId");
        return;
    }
    
    // 1. 从 SessionRegistry 查询会话信息（包含 userId）
    WebSocketSessionInfo sessionInfo = sessionRegistry.getWebSocketSession(sessionId);
    String userId = null;
    String loginSessionId = null;
    
    if (sessionInfo != null) {
        userId = sessionInfo.getUserId();
        loginSessionId = sessionInfo.getLoginSessionId();
        log.info("【WebSocket断开检测】检测到断开: sessionId={}, userId={}, loginSessionId={}, service={}, connectedAt={}", 
                sessionId, userId, loginSessionId, sessionInfo.getService(), 
                sessionInfo.getConnectedAt() != null ? 
                    java.time.Instant.ofEpochMilli(sessionInfo.getConnectedAt()) : null);
    } else {
        // 如果无法从 SessionRegistry 获取，尝试从事件中提取
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(event.getMessage());
        Principal principal = accessor.getUser();
        if (principal != null) {
            userId = principal.getName();
            loginSessionId = extractLoginSessionId(principal);
            log.info("【WebSocket断开检测】检测到断开（从事件提取）: sessionId={}, userId={}, loginSessionId={}", 
                    sessionId, userId, loginSessionId);
        } else {
            log.warn("【WebSocket断开检测】检测到断开但无法获取用户信息: sessionId={}", sessionId);
        }
    }
    
    // 2. 记录断开信息（用于测试和调试）
    if (userId != null) {
        log.info("【WebSocket断开检测】玩家断开连接详情: userId={}, sessionId={}, loginSessionId={}, 断开时间={}", 
                userId, sessionId, loginSessionId, java.time.Instant.now());
    }
    
    // 3. 清理 WebSocket 会话注册
    sessionRegistry.unregisterWebSocketSession(sessionId);
    log.debug("【WebSocket断开检测】已清理会话注册: sessionId={}", sessionId);
}
```

**关键点**：
- ✅ **注销会话**：从 `SessionRegistry` 中注销会话
- ✅ **清理 Redis**：删除 Redis 中的会话记录
- ✅ **自动检测**：基于 TCP 连接断开检测，不依赖前端代码
- ✅ **支持多种断开场景**：正常关闭、强制关闭、网络中断、系统崩溃等
- ✅ **详细日志**：记录断开信息，便于调试和问题排查

**断开检测原理**：
- Spring WebSocket 基于底层 TCP 连接状态检测断开
- 当 TCP 连接断开时，自动触发 `SessionDisconnectEvent`
- 比浏览器端 `beforeunload` 或 `unload` 事件更可靠，因为：
  - 不依赖前端 JavaScript 执行
  - 即使浏览器崩溃也能检测到
  - 网络中断时也能及时检测

#### 8.4.4 WebSocketDisconnectHelper 类结构

**文件位置**：`apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/WebSocketDisconnectHelper.java`

**类定义**：
```java
@Slf4j
@Component
public class WebSocketDisconnectHelper {
    private static final String KICK_DESTINATION = "/queue/system.kick";
    
    private final SimpMessagingTemplate messagingTemplate;
    private final MessageChannel clientInboundChannel;
}
```

**关键依赖**：
- `SimpMessagingTemplate`：STOMP 消息模板，用于发送消息
- `clientInboundChannel`：客户端入站消息通道，用于强制断开连接

#### 8.3.6 sendKickMessage 方法

**方法签名**：
```java
public void sendKickMessage(String userId, String sessionId, String reason)
```

**完整实现**：
```java
public void sendKickMessage(String userId, String sessionId, String reason) {
    try {
        SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create(SimpMessageType.MESSAGE);
        headerAccessor.setSessionId(sessionId);
        headerAccessor.setLeaveMutable(true);
        
        messagingTemplate.convertAndSendToUser(
                userId,
                KICK_DESTINATION,
                Map.of("type", "WS_KICK", "reason", reason),
                headerAccessor.getMessageHeaders()
        );
    } catch (Exception e) {
        log.warn("发送踢人通知失败: userId={}, sessionId={}", userId, sessionId, e);
    }
}
```

**关键点**：
- ✅ **发送到用户队列**：使用 `convertAndSendToUser()` 发送到 `/user/{userId}/queue/system.kick`
- ✅ **消息格式**：`{"type": "WS_KICK", "reason": "..."}`
- ✅ **错误处理**：记录警告，不抛出异常

#### 8.3.7 forceDisconnect 方法

**方法签名**：
```java
public void forceDisconnect(String sessionId)
```

**完整实现**：
```java
public void forceDisconnect(String sessionId) {
    try {
        StompHeaderAccessor header = StompHeaderAccessor.create(StompCommand.DISCONNECT);
        header.setSessionId(sessionId);
        header.setLeaveMutable(true);
        clientInboundChannel.send(MessageBuilder.createMessage(new byte[0], header.getMessageHeaders()));
    } catch (Exception e) {
        log.warn("强制断开连接失败: sessionId={}", sessionId, e);
    }
}
```

**关键点**：
- ✅ **创建 DISCONNECT 命令**：使用 `StompCommand.DISCONNECT`
- ✅ **设置 sessionId**：指定要断开的会话 ID
- ✅ **发送到入站通道**：通过 `clientInboundChannel` 发送，触发 Spring WebSocket 断开连接

---

### 8.4 WebSocket 单点登录

#### 8.4.1 同一用户多连接处理

**问题**：
- 用户可能在多个设备上建立 WebSocket 连接
- 业务要求：同一用户在同一时刻只能有一个 WebSocket 连接

**解决方案**：
- **单点登录**：新连接建立时，踢掉旧连接
- **实现方式**：`registerWebSocketSessionEnforceSingle()` 方法

#### 8.4.2 新连接踢掉旧连接

**流程**：
```
用户 A 在设备 1 建立 WebSocket 连接
  ↓
registerWebSocketSessionEnforceSingle()
  ├─ 查询 userId="user-A" 的所有 WebSocket 会话 → []
  ├─ 没有旧连接，不踢掉
  └─ 注册新会话
  ↓
设备 1 连接成功

用户 A 在设备 2 建立 WebSocket 连接
  ↓
registerWebSocketSessionEnforceSingle()
  ├─ 查询 userId="user-A" 的所有 WebSocket 会话 → [设备1的会话]
  ├─ 删除设备1的会话（返回被踢掉的会话列表）
  ├─ 注册新会话（设备2）
  ├─ 发送踢人通知到设备1
  └─ 强制断开设备1的连接
  ↓
设备 2 连接成功，设备 1 被踢下线
```

**关键代码**：
```java
List<WebSocketSessionInfo> kicked = sessionRegistry.registerWebSocketSessionEnforceSingle(info, 0);
if (!CollectionUtils.isEmpty(kicked)) {
    kicked.forEach(old -> {
        disconnectHelper.sendKickMessage(userId, old.getSessionId(), "账号已在其他终端登录");
        disconnectHelper.forceDisconnect(old.getSessionId());
    });
}
```

---

### 8.5 本章总结

**核心功能**：
1. WebSocket 连接建立时注册会话
2. 从 JWT 中提取 `loginSessionId`
3. WebSocket 单点登录（新连接踢掉旧连接）
4. 连接断开时注销会话

**关键代码**：
- `WebSocketSessionManager.handleSessionConnect()`：连接建立处理
- `extractLoginSessionId()`：从 JWT 中提取 `loginSessionId`
- `WebSocketDisconnectHelper.sendKickMessage()`：发送踢人通知
- `WebSocketDisconnectHelper.forceDisconnect()`：强制断开连接

**单点登录机制**：
- ✅ 新连接建立时，查询该用户的所有 WebSocket 会话
- ✅ 删除旧会话，返回被踢掉的会话列表
- ✅ 发送踢人通知并强制断开旧连接



---

## 九、Kafka事件通知机制

> **本章目标**：理解 Kafka 事件通知机制的完整实现，掌握事件发布、消费、处理的每个步骤，以及如何基于 `loginSessionId` 精确断开 WebSocket 连接。

---

### 9.1 事件通知概述

#### 9.1.1 为什么需要事件通知

**问题**：
- Gateway 服务处理登录/登出
- xxx-Service 服务管理 WebSocket 连接
- 需要跨服务通知：登录/登出时，断开 WebSocket 连接

**解决方案**：
- **Kafka 事件通知**：Gateway 发布事件，xxx-Service 消费事件
- **解耦**：Gateway 不需要直接调用 xxx-Service
- **扩展性**：多个服务可以订阅同一事件

#### 9.1.2 Kafka 作为消息中间件

**优势**：
- ✅ **解耦**：发布者和订阅者解耦
- ✅ **可靠性**：消息持久化，支持重试
- ✅ **扩展性**：多个服务可以订阅同一事件
- ✅ **顺序性**：同一用户的事件按顺序处理

---

### 9.2 事件发布流程

#### 9.2.1 完整发布流程

```
登录/登出触发事件
  ↓
SessionEventPublisher.publishSessionInvalidated(event)
  ↓
  ├─ 1. 序列化事件为 JSON
  │     JSON.toJSONString(event)
  │
  ├─ 2. 发送到 Kafka topic
  │     kafkaTemplate.send(topic, userId, message)
  │     ├─ topic: session-invalidated
  │     ├─ key: userId（用于分区）
  │     └─ value: JSON 字符串
  │
  ├─ 3. 异步处理结果
  │     future.whenComplete()
  │     ├─ 成功 → 记录日志
  │     └─ 失败 → 记录错误日志
  │
  └─ 4. 事件发布完成
```

#### 9.2.2 事件发布场景

**场景1：登录时踢掉旧会话**
```java
// LoginSessionKickHandler.publishKickedEvent()
for (LoginSessionInfo kickedSession : kickedSessions) {
    String kickedLoginSessionId = kickedSession.getLoginSessionId();
    if (kickedLoginSessionId != null && !kickedLoginSessionId.isBlank()) {
        SessionInvalidatedEvent event = SessionInvalidatedEvent.of(
                userId,
                kickedLoginSessionId,
                SessionInvalidatedEvent.EventType.FORCE_LOGOUT,
                "单点登录：被新登录踢下线"
        );
        sessionEventPublisher.publishSessionInvalidated(event);
    }
}
```

**场景2：登出时失效会话**
```java
// SecurityConfig.publishSessionInvalidatedEvent()
SessionInvalidatedEvent event = SessionInvalidatedEvent.of(
        userId,
        loginSessionId,
        SessionInvalidatedEvent.EventType.LOGOUT,
        "用户主动登出"
);
sessionEventPublisher.publishSessionInvalidated(event);
```

---

### 9.3 事件消费流程

#### 9.3.1 完整消费流程

```
Kafka 消息到达
  ↓
SessionEventConsumer.consumeSessionInvalidated(message, ack)
  ↓
  ├─ 1. 解析 JSON 为 SessionInvalidatedEvent
  │     JSON.parseObject(message, SessionInvalidatedEvent.class)
  │
  ├─ 2. 遍历所有 SessionEventListener
  │     for (SessionEventListener listener : listeners)
  │
  ├─ 3. 调用 listener.onSessionInvalidated(event)
  │     ├─ SessionInvalidatedListener.onSessionInvalidated()
  │     ├─ 其他服务的监听器（如果有）
  │     └─ 处理异常，记录错误
  │
  ├─ 4. 检查所有监听器是否成功
  │     ├─ 全部成功 → 提交 offset (ack.acknowledge())
  │     └─ 部分失败 → 不提交 offset（消息会重新消费）
  │
  └─ 5. 事件消费完成
```

#### 9.3.2 监听器注册机制

**Spring 自动注入**：
```java
@Autowired(required = false)
public SessionEventConsumer(List<SessionEventListener> listeners) {
    this.listeners = listeners != null ? listeners : List.of();
    log.info("会话事件消费者初始化完成，发现 {} 个监听器", this.listeners.size());
}
```

**原理**：
- Spring 自动收集所有实现了 `SessionEventListener` 接口的 Bean
- 注入到 `SessionEventConsumer` 的 `listeners` 列表中
- 收到 Kafka 消息后，遍历所有监听器并调用

**示例**：
- `game-service` 的 `SessionInvalidatedListener`：断开 WebSocket 连接
- 其他应用服务的监听器：各自的服务逻辑（如清理会话、断开连接等）

---

### 9.4 关键代码解析

#### 9.4.1 SessionEventPublisher 类结构

**文件位置**：`libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/publisher/SessionEventPublisher.java`

**类定义**：
```java
@Slf4j
@Component
@ConditionalOnBean(name = "sessionKafkaTemplate")
public class SessionEventPublisher {
    private final KafkaTemplate<String, String> kafkaTemplate;
    
    @Value("${session.kafka.topic:session-invalidated}")
    private String topic;
}
```

**关键依赖**：
- `KafkaTemplate`：Kafka 消息模板
- `topic`：Kafka topic 名称（默认：`session-invalidated`）

#### 9.4.2 publishSessionInvalidated 方法

**方法签名**：
```java
public void publishSessionInvalidated(SessionInvalidatedEvent event)
```

**完整实现**：
```java
public void publishSessionInvalidated(SessionInvalidatedEvent event) {
    try {
        // 1. 序列化事件为 JSON
        String message = JSON.toJSONString(event);
        
        // 2. 发送到 Kafka topic（使用 userId 作为 key，用于分区）
        CompletableFuture<SendResult<String, String>> future = 
                kafkaTemplate.send(topic, event.getUserId(), message);
        
        // 3. 异步处理结果
        future.whenComplete((result, ex) -> {
            if (ex == null) {
                log.debug("会话失效事件发布成功: userId={}, offset={}", 
                        event.getUserId(), result.getRecordMetadata().offset());
            } else {
                log.error("会话失效事件发布失败: userId={}", event.getUserId(), ex);
            }
        });
    } catch (Exception e) {
        log.error("发布会话失效事件异常: userId={}", event.getUserId(), e);
    }
}
```

**关键点**：
- ✅ **使用 userId 作为 key**：确保同一用户的事件发送到同一分区，保证顺序性
- ✅ **异步发送**：使用 `CompletableFuture` 异步处理结果
- ✅ **错误处理**：记录错误日志，不抛出异常（不阻塞主流程）

#### 9.4.3 SessionEventConsumer 类结构

**文件位置**：`libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/listener/SessionEventConsumer.java`

**类定义**：
```java
@Slf4j
@Component
public class SessionEventConsumer {
    private final List<SessionEventListener> listeners;
    
    @KafkaListener(topics = "${session.kafka.topic:session-invalidated}", 
                   containerFactory = "sessionKafkaListenerContainerFactory")
    public void consumeSessionInvalidated(String message, Acknowledgment ack) {
        // ...
    }
}
```

**关键依赖**：
- `List<SessionEventListener>`：所有注册的监听器列表（Spring 自动注入）

#### 9.4.4 consumeSessionInvalidated 方法

**方法签名**：
```java
@KafkaListener(topics = "${session.kafka.topic:session-invalidated}", 
               containerFactory = "sessionKafkaListenerContainerFactory")
public void consumeSessionInvalidated(String message, Acknowledgment ack)
```

**完整实现**：
```java
public void consumeSessionInvalidated(String message, Acknowledgment ack) {
    try {
        // 1. 解析事件
        SessionInvalidatedEvent event = JSON.parseObject(message, SessionInvalidatedEvent.class);
        log.debug("收到会话失效事件: userId={}, eventType={}", event.getUserId(), event.getEventType());
        
        // 2. 如果没有监听器，记录警告但提交 offset
        if (listeners.isEmpty()) {
            log.warn("收到会话失效事件，但未发现任何 SessionEventListener 实现: userId={}", event.getUserId());
            ack.acknowledge();
            return;
        }
        
        // 3. 调用所有监听器
        boolean allSuccess = true;
        for (SessionEventListener listener : listeners) {
            try {
                listener.onSessionInvalidated(event);
            } catch (Exception e) {
                log.error("监听器处理会话失效事件失败: listener={}, userId={}", 
                        listener.getClass().getName(), event.getUserId(), e);
                allSuccess = false;
            }
        }
        
        // 4. 只有所有监听器都成功才提交 offset
        if (allSuccess) {
            ack.acknowledge();
            log.debug("会话失效事件处理完成并提交: userId={}", event.getUserId());
        } else {
            log.warn("会话失效事件部分监听器失败，不提交 offset: userId={}", event.getUserId());
            // 注意：不调用 ack.acknowledge()，消息会被重新消费
        }
        
    } catch (Exception e) {
        log.error("消费会话失效事件异常: message={}", message, e);
        // 解析失败也不提交，让消息重新消费
    }
}
```

**关键逻辑**：
1. ✅ **解析事件**：将 JSON 字符串解析为 `SessionInvalidatedEvent` 对象
2. ✅ **遍历监听器**：遍历所有注册的 `SessionEventListener` 并调用
3. ✅ **错误处理**：单个监听器失败不影响其他监听器，但记录错误
4. ✅ **手动提交 offset**：只有所有监听器都成功才提交 offset，否则消息会重新消费

#### 9.4.5 SessionInvalidatedEvent 事件结构

**文件位置**：`libs/session-common/src/main/java/com/gamehub/session/event/SessionInvalidatedEvent.java`

**类定义**：
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SessionInvalidatedEvent {
    private String userId;
    private String loginSessionId; // 可选字段
    private EventType eventType;
    private Long timestamp;
    private String reason; // 可选字段
    
    public enum EventType {
        LOGOUT,
        PASSWORD_CHANGED,
        USER_DISABLED,
        FORCE_LOGOUT,
        OTHER
    }
}
```

**工厂方法**：
```java
// 不包含 loginSessionId（向后兼容）
public static SessionInvalidatedEvent of(String userId, EventType eventType, String reason)

// 包含 loginSessionId（核心功能）
public static SessionInvalidatedEvent of(String userId, String loginSessionId, EventType eventType, String reason)
```

**关键字段**：
- ✅ **userId**：用户 ID（必需）
- ✅ **loginSessionId**：登录会话 ID（可选，用于精确查询）
- ✅ **eventType**：事件类型（必需）
- ✅ **timestamp**：事件触发时间（自动设置）
- ✅ **reason**：触发原因（可选）

> ✅ 事件模型被提取到 `session-common`，Kafka 模块只负责发布/消费；所有服务引用同一个 domain event，避免多处定义导致的序列化不兼容。

#### 9.4.6 SessionInvalidatedListener 实现

**文件位置**：`apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/SessionInvalidatedListener.java`

**类定义**：
```java
@Slf4j
@Component
public class SessionInvalidatedListener implements SessionEventListener {
    private final SessionRegistry sessionRegistry;
    private final WebSocketDisconnectHelper disconnectHelper;
}
```

**关键依赖**：
- `SessionRegistry`：查询 WebSocket 会话
- `WebSocketDisconnectHelper`：断开 WebSocket 连接

#### 9.4.7 onSessionInvalidated 方法

**方法签名**：
```java
@Override
public void onSessionInvalidated(SessionInvalidatedEvent event)
```

**完整实现**：
```java
@Override
public void onSessionInvalidated(SessionInvalidatedEvent event) {
    String userId = event.getUserId();
    String loginSessionId = event.getLoginSessionId();
    log.info("收到会话失效事件，开始断开用户 WebSocket 连接: userId={}, loginSessionId={}, eventType={}, reason={}", 
            userId, loginSessionId, event.getEventType(), event.getReason());
    
    List<WebSocketSessionInfo> gameServiceSessions;
    
    // 如果事件包含 loginSessionId，基于 loginSessionId 精确查询
    if (loginSessionId != null && !loginSessionId.isBlank()) {
        log.debug("基于 loginSessionId 查询 WebSocket 会话: loginSessionId={}", loginSessionId);
        List<WebSocketSessionInfo> wsSessions = sessionRegistry.getWebSocketSessionsByLoginSessionId(loginSessionId);
        // 过滤出 game-service 的会话
        gameServiceSessions = wsSessions.stream()
                .filter(session -> "game-service".equals(session.getService()))
                .toList();
    } else {
        // 如果事件只有 userId，基于 userId 查询（向后兼容）
        log.debug("基于 userId 查询 WebSocket 会话（向后兼容）: userId={}", userId);
        List<WebSocketSessionInfo> wsSessions = sessionRegistry.getWebSocketSessions(userId);
        // 过滤出 game-service 的会话
        gameServiceSessions = wsSessions.stream()
                .filter(session -> "game-service".equals(session.getService()))
                .toList();
    }
    
    if (CollectionUtils.isEmpty(gameServiceSessions)) {
        log.debug("用户 {} 在 game-service 中无 WebSocket 连接", userId);
        return;
    }
    
    log.info("用户 {} 在 game-service 中有 {} 个 WebSocket 连接，开始断开", userId, gameServiceSessions.size());
    
    // 生成踢人原因
    String reason = getKickReason(event);
    
    // 对每个会话执行断连操作
    for (WebSocketSessionInfo session : gameServiceSessions) {
        try {
            // 1. 发送踢人通知
            disconnectHelper.sendKickMessage(userId, session.getSessionId(), reason);
            
            // 2. 强制断开连接
            disconnectHelper.forceDisconnect(session.getSessionId());
            
            // 3. 从会话注册表中移除
            sessionRegistry.unregisterWebSocketSession(session.getSessionId());
            
            log.debug("已断开用户 {} 的 WebSocket 连接: sessionId={}", userId, session.getSessionId());
        } catch (Exception e) {
            log.error("断开用户 {} WebSocket 连接失败: sessionId={}", userId, session.getSessionId(), e);
        }
    }
    
    log.info("用户 {} 的所有 WebSocket 连接已断开: 共 {} 个", userId, gameServiceSessions.size());
}
```

**关键逻辑**：
1. ✅ **提取事件信息**：从事件中提取 `userId` 和 `loginSessionId`
2. ✅ **精确查询**：如果事件包含 `loginSessionId`，基于 `loginSessionId` 查询（精确）
3. ✅ **向后兼容**：如果事件只有 `userId`，基于 `userId` 查询（向后兼容）
4. ✅ **过滤服务**：只处理 `game-service` 的会话
5. ✅ **断开连接**：发送踢人通知并强制断开
6. ✅ **清理注册表**：从 `SessionRegistry` 中移除会话

#### 9.4.8 getKickReason 方法

**方法签名**：
```java
private String getKickReason(SessionInvalidatedEvent event)
```

**完整实现**：
```java
private String getKickReason(SessionInvalidatedEvent event) {
    if (event.getReason() != null && !event.getReason().isEmpty()) {
        return event.getReason();
    }
    
    return switch (event.getEventType()) {
        case LOGOUT -> "用户已登出";
        case PASSWORD_CHANGED -> "密码已修改，请重新登录";
        case USER_DISABLED -> "账号已被禁用";
        case FORCE_LOGOUT -> "管理员强制下线";
        case OTHER -> "会话已失效";
    };
}
```

**关键点**：
- ✅ **优先使用事件原因**：如果事件包含 `reason`，直接使用
- ✅ **根据事件类型生成**：如果没有 `reason`，根据 `eventType` 生成默认原因

#### 9.4.9 Keycloak Webhook 通知（注册同步）

Kafka 事件解决的是“某个 loginSession 失效后如何通知各服务”。除此之外，还需要知道 Keycloak 自身的用户事件（注册、禁用等）。目前我们通过官方的 webhook-http 插件打通：

1. **Keycloak 侧配置**  
   - 在 `docker-compose.yml` 中为 Keycloak 设置 `WEBHOOK_HTTP_BASE_PATH=http://system-service:8080/internal/keycloak/events`；  
   - 在 Realm 的 `Events → Event Listeners` 勾选 `webhook-http`，即可把 REGISTER/LOGIN/LOGOUT 等事件推送到 system-service。
2. **system-service 监听端点**  
   - `apps/system-service/src/main/java/com/gamehub/systemservice/controller/internal/KeycloakEventController.java` 暴露 `/internal/keycloak/events`，校验签名后记录 Keycloak 事件；  
   - 目前重点处理 `REGISTER`，在收到新用户注册事件时调用 `KeycloakAdminClient` 拉取 profile，把昵称等信息同步到平台库。
3. **与会话事件协同**  
   - Webhook 通道强调“用户状态变化”，Kafka 通道强调“会话状态变化”；  
   - 未来如果监听 PASSWORD_UPDATE / USER_DISABLED，只需在 controller 内部发布 `SessionInvalidatedEvent` 或调用 `KeycloakSsoLogoutService` 即可实现“Keycloak 管理操作 → 业务会话失效”的闭环。

---

### 9.5 基于 loginSessionId 的精确查询

#### 9.5.1 为什么需要精确查询

**问题**：
- 如果只基于 `userId` 查询，会断开该用户的所有 WebSocket 连接
- 但实际只需要断开特定 `loginSessionId` 的连接

**示例**：
```
用户 A 在设备 1 登录（loginSessionId="sid-001"）
  ├─ 建立 WebSocket 连接 1

用户 A 在设备 2 登录（loginSessionId="sid-002"）
  ├─ 建立 WebSocket 连接 2
  ├─ 设备 1 的登录会话被标记为 KICKED
  └─ 发布事件（loginSessionId="sid-001"）

如果只基于 userId 查询：
  → 会断开连接 1 和连接 2（错误！）

如果基于 loginSessionId 查询：
  → 只断开连接 1（正确！）
```

#### 9.5.2 精确查询实现

**代码位置**：`SessionInvalidatedListener.onSessionInvalidated()`

**实现逻辑**：
```java
if (loginSessionId != null && !loginSessionId.isBlank()) {
    // 基于 loginSessionId 精确查询
    List<WebSocketSessionInfo> wsSessions = 
            sessionRegistry.getWebSocketSessionsByLoginSessionId(loginSessionId);
    gameServiceSessions = wsSessions.stream()
            .filter(session -> "game-service".equals(session.getService()))
            .toList();
} else {
    // 基于 userId 查询（向后兼容）
    List<WebSocketSessionInfo> wsSessions = sessionRegistry.getWebSocketSessions(userId);
    gameServiceSessions = wsSessions.stream()
            .filter(session -> "game-service".equals(session.getService()))
            .toList();
}
```

**关键点**：
- ✅ **优先使用 loginSessionId**：如果事件包含 `loginSessionId`，使用精确查询
- ✅ **向后兼容**：如果事件只有 `userId`，使用 `userId` 查询

---

### 9.6 事件处理流程图

```
用户登出
  ↓
SecurityConfig.publishSessionInvalidatedEvent()
  ↓
SessionEventPublisher.publishSessionInvalidated()
  ↓
Kafka 发送消息（topic: session-invalidated, key: userId）
  ↓
SessionEventConsumer.consumeSessionInvalidated()
  ↓
遍历所有 SessionEventListener
  ↓
SessionInvalidatedListener.onSessionInvalidated()
  ├─ 基于 loginSessionId 查询 WebSocket 会话
  ├─ 过滤出 game-service 的会话
  ├─ 遍历所有会话
  │     ├─ 发送踢人通知
  │     ├─ 强制断开连接
  │     └─ 清理 SessionRegistry
  └─ 所有监听器成功 → 提交 offset
```

---

### 9.7 本章总结

**核心功能**：
1. 事件发布：Gateway 发布会话失效事件到 Kafka
2. 事件消费：Game-Service 消费事件并处理
3. 精确查询：基于 `loginSessionId` 精确断开 WebSocket 连接
4. 监听器机制：支持多个服务订阅同一事件

**关键代码**：
- `SessionEventPublisher.publishSessionInvalidated()`：发布事件
- `SessionEventConsumer.consumeSessionInvalidated()`：消费事件
- `SessionInvalidatedListener.onSessionInvalidated()`：处理事件
- `SessionInvalidatedEvent`：事件结构

**事件流程**：
- ✅ Gateway 发布事件（包含 `loginSessionId`）
- ✅ Kafka 消息队列（解耦、可靠）
- ✅ Game-Service 消费事件
- ✅ 基于 `loginSessionId` 精确查询 WebSocket 会话
- ✅ 断开连接并清理注册表



---

## 十、SessionRegistry核心实现

> **本章目标**：理解 SessionRegistry 的核心实现，掌握 Redis 存储结构、双索引设计、会话状态管理等关键机制。

---

### 10.1 SessionRegistry 概述

#### 10.1.1 统一会话注册表

**职责**：
- 记录/查询/清理"登录会话（JWT/Token）"
- 记录/查询/清理"WebSocket 长连接会话"
- 提供聚合视图与批量清理能力（用于后台"强制下线"）

**存储**：
- 全部基于 Redis
- 使用 JSON 序列化存储会话信息

#### 10.1.2 核心功能

**登录会话管理**：

- 注册登录会话
- 单点登录（后连踢前）
- 查询会话（按 sessionId、loginSessionId、userId）
- 更新会话状态
- 注销会话

**WebSocket 会话管理**：
- 注册 WebSocket 会话
- 单点 WebSocket（后连踢前）
- 查询会话（按 sessionId、userId、loginSessionId）
- 注销会话

---

### 10.2 Redis 存储结构

#### 10.2.1 登录会话存储

**键空间设计**：

```
Key 1: session:login:user:{userId}
Type: Set
Members: [sessionId1, sessionId2, ...]
TTL: 与 Key 2 一致
用途: 快速查询用户的所有登录会话

Key 2: session:login:token:{sessionId}
Type: String
Value: LoginSessionInfo JSON
TTL: token 剩余有效期（或默认 12 小时）
用途: 按 sessionId（jti）查询会话详情（向后兼容）

Key 3: session:login:loginSession:{loginSessionId}
Type: String
Value: LoginSessionInfo JSON
TTL: token 剩余有效期（或默认 12 小时）
用途: 按 loginSessionId（sid）查询会话详情（核心）
```

**示例**：
```
session:login:user:user-123 → Set["jti-abc123", "jti-def456"]

session:login:token:jti-abc123 → {
  "sessionId": "jti-abc123",
  "loginSessionId": "sid-xyz789",
  "userId": "user-123",
  "status": "ACTIVE",
  "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "issuedAt": 1704067200000,
  "expiresAt": 1704070800000,
  "attributes": {
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0..."
  }
}

session:login:loginSession:sid-xyz789 → {
  "sessionId": "jti-abc123",
  "loginSessionId": "sid-xyz789",
  "userId": "user-123",
  "status": "ACTIVE",
  ...
}
```

#### 10.2.2 WebSocket 会话存储

**键空间设计**：

```
Key 1: session:ws:user:{userId}
Type: Set
Members: [sessionId1, sessionId2, ...]
TTL: 与 Key 2 一致
用途: 快速查询用户的所有 WebSocket 会话

Key 2: session:ws:session:{sessionId}
Type: String
Value: WebSocketSessionInfo JSON
TTL: 默认 24 小时
用途: 按 sessionId 查询 WebSocket 会话详情
```

**示例**：
```
session:ws:user:user-123 → Set["ws-session-001", "ws-session-002"]

session:ws:session:ws-session-001 → {
  "sessionId": "ws-session-001",
  "userId": "user-123",
  "loginSessionId": "sid-xyz789",
  "service": "game-service",
  "connectedAt": 1704067200000,
  "attributes": {}
}
```

---

### 10.3 核心方法实现

#### 10.3.1 registerLoginSession 方法

**方法签名**：
```java
public void registerLoginSession(LoginSessionInfo sessionInfo, long ttlSeconds)
```

**实现逻辑**：
```java
public void registerLoginSession(LoginSessionInfo sessionInfo, long ttlSeconds) {
    // 1. 参数校验
    Objects.requireNonNull(sessionInfo, "sessionInfo must not be null");
    requireText(sessionInfo.getSessionId(), "sessionId");
    requireText(sessionInfo.getUserId(), "userId");
    
    // 2. 设置默认值
    if (sessionInfo.getIssuedAt() == null) {
        sessionInfo.setIssuedAt(Instant.now().toEpochMilli());
    }
    if (sessionInfo.getAttributes() == null) {
        sessionInfo.setAttributes(new HashMap<>());
    }
    if (sessionInfo.getStatus() == null) {
        sessionInfo.setStatus(SessionStatus.ACTIVE);
    }
    
    // 3. 计算 TTL
    Duration ttl = resolveTtl(ttlSeconds, DEFAULT_LOGIN_TTL);
    
    // 4. 构建 Key
    String userKey = LOGIN_USER_KEY_PREFIX + sessionInfo.getUserId();
    String sessionKey = LOGIN_SESSION_KEY_PREFIX + sessionInfo.getSessionId();
    String sessionJson = JSON.toJSONString(sessionInfo);
    
    // 5. 存储（按 sessionId）
    redis.opsForSet().add(userKey, sessionInfo.getSessionId());
    redis.opsForValue().set(sessionKey, sessionJson, ttl);
    
    // 6. 如果提供了 loginSessionId，同时按 loginSessionId 存储（双索引）
    if (sessionInfo.getLoginSessionId() != null && !sessionInfo.getLoginSessionId().isBlank()) {
        String loginSessionKey = LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX + sessionInfo.getLoginSessionId();
        redis.opsForValue().set(loginSessionKey, sessionJson, ttl);
    }
}
```

**关键点**：
- ✅ **双索引存储**：同时按 `sessionId` 和 `loginSessionId` 存储
- ✅ **用户索引**：维护用户的所有会话 ID 集合
- ✅ **自动设置默认值**：状态默认为 ACTIVE

#### 10.3.2 registerLoginSessionEnforceSingle 方法

**方法签名**：
```java
public List<LoginSessionInfo> registerLoginSessionEnforceSingle(LoginSessionInfo sessionInfo, long ttlSeconds)
```

**实现逻辑**：
```java
public List<LoginSessionInfo> registerLoginSessionEnforceSingle(LoginSessionInfo sessionInfo, long ttlSeconds) {
    // 1. 获取该用户的所有 ACTIVE 会话
    List<LoginSessionInfo> activeSessions = getActiveLoginSessions(sessionInfo.getUserId());
    
    // 2. 将旧会话标记为 KICKED（后续会在 blacklistKickedSessions() 中删除）
    List<LoginSessionInfo> kicked = new ArrayList<>();
    for (LoginSessionInfo oldSession : activeSessions) {
        // 跳过自己（如果新会话的 loginSessionId 与旧会话相同，说明是同一登录会话的 token 刷新）
        if (sessionInfo.getLoginSessionId() != null 
                && sessionInfo.getLoginSessionId().equals(oldSession.getLoginSessionId())) {
            continue; // 跳过，不踢掉
        }
        
        // 更新状态为 KICKED
        updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
        oldSession.setStatus(SessionStatus.KICKED);
        kicked.add(oldSession);
    }
    
    // 3. 确保新会话状态为 ACTIVE
    sessionInfo.setStatus(SessionStatus.ACTIVE);
    
    // 4. 登记当前会话
    registerLoginSession(sessionInfo, ttlSeconds);
    
    return kicked;
}
```

**关键逻辑**：
1. ✅ **查询 ACTIVE 会话**：只查询该 `userId` 的 ACTIVE 会话
2. ✅ **跳过同一 loginSessionId**：token 刷新场景，不踢掉自己
3. ✅ **标记为 KICKED**：旧会话标记为 KICKED（后续会在 `blacklistKickedSessions()` 中删除）
4. ✅ **注册新会话**：新会话状态为 ACTIVE

#### 10.3.3 getLoginSessionByLoginSessionId 方法

**方法签名**：
```java
public LoginSessionInfo getLoginSessionByLoginSessionId(String loginSessionId)
```

**实现逻辑**：
```java
public LoginSessionInfo getLoginSessionByLoginSessionId(String loginSessionId) {
    if (loginSessionId == null || loginSessionId.isBlank()) {
        return null;
    }
    
    // 直接从 loginSessionId 索引查询（O(1) 时间复杂度）
    String json = redis.opsForValue().get(LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX + loginSessionId);
    if (json == null) {
        return null;
    }
    
    try {
        LoginSessionInfo info = JSON.parseObject(json, LoginSessionInfo.class);
        // 向后兼容：如果状态为 null，默认为 ACTIVE
        if (info != null && info.getStatus() == null) {
            info.setStatus(SessionStatus.ACTIVE);
        }
        return info;
    } catch (Exception ex) {
        log.warn("反序列化 LoginSessionInfo 失败: loginSessionId={}", loginSessionId, ex);
        return null;
    }
}
```

**关键点**：
- ✅ **O(1) 查询**：直接从 `loginSessionId` 索引查询，性能高
- ✅ **向后兼容**：如果状态为 null，默认为 ACTIVE

#### 10.3.4 updateSessionStatus 方法

**方法签名**：
```java
public void updateSessionStatus(String sessionId, SessionStatus status)
```

**实现逻辑**：
```java
public void updateSessionStatus(String sessionId, SessionStatus status) {
    if (sessionId == null || sessionId.isBlank() || status == null) {
        return;
    }
    
    // 1. 获取会话信息
    LoginSessionInfo session = getLoginSession(sessionId);
    if (session == null) {
        log.warn("更新会话状态失败：会话不存在: sessionId={}", sessionId);
        return;
    }
    
    // 2. 更新状态
    session.setStatus(status);
    String sessionJson = JSON.toJSONString(session);
    
    // 3. 计算剩余 TTL
    Duration ttl = DEFAULT_LOGIN_TTL;
    if (session.getExpiresAt() != null && session.getExpiresAt() > 0) {
        long remainingSeconds = (session.getExpiresAt() - Instant.now().toEpochMilli()) / 1000;
        if (remainingSeconds > 0) {
            ttl = Duration.ofSeconds(remainingSeconds);
        }
    }
    
    // 4. 更新按 sessionId 存储的数据
    String sessionKey = LOGIN_SESSION_KEY_PREFIX + sessionId;
    redis.opsForValue().set(sessionKey, sessionJson, ttl);
    
    // 5. 如果存在 loginSessionId，同时更新按 loginSessionId 存储的数据（双索引同步）
    if (session.getLoginSessionId() != null && !session.getLoginSessionId().isBlank()) {
        String loginSessionKey = LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX + session.getLoginSessionId();
        redis.opsForValue().set(loginSessionKey, sessionJson, ttl);
    }
}
```

**关键点**：
- ✅ **双索引同步**：同时更新按 `sessionId` 和 `loginSessionId` 存储的数据
- ✅ **TTL 计算**：使用剩余有效期作为 TTL

---

### 10.4 双索引设计

#### 10.4.1 为什么需要双索引

**问题**：
- 需要按 `sessionId`（jti）查询（向后兼容）
- 需要按 `loginSessionId`（sid）查询（核心功能）

**解决方案**：
- **双索引**：同时按 `sessionId` 和 `loginSessionId` 存储
- **同步更新**：更新时同时更新两个索引

#### 10.4.2 sessionId 索引

**用途**：

- 向后兼容旧代码
- 按 `sessionId`（jti）查询会话

**Key 格式**：
```
session:login:token:{sessionId}
```

**查询方法**：
```java
public LoginSessionInfo getLoginSession(String sessionId)
```

#### 10.4.3 loginSessionId 索引

**用途**：
- 核心功能：按 `loginSessionId`（sid）查询会话
- JWT 校验时查询会话状态
- 单点登录时查询会话

**Key 格式**：
```
session:login:loginSession:{loginSessionId}
```

**查询方法**：
```java
public LoginSessionInfo getLoginSessionByLoginSessionId(String loginSessionId)
```

#### 10.4.4 双索引同步

**写入时**：
```java
// 同时写入两个索引
redis.opsForValue().set(sessionKey, sessionJson, ttl); // sessionId 索引
redis.opsForValue().set(loginSessionKey, sessionJson, ttl); // loginSessionId 索引
```

**更新时**：
```java
// 同时更新两个索引
redis.opsForValue().set(sessionKey, sessionJson, ttl); // sessionId 索引
redis.opsForValue().set(loginSessionKey, sessionJson, ttl); // loginSessionId 索引
```

**删除时**：
```java
// 同时删除两个索引
redis.delete(sessionKey); // sessionId 索引
redis.delete(loginSessionKey); // loginSessionId 索引
```

#### 10.4.5 refreshLoginSession 方法

**方法签名**：
```java
public void refreshLoginSession(LoginSessionInfo sessionInfo, String previousSessionId, long ttlSeconds)
```

**用途**：
- Token 刷新时，`jti` 会变化，需要更新 SessionRegistry 中的 `sessionId`
- 删除旧的 `sessionId` 记录，添加新的 `sessionId` 记录
- 保持 `loginSessionId` 不变，确保会话关联正确

**实现逻辑**：
```java
public void refreshLoginSession(LoginSessionInfo sessionInfo, String previousSessionId, long ttlSeconds) {
    // 1. 如果 previousSessionId 与新的 sessionId 不同，删除旧的记录
    if (previousSessionId != null && !previousSessionId.equals(sessionInfo.getSessionId())) {
        redis.opsForSet().remove(LOGIN_USER_KEY_PREFIX + userId, previousSessionId);
        redis.delete(LOGIN_SESSION_KEY_PREFIX + previousSessionId);
    }
    
    // 2. 添加新的 sessionId 记录
    Duration ttl = resolveTtl(ttlSeconds, DEFAULT_LOGIN_TTL);
    String userKey = LOGIN_USER_KEY_PREFIX + sessionInfo.getUserId();
    String sessionKey = LOGIN_SESSION_KEY_PREFIX + sessionInfo.getSessionId();
    String sessionJson = JSON.toJSONString(sessionInfo);
    
    redis.opsForSet().add(userKey, sessionInfo.getSessionId());
    redis.opsForValue().set(sessionKey, sessionJson, ttl);
    
    // 3. 更新 loginSessionId 索引（保持 loginSessionId 不变）
    if (sessionInfo.getLoginSessionId() != null && !sessionInfo.getLoginSessionId().isBlank()) {
        String loginSessionKey = LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX + sessionInfo.getLoginSessionId();
        redis.opsForValue().set(loginSessionKey, sessionJson, ttl);
    }
}
```

**关键点**：
- ✅ **删除旧记录**：删除旧的 `sessionId` 记录（从用户集合和会话详情中删除）
- ✅ **添加新记录**：添加新的 `sessionId` 记录
- ✅ **更新 loginSessionId 索引**：更新按 `loginSessionId` 存储的数据（保持 `loginSessionId` 不变）
- ✅ **TTL 计算**：使用 `refresh_token` 的过期时间计算 TTL

**使用场景**：
- TokenController 检测到 token 刷新时调用
- 确保 SessionRegistry 中的会话信息与当前 token 一致

---

### 10.5 本章总结

**核心功能**：
1. 统一会话注册表（登录会话 + WebSocket 会话）
2. 双索引设计（sessionId + loginSessionId）
3. 单点登录（后连踢前）
4. 会话状态管理

**存储结构**：
- 登录会话：按 `sessionId` 和 `loginSessionId` 双索引
- WebSocket 会话：按 `sessionId` 索引
- 用户索引：维护用户的所有会话 ID 集合

**关键方法**：
- `registerLoginSession()`：注册登录会话
- `registerLoginSessionEnforceSingle()`：单点登录注册
- `getLoginSessionByLoginSessionId()`：按 loginSessionId 查询
- `updateSessionStatus()`：更新会话状态
- `refreshLoginSession()`：刷新登录会话（token 刷新时更新 sessionId）



---

## 十一、JWT黑名单机制

> **本章目标**：理解 JWT 黑名单机制，掌握如何立即失效已撤销的 token，以及黑名单的存储设计和 TTL 管理。

---

### 11.1 黑名单概述

#### 11.1.1 为什么需要黑名单

**问题**：
- JWT 是无状态的，一旦签发就无法撤销
- 用户登出后，token 仍然有效（直到过期）
- 用户在其他设备登录后，旧设备的 token 仍然有效

**解决方案**：
- **黑名单机制**：将被撤销的 token 加入黑名单
- JWT 校验时，先检查黑名单
- 如果 token 在黑名单中，拒绝访问

#### 11.1.2 黑名单的作用

**功能**：
- ✅ **立即失效 token**：登出时立即失效 token
- ✅ **单点登录支持**：新登录时，立即失效旧 token
- ✅ **安全性**：防止已撤销的 token 被继续使用

---

### 11.2 代码调用链路（黑名单）

#### 11.2.1 加入黑名单

```
登录时踢掉旧会话
  ↓
LoginSessionKickHandler.blacklistKickedSessions()
  ↓
JwtBlacklistService.addToBlacklist(token, ttl)
  ↓
Redis SET jwt:blacklist:{token} "1" EX {ttl}
  ↓
黑名单记录创建完成
```

#### 11.2.2 检查黑名单

```
JWT 校验时
  ↓
JwtDecoderConfig.jwtDecoder()
  ↓
JwtBlacklistService.isBlacklisted(token)
  ↓
Redis EXISTS jwt:blacklist:{token}
  ├─ 存在 → 返回 true（命中黑名单）
  └─ 不存在 → 返回 false（未命中）
  ↓
命中黑名单 → 抛出 JwtException("Token has been revoked")
未命中 → 继续后续校验
```

---

### 11.3 关键代码解析

#### 11.3.1 JwtBlacklistService 类结构

**文件位置**：`apps/gateway/src/main/java/com/gamehub/gateway/service/JwtBlacklistService.java`

**类定义**：
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class JwtBlacklistService {
    private static final String BLACKLIST_KEY_PREFIX = "jwt:blacklist:";
    private static final long DEFAULT_TTL_SECONDS = 3600;
    
    private final ReactiveStringRedisTemplate redisTemplate;
}
```

**关键依赖**：
- `ReactiveStringRedisTemplate`：Redis 操作模板（响应式）

#### 11.3.2 addToBlacklist 方法

**方法签名**：
```java
public Mono<Void> addToBlacklist(String token, long expiresInSeconds)
```

**完整实现**：
```java
public Mono<Void> addToBlacklist(String token, long expiresInSeconds) {
    if (token == null || token.isBlank()) {
        return Mono.empty();
    }
    
    // 计算 TTL（使用 token 剩余有效期，兜底 1 小时）
    long ttl = expiresInSeconds > 0 ? expiresInSeconds : DEFAULT_TTL_SECONDS;
    
    // 写入 Redis
    return redisTemplate.opsForValue()
            .set(buildKey(token), "1", Duration.ofSeconds(ttl))
            .doOnSuccess(success -> {
                if (Boolean.FALSE.equals(success)) {
                    log.warn("Redis set 返回 false，token={}", token);
                }
            })
            .doOnError(ex -> log.error("写入 JWT 黑名单失败", ex))
            .onErrorResume(ex -> Mono.empty())
            .then();
}
```

**关键点**：
- ✅ **TTL 计算**：使用 token 剩余有效期作为黑名单 TTL
- ✅ **兜底策略**：如果 TTL <= 0，使用默认 1 小时
- ✅ **错误处理**：记录错误，不抛出异常（不阻塞主流程）

#### 11.3.3 isBlacklisted 方法

**方法签名**：
```java
public Mono<Boolean> isBlacklisted(String token)
```

**完整实现**：
```java
public Mono<Boolean> isBlacklisted(String token) {
    if (token == null || token.isBlank()) {
        return Mono.just(false);
    }
    
    return redisTemplate.hasKey(buildKey(token))
            .onErrorResume(ex -> {
                log.error("查询 JWT 黑名单失败，默认视为命中", ex);
                return Mono.just(true); // 出错时默认视为命中，宁可拒绝也不放过
            });
}
```

**关键点**：
- ✅ **O(1) 查询**：使用 `hasKey()` 查询，性能高
- ✅ **安全策略**：出错时默认视为命中，宁可拒绝也不放过

#### 11.3.4 buildKey 方法

**方法签名**：
```java
private static String buildKey(String token)
```

**实现逻辑**：
```java
private static String buildKey(String token) {
    return BLACKLIST_KEY_PREFIX + token;
}
```

**Key 格式**：
```
jwt:blacklist:{完整的token字符串}
```

**示例**：
```
jwt:blacklist:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyLTEyMyIsImppdCI6Imp0aS1hYmMxMjMiLCJzaWQiOiJzaWQteHl6Nzg5IiwiaWF0IjoxNzA0MDY3MjAwLCJleHAiOjE3MDQwNzA4MDB9.signature
```

---

### 11.4 Redis 存储设计

#### 11.4.1 Key 设计

**Key 格式**：
```
jwt:blacklist:{完整的token字符串}
```

**特点**：
- ✅ **唯一性**：每个 token 对应一个唯一的 key
- ✅ **可读性**：key 中包含 token 前缀，便于识别

#### 11.4.2 Value 设计

**Value 格式**：
```
"1"
```

**特点**：
- ✅ **简单**：只需要标记存在即可，不需要存储额外信息
- ✅ **节省空间**：只存储一个字符

#### 11.4.3 TTL 设计

**TTL 计算**：
```java
long ttl = expiresInSeconds > 0 ? expiresInSeconds : DEFAULT_TTL_SECONDS;
```

**特点**：
- ✅ **自动过期**：使用 token 剩余有效期作为 TTL
- ✅ **自动清理**：token 过期后，黑名单记录自动删除
- ✅ **节省空间**：不需要手动清理过期的黑名单记录

**示例**：
```
Token 过期时间：2024-01-01 12:00:00
当前时间：2024-01-01 11:45:00
剩余时间：15 分钟 = 900 秒

加入黑名单：
  Redis SET jwt:blacklist:{token} "1" EX 900
```

---

### 11.5 黑名单使用场景

#### 11.5.1 场景1：登录时踢掉旧 token

**触发时机**：
- 用户在其他设备登录
- 旧设备的会话被删除，token 被加入黑名单

**代码位置**：
```java
// LoginSessionKickHandler.blacklistKickedSessions()
for (LoginSessionInfo kickedSession : kickedSessions) {
    // 1. 从 SessionRegistry 删除旧会话
    sessionRegistry.unregisterLoginSession(kickedSession.getSessionId());
    
    // 2. 将旧 token 加入黑名单
    if (kickedSession.getToken() != null && !kickedSession.getToken().isBlank()) {
        long ttlSeconds = (kickedSession.getExpiresAt() - Instant.now().toEpochMilli()) / 1000;
        blacklistService.addToBlacklist(kickedSession.getToken(), ttlSeconds);
    }
}
```

**效果**：
- 旧设备的 token 立即失效
- 旧设备使用 token 访问资源时，会被拒绝

#### 11.5.2 场景2：登出时失效 token

**触发时机**：
- 用户主动登出
- 当前 token 被加入黑名单

**代码位置**：
```java
// SecurityConfig.addTokenToBlacklist()
String token = client.getAccessToken().getTokenValue();
Instant expiresAt = client.getAccessToken().getExpiresAt();
long expiresIn = Duration.between(Instant.now(), expiresAt).getSeconds();
blacklistService.addToBlacklist(token, expiresIn);
```

**效果**：
- 登出后，token 立即失效
- 即使 token 未过期，也无法继续使用

#### 11.5.3 场景3：JWT 校验时检查黑名单

**触发时机**：
- 每次 JWT 校验时
- 先检查黑名单，再检查签名和状态

**代码位置**：
```java
// JwtDecoderConfig.jwtDecoder()
return token -> jwtBlacklistService.isBlacklisted(token)
        .flatMap(blacklisted -> {
            if (Boolean.TRUE.equals(blacklisted)) {
                return Mono.error(new JwtException("Token has been revoked"));
            }
            // 继续后续校验
        });
```

**效果**：
- 命中黑名单的 token 立即被拒绝
- 性能高（O(1) 查询）

---

### 11.6 性能考虑

#### 11.6.1 查询性能

**时间复杂度**：
- `isBlacklisted()`：O(1)（Redis `EXISTS` 操作）

**性能优化**：
- ✅ **最先检查**：黑名单检查放在最前面，性能最高
- ✅ **快速失败**：命中黑名单立即拒绝，不进行后续校验

#### 11.6.2 存储空间

**空间占用**：
- 每个 token 对应一个 key
- key 长度 = `jwt:blacklist:` 前缀长度 + token 长度
- value 只存储 `"1"`（1 字节）

**空间优化**：
- ✅ **自动过期**：使用 TTL，token 过期后自动删除
- ✅ **不需要手动清理**：Redis 自动清理过期的 key

#### 11.6.3 扩展性

**问题**：
- 如果 token 很长，key 也会很长
- 大量 token 会导致 Redis 内存占用增加

**解决方案**：
- ✅ **TTL 自动清理**：过期的 token 自动删除
- ✅ **Redis 内存管理**：使用 Redis 的内存淘汰策略
- ✅ **未来优化**：可以考虑使用 token 的 hash 值作为 key（减少 key 长度）

---

### 11.7 本章总结

**核心功能**：
1. 立即失效已撤销的 token
2. 支持单点登录（新登录踢掉旧 token）
3. 支持登出时失效 token

**存储设计**：
- Key：`jwt:blacklist:{完整的token字符串}`
- Value：`"1"`
- TTL：token 剩余有效期（自动过期）

**关键方法**：
- `addToBlacklist()`：加入黑名单
- `isBlacklisted()`：检查黑名单

**性能特点**：
- ✅ O(1) 查询性能
- ✅ 自动过期，节省空间
- ✅ 最先检查，快速失败



---

## 十二、完整数据流图

> **本章目标**：通过完整的数据流图，理解整个单点登录系统的数据流转过程，包括登录、JWT校验、WebSocket连接、登出等完整流程。

---

### 12.1 登录数据流

#### 12.1.1 完整登录数据流图

```
┌─────────┐
│  用户   │
└────┬────┘
     │ 1. 访问 /oauth2/authorization/keycloak
     ↓
┌─────────────────┐
│  Gateway        │
│  (Spring Security)│
└────┬────────────┘
     │ 2. 重定向到 Keycloak
     ↓
┌─────────────┐
│  Keycloak   │
│  (登录页面)  │
└────┬────────┘
     │ 3. 用户输入用户名密码
     ↓
┌─────────────┐
│  Keycloak   │
│  (验证用户)  │
└────┬────────┘
     │ 4. 生成授权码，重定向回 Gateway
     ↓
┌─────────────────┐
│  Gateway        │
│  (OAuth2 Client)│
└────┬────────────┘
     │ 5. 使用授权码换取 access_token
     ↓
┌─────────────┐
│  Keycloak   │
│  (Token端点) │
└────┬────────┘
     │ 6. 返回 access_token (包含 sid)
     ↓
┌─────────────────────────────────────┐
│  Gateway - LoginSessionKickHandler  │
└────┬────────────────────────────────┘
     │
     ├─ 7. 提取 JWT 信息
     │     ├─ userId (sub)
     │     ├─ sessionId (jti)
     │     └─ loginSessionId (sid)
     │
     ├─ 8. 构建 LoginSessionInfo
     │
     ├─ 9. 调用 registerLoginSessionEnforceSingle()
     │     ↓
     │  ┌──────────────────────┐
     │  │  SessionRegistry     │
     │  └────┬─────────────────┘
     │       │
     │       ├─ 9.1 查询该用户的所有 ACTIVE 会话
     │       │     ↓
     │       │  ┌──────┐
     │       │  │Redis │
     │       │  │查询  │
     │       │  └──────┘
     │       │
     │       ├─ 9.2 将旧会话标记为 KICKED
     │       │     ↓
     │       │  ┌──────┐
     │       │  │Redis │
     │       │  │更新  │
     │       │  └──────┘
     │       │
     │       └─ 9.3 注册新会话（状态=ACTIVE）
     │             ↓
     │          ┌──────┐
     │          │Redis │
     │          │存储  │
     │          └──────┘
     │
     ├─ 10. 删除旧会话并将 token 加入黑名单
     │      ↓
     │   ┌──────────────────┐
     │   │JwtBlacklistService│
     │   └────┬─────────────┘
     │        │
     │        └─ Redis SET jwt:blacklist:{token} "1" EX {ttl}
     │
     ├─ 11. 发布 SESSION_KICKED 事件
     │      ↓
     │   ┌──────────────────┐
     │   │SessionEventPublisher│
     │   └────┬─────────────┘
     │        │
     │        └─ Kafka 发送消息
     │              ↓
     │           ┌──────┐
     │           │Kafka │
     │           │Topic │
     │           └──────┘
     │
     └─ 12. 存储 loginSessionId 到 HTTP Session
           ↓
        ┌──────┐
        │Redis │
        │Session│
        └──────┘
```

#### 12.1.2 数据流转说明

**步骤1-6：OAuth2 授权码流程**
- Spring Security 自动处理
- 用户完成认证，获取 access_token

**步骤7-9：会话注册**
- 提取 JWT 信息
- 构建 `LoginSessionInfo`
- 调用 `registerLoginSessionEnforceSingle()` 实现单点登录

**步骤10：删除旧会话并加入黑名单**
- 从 SessionRegistry 中删除被踢掉的旧会话（`unregisterLoginSession()`）
- 将被踢掉的旧 token 加入黑名单（`addToBlacklist()`）
- 立即失效旧 token

**步骤11：事件发布**
- 发布 SESSION_KICKED 事件到 Kafka
- 通知各服务断开 WebSocket 连接

**步骤12：HTTP Session 存储**
- 存储 `loginSessionId` 到 HTTP Session
- 用于后续在 `TokenController` 中验证

---

### 12.2 JWT校验数据流

#### 12.2.1 完整JWT校验数据流图

```
┌─────────┐
│ 客户端  │
└────┬────┘
     │ 1. 请求携带 Authorization: Bearer {token}
     ↓
┌─────────────────┐
│  Gateway        │
│  (Spring Security)│
└────┬────────────┘
     │ 2. BearerTokenAuthenticationFilter
     ↓
┌──────────────────────┐
│  JwtDecoderConfig    │
│  jwtDecoder()        │
└────┬─────────────────┘
     │
     ├─ [第一层] 黑名单检查
     │     ↓
     │  ┌──────────────────┐
     │  │JwtBlacklistService│
     │  └────┬─────────────┘
     │       │
     │       └─ Redis EXISTS jwt:blacklist:{token}
     │             ├─ 存在 → 401 Unauthorized
     │             └─ 不存在 → 继续
     │
     ├─ [第二层] 签名校验
     │     ↓
     │  ┌──────────────────┐
     │  │NimbusReactiveJwtDecoder│
     │  └────┬─────────────┘
     │       │
     │       ├─ 验证签名（Keycloak 公钥）
     │       ├─ 验证过期时间（exp）
     │       ├─ 验证颁发者（iss）
     │       ├─ 验证受众（aud）
     │       ├─ 失败 → 401 Unauthorized
     │       └─ 成功 → 返回 Jwt 对象
     │
     └─ [第三层] 会话状态检查
           ↓
        ┌──────────────────────┐
        │checkSessionStatus()   │
        └────┬──────────────────┘
             │
             ├─ 提取 loginSessionId (sid)
             │
             ├─ 查询 SessionRegistry
             │     ↓
             │  ┌──────────────────┐
             │  │SessionRegistry  │
             │  └────┬────────────┘
             │       │
             │       └─ getLoginSessionByLoginSessionId(loginSessionId)
             │             ↓
             │          ┌──────┐
             │          │Redis │
             │          │查询  │
             │          └──────┘
             │
             ├─ 检查会话状态
             │     ├─ ACTIVE → 通过
             │     ├─ KICKED → 401 Unauthorized
             │     └─ EXPIRED → 401 Unauthorized
             │
             └─ 通过 → 创建 JwtAuthenticationToken
                   ↓
               请求继续处理
```

#### 12.2.2 三层校验说明

**第一层：黑名单检查**
- 最先执行，性能最高
- 立即拒绝已撤销的 token

**第二层：签名校验**
- Spring Security 自动完成
- 验证 token 的合法性

**第三层：会话状态检查**
- 核心机制
- 判断 loginSession 是否被踢

---

### 12.3 WebSocket连接数据流

#### 12.3.1 完整WebSocket连接数据流图

```
┌─────────┐
│ 客户端  │
└────┬────┘
     │ 1. 建立 WebSocket 连接（携带 JWT token）
     │    URL: /ws?access_token=xxx 或 Header: Authorization: Bearer xxx
     ↓
┌─────────────────┐
│  Gateway        │
│  WebSocketTokenFilter│
└────┬────────────┘
     │ 1.1 从 URL 参数提取 token，放入 Authorization header
     ↓
┌─────────────────┐
│  Game-Service   │
│  (Spring WebSocket)│
└────┬────────────┘
     │ 2. STOMP CONNECT 命令到达
     ↓
┌──────────────────────────┐
│  WebSocketAuthChannelInterceptor│
│  preSend()                │
└────┬─────────────────────┘
     │ 2.1 从 STOMP header 提取 token
     │ 2.2 验证 token（JwtDecoder）
     │ 2.3 设置用户身份到 WebSocket 会话
     │     accessor.setUser(JwtAuthenticationToken)
     │     ↓
     │     Spring 框架保存到会话存储：
     │     Session[sessionId] = Principal
     ↓
┌──────────────────────┐
│  WebSocketSessionManager│
│  handleSessionConnect()│
└────┬─────────────────┘
     │
     ├─ 3. 从 Principal 提取信息
     │     ├─ userId (principal.getName())
     │     ├─ sessionId (accessor.getSessionId())
     │     └─ loginSessionId (extractLoginSessionId(principal))
     │     **注意**：Principal 从 WebSocket 会话中获取（由拦截器设置）
     │
     ├─ 4. 构建 WebSocketSessionInfo
     │
     ├─ 5. 调用 registerWebSocketSessionEnforceSingle()
     │     ↓
     │  ┌──────────────────────┐
     │  │  SessionRegistry      │
     │  └────┬─────────────────┘
     │       │
     │       ├─ 5.1 查询该用户的所有 WebSocket 会话
     │       │     ↓
     │       │  ┌──────┐
     │       │  │Redis │
     │       │  │查询  │
     │       │  └──────┘
     │       │
     │       ├─ 5.2 删除旧会话（返回被踢掉的会话列表）
     │       │     ↓
     │       │  ┌──────┐
     │       │  │Redis │
     │       │  │删除  │
     │       │  └──────┘
     │       │
     │       └─ 5.3 注册新会话
     │             ↓
     │          ┌──────┐
     │          │Redis │
     │          │存储  │
     │          └──────┘
     │
     └─ 6. 处理被踢掉的旧连接
           ├─ 发送踢人通知
           │     ↓
           │  ┌──────────────────┐
           │  │WebSocketDisconnectHelper│
           │  └────┬────────────┘
           │       │
           │       └─ 发送到 /queue/system.kick
           │
           └─ 强制断开连接
                 ↓
              ┌──────────────────┐
              │WebSocketDisconnectHelper│
              └────┬─────────────┘
                   │
                   └─ 发送 DISCONNECT 命令
```

#### 12.3.2 WebSocket 认证流程说明

**认证流程**：
1. **Gateway 层**：`WebSocketTokenFilter` 从 URL 参数提取 token，放入 `Authorization` header
2. **拦截器层**：`WebSocketAuthChannelInterceptor` 在 STOMP CONNECT 时：
   - 从 STOMP header 提取 token
   - 验证 token（签名、过期等）
   - 通过 `accessor.setUser()` 设置用户身份到 WebSocket 会话
3. **会话存储**：Spring 框架将用户身份保存到会话存储中（以 `sessionId` 为 key）
4. **后续消息**：Spring 框架自动从会话中获取用户身份，设置到消息 header 中
5. **应用服务逻辑**：通过 `sha.getUser()` 获取用户身份

**关键点**：
- ✅ Token 只在 STOMP CONNECT 时使用一次
- ✅ 用户身份存储在 WebSocket 会话中
- ✅ 后续消息不再需要携带 token
- ✅ 应用服务逻辑从消息 header 中获取用户身份（Spring 框架已从会话中设置）

#### 12.3.3 WebSocket单点登录说明

**流程**：
1. 新连接建立时，查询该用户的所有 WebSocket 会话
2. 删除旧会话，返回被踢掉的会话列表
3. 注册新会话
4. 发送踢人通知并强制断开旧连接

---

### 12.4 登出数据流

#### 12.4.1 完整登出数据流图

```
┌─────────┐
│  用户   │
└────┬────┘
     │ 1. 访问 /logout
     ↓
┌─────────────────┐
│  Gateway        │
│  (Spring Security)│
└────┬────────────┘
     │ 2. Logout Filter
     ↓
┌─────────────────────────────────┐
│  SecurityConfig                 │
│  jwtBlacklistLogoutHandler()   │
└────┬────────────────────────────┘
     │
     ├─ 3. 获取 OAuth2AuthorizedClient
     │
     ├─ 4. 将 access_token 加入黑名单
     │      ↓
     │   ┌──────────────────┐
     │   │JwtBlacklistService│
     │   └────┬─────────────┘
     │        │
     │        └─ Redis SET jwt:blacklist:{token} "1" EX {ttl}
     │
     ├─ 5. 从 JWT 中提取 loginSessionId
     │
     ├─ 6. 发布 SESSION_INVALIDATED 事件
     │      ↓
     │   ┌──────────────────┐
     │   │SessionEventPublisher│
     │   └────┬─────────────┘
     │        │
     │        └─ Kafka 发送消息
     │              ↓
     │           ┌──────┐
     │           │Kafka │
     │           │Topic │
     │           └──────┘
     │
     └─ 7. 移除 OAuth2AuthorizedClient
           ↓
        ┌──────┐
        │Redis │
        │Session│
        └──────┘

同时（异步）：
┌──────┐
│Kafka │
│Topic │
└──┬───┘
   │ 8. 消息到达
   ↓
┌──────────────────────┐
│  SessionEventConsumer│
│  consumeSessionInvalidated()│
└────┬─────────────────┘
     │ 9. 遍历所有 SessionEventListener
     ↓
┌──────────────────────────────┐
│  SessionInvalidatedListener  │
│  onSessionInvalidated()      │
└────┬─────────────────────────┘
     │
     ├─ 10. 基于 loginSessionId 查询 WebSocket 会话
     │      ↓
     │   ┌──────────────────────┐
     │   │  SessionRegistry      │
     │   └────┬─────────────────┘
     │        │
     │        └─ getWebSocketSessionsByLoginSessionId(loginSessionId)
     │              ↓
     │           ┌──────┐
     │           │Redis │
     │           │查询  │
     │           └──────┘
     │
     ├─ 11. 遍历所有会话
     │      ├─ 发送踢人通知
     │      ├─ 强制断开连接
     │      └─ 清理 SessionRegistry
     │
     └─ 12. 所有监听器成功 → 提交 offset
```

#### 12.4.2 登出流程说明

**同步处理**：
1. 将 token 加入黑名单
2. 发布事件到 Kafka
3. 移除 OAuth2AuthorizedClient

**异步处理**：
1. Kafka 消息到达
2. 消费事件
3. 断开 WebSocket 连接

---

### 12.5 单点登录完整数据流

#### 12.5.1 用户A在设备1登录

```
设备 1 登录
  ↓
LoginSessionKickHandler
  ├─ 查询 userId="user-A" 的 ACTIVE 会话 → []
  ├─ 没有旧会话，不踢掉
  └─ 注册新会话（loginSessionId="sid-001", status=ACTIVE）
  ↓
设备 1 登录成功
```

#### 12.5.2 用户A在设备2登录（单点登录）

```
设备 2 登录
  ↓
LoginSessionKickHandler
  ├─ 查询 userId="user-A" 的 ACTIVE 会话 → [设备1的会话]
  ├─ 设备1的会话 loginSessionId="sid-001"
  ├─ 设备2的会话 loginSessionId="sid-002"
  ├─ loginSessionId 不同，需要踢掉设备1
  │
  ├─ 将设备1的会话标记为 KICKED
  │     ↓
  │  SessionRegistry.updateSessionStatus()
  │     ↓
  │  Redis 更新（双索引同步）
  │
  ├─ 删除设备1的会话，并将 token 加入黑名单
  │     ├─ SessionRegistry.unregisterLoginSession()（删除会话）
  │     └─ JwtBlacklistService.addToBlacklist()（加入黑名单）
  │         └─ Redis SET jwt:blacklist:{token1} "1" EX {ttl}
  │
  ├─ 发布 SESSION_KICKED 事件（loginSessionId="sid-001"）
  │     ↓
  │  SessionEventPublisher.publishSessionInvalidated()
  │     ↓
  │  Kafka 发送消息
  │
  └─ 注册新会话（设备2, loginSessionId="sid-002", status=ACTIVE）
  ↓
设备 2 登录成功

同时（异步）：
Kafka 消息到达
  ↓
SessionEventConsumer.consumeSessionInvalidated()
  ↓
SessionInvalidatedListener.onSessionInvalidated()
  ├─ 基于 loginSessionId="sid-001" 查询 WebSocket 会话
  ├─ 找到设备1的 WebSocket 连接
  ├─ 发送踢人通知
  ├─ 强制断开连接
  └─ 清理 SessionRegistry
  ↓
设备 1 的 WebSocket 连接被断开

同时（设备1后续请求）：
设备 1 使用 token1 访问资源
  ↓
JwtDecoderConfig.jwtDecoder()
  ├─ [第一层] 黑名单检查 → 命中 → 401 Unauthorized
  └─ 请求被拒绝
```

---

### 12.6 本章总结

**核心数据流**：
1. **登录数据流**：用户登录 → 会话注册 → 单点登录处理 → 黑名单 → 事件发布
2. **JWT校验数据流**：三层校验（黑名单 → 签名 → 状态）
3. **WebSocket连接数据流**：连接建立 → 会话注册 → 单点登录检查 → 踢掉旧连接
4. **登出数据流**：登出请求 → 黑名单 → 事件发布 → Kafka → WebSocket断连

**数据存储**：
- **Redis**：SessionRegistry、黑名单、HTTP Session
- **Kafka**：事件通知

**关键组件**：
- `LoginSessionKickHandler`：登录处理
- `JwtDecoderConfig`：JWT 校验
- `SessionRegistry`：会话管理
- `SessionEventPublisher`：事件发布
- `SessionInvalidatedListener`：事件处理



---

## 十三、关键设计决策

> **本章目标**：理解关键设计决策的原因和依据，掌握为什么选择 `sid` 作为 `loginSessionId`、为什么标记 KICKED 而不是删除、为什么需要 HTTP Session 存储、为什么需要三层校验。

---

### 13.1 为什么使用 sid 作为 loginSessionId

#### 13.1.1 sid 的稳定性

**问题**：为什么不能使用 `jti`（JWT ID）作为 `loginSessionId`？

**答案**：

**jti 的问题**：
- ⚠️ **不稳定**：token 刷新时，`jti` 可能变化（取决于 Keycloak 配置）
- ⚠️ **作用域小**：`jti` 只标识单个 token，不能标识整个登录会话
- ⚠️ **无法追踪**：无法追踪同一登录会话的所有 token

**sid 的优势**：
- ✅ **稳定不变**：在一次登录生命周期内，`sid` 保持不变
- ✅ **token 刷新不变**：即使 token 刷新，`sid` 仍然不变
- ✅ **作用域大**：`sid` 标识整个登录会话，可以关联所有 token
- ✅ **可追踪**：可以追踪整个登录会话的所有操作

**示例**：
```
用户登录
  Token 1: jti="jti-001", sid="sid-xyz789"
  ↓
Token 刷新
  Token 2: jti="jti-002", sid="sid-xyz789"  ← sid 不变！
  ↓
Token 再次刷新
  Token 3: jti="jti-003", sid="sid-xyz789"  ← sid 仍然不变！

所有 token 都共享同一个 sid="sid-xyz789"
```

#### 13.1.2 Keycloak 原生支持

**Keycloak 的 sid claim**：
- Keycloak 在 JWT 中自动包含 `sid` claim
- `sid` 是 Keycloak 的会话 ID，在整个登录生命周期内稳定不变
- 符合 OIDC 规范（OpenID Connect Session Management）

**代码实现**：
```java
// 从 JWT 中提取 sid
Object sidObj = jwt.getClaim("sid");
if (sidObj != null) {
    String sid = sidObj.toString();
    if (sid != null && !sid.isBlank()) {
        loginSessionId = sid; // 使用 sid
    }
}
```

#### 13.1.3 token 刷新时不变

**关键特性**：
- ✅ **登录时生成**：用户登录时，Keycloak 生成新的 `sid`
- ✅ **刷新时保持**：token 刷新时，`sid` 保持不变
- ✅ **登出时失效**：用户登出时，`sid` 失效

**实现原理**：
- Keycloak 的 `sid` 绑定到 Keycloak 的会话
- 只要 Keycloak 会话存在，`sid` 就保持不变
- token 刷新只是生成新的 token，不改变 Keycloak 会话

---

### 13.2 为什么先标记 KICKED 再删除

#### 13.2.1 两阶段处理机制

**处理流程**：
1. **第一阶段**：`registerLoginSessionEnforceSingle()` 将旧会话标记为 KICKED
2. **第二阶段**：`blacklistKickedSessions()` 从 SessionRegistry 删除旧会话，并将 token 加入黑名单

**为什么分两阶段**：
- ✅ **状态一致性**：先标记 KICKED，确保状态更新完成
- ✅ **错误处理**：如果删除失败，至少状态已标记，不会影响新会话注册
- ✅ **代码清晰**：职责分离，`registerLoginSessionEnforceSingle()` 负责状态管理，`blacklistKickedSessions()` 负责清理

**代码实现**：
```java
// 第一阶段：标记为 KICKED
updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
oldSession.setStatus(SessionStatus.KICKED);
kicked.add(oldSession);

// 第二阶段：删除会话并加入黑名单（在 blacklistKickedSessions() 中执行）
sessionRegistry.unregisterLoginSession(kickedSession.getSessionId());
blacklistService.addToBlacklist(kickedSession.getToken(), ttlSeconds);
```

**最终结果**：
- ✅ **会话已删除**：从 SessionRegistry 和 Redis 中删除旧会话记录
- ✅ **Token 已失效**：旧 token 已加入黑名单，无法继续使用
- ✅ **状态已标记**：在删除前已标记为 KICKED，便于日志记录和问题排查

#### 13.2.2 问题排查

**场景**：
- 用户报告"账号被踢下线"
- 需要查看登录历史，确认是否被其他设备登录

**标记 KICKED 的好处**：
- ✅ **状态标识**：在删除前标记为 KICKED，便于日志记录和问题排查
- ✅ **时间窗口**：在标记到删除之间的时间窗口内，可以查看被踢下线的会话信息
- ✅ **错误处理**：如果删除失败，至少状态已标记，不会影响新会话注册

**注意**：
- 标记为 KICKED 后，会在 `blacklistKickedSessions()` 方法中从 SessionRegistry 删除会话记录
- 删除操作会清理 Redis 中的会话数据，但日志中会保留被踢下线的记录

**示例**：
```
用户 A 的登录流程：
  - 2024-01-01 10:00:00 登录（设备1，loginSessionId="sid-001"）
  - 2024-01-01 10:05:00 登录（设备2，loginSessionId="sid-002"）
    ├─ 设备1的会话被标记为 KICKED
    ├─ 设备1的会话从 SessionRegistry 删除
    └─ 设备1的 token 被加入黑名单
  
日志记录：
  - 设备1在10:00登录
  - 设备2在10:05登录，踢掉了设备1（日志中记录）
  - 设备1的会话已删除（Redis 中不再存在）
```

#### 13.2.3 两阶段处理机制

**处理流程**：
1. **第一阶段**：标记为 KICKED（状态管理）
2. **第二阶段**：删除会话记录（清理数据）

**原则**：
- ✅ **状态管理**：先标记状态，确保状态一致性
- ✅ **数据清理**：删除会话记录，释放存储空间
- ✅ **日志记录**：删除前记录日志，保留审计信息

**实现**：
```java
// 第一阶段：标记为 KICKED
updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);

// 第二阶段：删除会话（在 blacklistKickedSessions() 中）
sessionRegistry.unregisterLoginSession(kickedSession.getSessionId());

// 旧方案（直接删除）
redis.delete(LOGIN_SESSION_KEY_PREFIX + sessionId); // ❌ 删除数据

// 新方案（标记）
updateSessionStatus(sessionId, SessionStatus.KICKED); // ✅ 保留数据，只更新状态
```

---

### 13.3 为什么需要 HTTP Session 存储 loginSessionId

#### 13.3.1 TokenController 验证需要

**问题**：为什么需要在 HTTP Session 中存储 `loginSessionId`？

**答案**：

**OAuth2AuthorizedClientService 覆盖问题**：
- `OAuth2AuthorizedClientService` 存储 `OAuth2AuthorizedClient` 时，使用 `userId` 作为 key
- 同一用户的新登录会覆盖旧登录的 `OAuth2AuthorizedClient`
- 导致设备 1 调用 `/token` 时，可能获取到设备 2 的 token

**解决方案**：
- ✅ **HTTP Session 存储**：登录时，将 `loginSessionId` 存储到 HTTP Session
- ✅ **TokenController 验证**：获取 token 时，验证 token 的 `loginSessionId` 与 Session 中的是否匹配
- ✅ **防止覆盖**：如果不匹配，说明 token 已被其他登录覆盖，拒绝返回 token

**代码实现**：
```java
// 登录时存储
session.getAttributes().put(SESSION_LOGIN_SESSION_ID_KEY, loginSessionId);

// TokenController 验证
String sessionLoginSessionId = (String) session.getAttributes().get(SESSION_LOGIN_SESSION_ID_KEY);
if (!loginSessionId.equals(sessionLoginSessionId)) {
    return 401; // token 已被覆盖
}
```

#### 13.3.2 防止 token 被覆盖

**场景**：
```
设备 1 登录
  HTTP Session: loginSessionId="sid-001"
  OAuth2AuthorizedClientService: userId="user-A" → token1 (sid="sid-001")

设备 2 登录
  HTTP Session: loginSessionId="sid-002"
  OAuth2AuthorizedClientService: userId="user-A" → token2 (sid="sid-002")  ← 覆盖！

设备 1 调用 /token
  OAuth2AuthorizedClientService 返回 token2 (sid="sid-002")
  HTTP Session 中存储的是 loginSessionId="sid-001"
  sid-002 != sid-001 → 拒绝返回 token
```

**关键点**：
- ✅ **HTTP Session 隔离**：每个设备的 HTTP Session 是独立的
- ✅ **精确匹配**：确保返回的 token 属于当前 Session
- ✅ **防止覆盖**：即使 `OAuth2AuthorizedClientService` 被覆盖，也能检测到

---

### 13.4 为什么需要三层校验

#### 13.4.1 签名校验：防止伪造

**作用**：
- ✅ **防止伪造**：验证 token 是否由合法的授权服务器签发
- ✅ **防止篡改**：验证 token 内容是否被篡改
- ✅ **标准校验**：符合 OAuth2/JWT 标准

**实现**：
```java
ReactiveJwtDecoder delegate = NimbusReactiveJwtDecoder
        .withIssuerLocation(issuerUri)
        .build();
```

**校验内容**：
- 签名是否有效（使用 Keycloak 公钥）
- 过期时间（exp）
- 颁发者（iss）
- 受众（aud）

#### 13.4.2 黑名单校验：立即失效

**作用**：
- ✅ **立即失效**：登出时立即失效 token
- ✅ **单点登录支持**：新登录时，立即失效旧 token
- ✅ **性能高**：O(1) 查询，最先执行

**实现**：
```java
jwtBlacklistService.isBlacklisted(token)
    .flatMap(blacklisted -> {
        if (Boolean.TRUE.equals(blacklisted)) {
            return Mono.error(new JwtException("Token has been revoked"));
        }
        // 继续后续校验
    });
```

**使用场景**：
- 用户主动登出
- 用户在其他设备登录（旧 token 被加入黑名单）

#### 13.4.3 状态校验：会话管理

**作用**：
- ✅ **会话管理**：判断 loginSession 是否被踢下线
- ✅ **单点登录核心**：实现单点登录（后连踢前）
- ✅ **精确控制**：基于 `loginSessionId` 精确控制

**实现**：
```java
LoginSessionInfo sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
if (sessionInfo != null && sessionInfo.getStatus() != SessionStatus.ACTIVE) {
    return Mono.error(new JwtException("Session is not active: " + sessionInfo.getStatus()));
}
```

**使用场景**：
- 用户在其他设备登录（旧会话被标记为 KICKED）
- 会话过期或被用户主动注销（状态为 EXPIRED）

#### 13.4.4 三层校验的协同作用

**协同机制**：
1. **第一层（黑名单）**：立即失效已撤销的 token（性能最高）
2. **第二层（签名）**：验证 token 的合法性（标准校验）
3. **第三层（状态）**：判断 loginSession 是否被踢（核心功能）

**为什么需要三层**：
- ✅ **互补**：每层解决不同的问题
- ✅ **性能**：黑名单最先检查，快速失败
- ✅ **安全**：签名校验防止伪造，状态校验防止被踢
- ✅ **完整**：三层校验覆盖所有场景

**示例**：
```
场景1：用户登出
  - 第一层（黑名单）→ 命中 → 拒绝 ✅

场景2：用户在其他设备登录
  - 第一层（黑名单）→ 命中 → 拒绝 ✅
  - 第三层（状态）→ KICKED → 拒绝 ✅

场景3：伪造 token
  - 第二层（签名）→ 签名无效 → 拒绝 ✅

场景4：正常请求
  - 第一层（黑名单）→ 未命中 → 继续
  - 第二层（签名）→ 通过 → 继续
  - 第三层（状态）→ ACTIVE → 通过 ✅
```

---

### 13.5 为什么需要双索引设计

#### 13.5.1 向后兼容需求

**问题**：为什么需要同时按 `sessionId` 和 `loginSessionId` 存储？

**答案**：

**向后兼容**：
- 旧代码可能使用 `sessionId`（jti）查询会话
- 新代码使用 `loginSessionId`（sid）查询会话
- 需要同时支持两种查询方式

**实现**：
```java
// 按 sessionId 存储（向后兼容）
redis.opsForValue().set(LOGIN_SESSION_KEY_PREFIX + sessionId, sessionJson, ttl);

// 按 loginSessionId 存储（核心功能）
if (loginSessionId != null && !loginSessionId.isBlank()) {
    redis.opsForValue().set(LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX + loginSessionId, sessionJson, ttl);
}
```

#### 13.5.2 查询性能

**性能对比**：

**单索引（只有 sessionId）**：
- 按 `loginSessionId` 查询需要遍历所有会话（O(n)）
- 性能差，不适合高并发场景

**双索引（sessionId + loginSessionId）**：
- 按 `sessionId` 查询：O(1)
- 按 `loginSessionId` 查询：O(1)
- 性能好，适合高并发场景

---

### 13.6 本章总结

**关键设计决策**：
1. **使用 sid 作为 loginSessionId**：稳定、token 刷新不变、Keycloak 原生支持
2. **标记 KICKED 而不是删除**：审计需求、问题排查、数据完整性
3. **HTTP Session 存储 loginSessionId**：TokenController 验证需要、防止 token 被覆盖
4. **三层校验**：签名校验（防止伪造）、黑名单校验（立即失效）、状态校验（会话管理）
5. **双索引设计**：向后兼容、查询性能

**设计原则**：
- ✅ **稳定性优先**：选择稳定的标识符（sid）
- ✅ **状态管理**：先标记 KICKED，再删除会话记录
- ✅ **安全性优先**：多层校验，确保安全
- ✅ **性能优化**：双索引设计，提高查询性能



---

## 十四、边界场景处理

> **本章目标**：理解各种边界场景的处理逻辑，掌握如何正确处理同一浏览器多Tab、Token刷新、网络延迟、向后兼容等边界情况。

---

### 14.1 同一浏览器多Tab

#### 14.1.1 共享 loginSessionId

**场景**：
- 用户在同一浏览器的多个 Tab 中打开应用
- 所有 Tab 共享同一个 HTTP Session
- 所有 Tab 共享同一个 `loginSessionId`

**行为**：
```
Tab 1 打开应用
  ↓
登录成功，loginSessionId="sid-001"
  ↓
HTTP Session 存储 loginSessionId="sid-001"

Tab 2 打开应用（同一浏览器）
  ↓
共享同一个 HTTP Session
  ↓
HTTP Session 中已有 loginSessionId="sid-001"
  ↓
Tab 2 也使用 loginSessionId="sid-001"
```

**关键点**：
- ✅ **共享 Session**：同一浏览器的多个 Tab 共享同一个 HTTP Session
- ✅ **共享 loginSessionId**：所有 Tab 使用同一个 `loginSessionId`
- ✅ **正常行为**：这是浏览器的正常行为，不需要特殊处理

#### 14.1.2 新设备登录后的影响

**场景**：
- 用户在同一浏览器的多个 Tab 中使用应用
- 用户在新设备上登录
- 新设备登录会踢掉旧设备的所有 Tab

**流程**：
```
Tab 1、Tab 2、Tab 3（同一浏览器，loginSessionId="sid-001"）
  ↓
用户在新设备登录（loginSessionId="sid-002"）
  ↓
旧设备的会话被标记为 KICKED，然后删除会话并将 token 加入黑名单
  ↓
旧设备的 token 被加入黑名单
  ↓
发布 SESSION_KICKED 事件（loginSessionId="sid-001"）
  ↓
Tab 1、Tab 2、Tab 3 的所有请求
  ├─ [第一层] 黑名单检查 → 命中 → 401 Unauthorized
  └─ 所有 Tab 都被踢下线
```

**关键点**：
- ✅ **所有 Tab 受影响**：同一浏览器的所有 Tab 共享同一个 `loginSessionId`，都会被踢下线
- ✅ **符合预期**：这是单点登录的正常行为
- ✅ **用户体验**：前端应该提示用户"账号已在其他设备登录"

---

### 14.2 Token刷新

#### 14.2.1 refresh_token 处理

**场景**：
- 用户登录后，access_token 过期
- 前端使用 refresh_token 刷新 access_token
- 新 token 的 `jti` 可能变化，但 `sid` 保持不变

**流程**：
```
用户登录
  Token 1: jti="jti-001", sid="sid-xyz789"
  ↓
Token 过期
  ↓
前端使用 refresh_token 刷新
  ↓
  Token 2: jti="jti-002", sid="sid-xyz789"  ← sid 不变！
  ↓
前端使用新 token 访问资源
  ↓
JWT 校验
  ├─ 提取 loginSessionId="sid-xyz789"
  ├─ 查询 SessionRegistry
  ├─ 找到会话（loginSessionId="sid-xyz789"）
  └─ 状态为 ACTIVE → 通过 ✅
```

**关键点**：
- ✅ **sid 不变**：token 刷新时，`sid` 保持不变
- ✅ **正常使用**：新 token 可以正常使用
- ✅ **无需特殊处理**：系统自动处理 token 刷新

#### 14.2.2 跳过同一 loginSessionId 的会话

**场景**：
- 用户登录后，token 刷新
- 新 token 的 `jti` 可能变化，但 `loginSessionId` 保持不变
- 如果新 token 再次触发登录流程，不应该踢掉自己

**代码实现**：
```java
// SessionRegistry.registerLoginSessionEnforceSingle()
for (LoginSessionInfo oldSession : activeSessions) {
    // 跳过自己（如果新会话的 loginSessionId 与旧会话相同，说明是同一登录会话的 token 刷新）
    if (sessionInfo.getLoginSessionId() != null 
            && sessionInfo.getLoginSessionId().equals(oldSession.getLoginSessionId())) {
        log.debug("跳过同一 loginSessionId 的会话: loginSessionId={}", sessionInfo.getLoginSessionId());
        continue; // 跳过，不踢掉
    }
    
    // 更新状态为 KICKED
    updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
}
```

**关键逻辑**：
- ✅ **跳过自己**：如果新会话的 `loginSessionId` 与旧会话相同，跳过（不踢掉）
- ✅ **只踢其他登录**：只踢掉不同 `loginSessionId` 的会话
- ✅ **支持 token 刷新**：token 刷新不会导致自己被踢下线

**示例**：
```
用户 A 在设备 1 登录
  loginSessionId="sid-001", sessionId="jti-001", status=ACTIVE
  ↓
Token 刷新（可能是前端自动刷新，或重新登录）
  ↓
新会话：loginSessionId="sid-001", sessionId="jti-002"
  ↓
registerLoginSessionEnforceSingle()
  ├─ 查询 ACTIVE 会话 → [旧会话（loginSessionId="sid-001"）]
  ├─ 新会话的 loginSessionId="sid-001" == 旧会话的 loginSessionId="sid-001"
  ├─ 跳过，不踢掉 ✅
  └─ 注册新会话（更新 sessionId="jti-002"）
```

#### 14.2.3 新 token 的 loginSessionId

**验证**：
- ✅ **保持不变**：token 刷新时，`loginSessionId`（sid）保持不变
- ✅ **正常使用**：新 token 可以正常使用
- ✅ **无需重新登录**：不需要用户重新登录

---

### 14.3 网络延迟/重试

#### 14.3.1 竞态条件处理

**场景**：
- 用户几乎同时在两个设备上登录
- 两个登录请求可能同时到达服务器
- 可能出现竞态条件

**问题**：
```
设备 1 登录请求到达（时间 T1）
  ↓
查询 ACTIVE 会话 → []
  ↓
注册新会话（loginSessionId="sid-001"）

设备 2 登录请求到达（时间 T2，T2 ≈ T1）
  ↓
查询 ACTIVE 会话 → []（设备1的会话可能还未注册完成）
  ↓
注册新会话（loginSessionId="sid-002"）
  ↓
结果：两个会话都是 ACTIVE（错误！）
```

**解决方案**：

**方案1：Redis 原子操作**
- 使用 Redis 的原子操作（如 SETNX、WATCH/MULTI/EXEC）
- 确保同一用户只有一个 ACTIVE 会话

**当前实现**：
- ⚠️ **非原子操作**：当前实现不是原子操作
- ✅ **最终一致性**：通过后续的 JWT 校验和状态检查，确保最终一致性
- ✅ **实际影响小**：竞态条件发生的概率很低（需要几乎同时登录）

**改进建议**：
- 可以使用 Redis 的 `SETNX` 或 `WATCH/MULTI/EXEC` 实现原子操作
- 或者使用分布式锁（如 Redisson）

#### 14.3.2 最终一致性

**原则**：
- ✅ **最终一致性**：系统最终会达到一致状态
- ✅ **多层校验**：通过多层校验确保安全性

**实现**：
```
即使出现竞态条件（两个会话都是 ACTIVE）
  ↓
后续请求的 JWT 校验
  ├─ 查询 SessionRegistry
  ├─ 如果找到多个 ACTIVE 会话
  ├─ 可以选择：
  │     ├─ 只允许最新的会话（按时间戳）
  │     └─ 或者标记所有旧会话为 KICKED
  └─ 确保最终只有一个 ACTIVE 会话
```

**当前实现**：
- ✅ **JWT 校验**：每次请求都会检查会话状态
- ✅ **状态检查**：如果会话状态非 ACTIVE，拒绝访问
- ✅ **最终一致**：即使出现竞态条件，最终也会达到一致状态

---

### 14.4 向后兼容

#### 14.4.1 旧 token 没有 loginSessionId

**场景**：
- 旧 token 可能没有 `sid` claim
- 旧 token 可能没有在 SessionRegistry 中注册
- 需要向后兼容，避免影响现有功能

**处理策略**：

**策略1：JWT 校验时**
```java
// JwtDecoderConfig.checkSessionStatus()
if (loginSessionId == null || loginSessionId.isBlank()) {
    log.warn("JWT 中没有 loginSessionId，跳过状态检查（向后兼容）");
    return Mono.empty(); // 跳过，不拒绝
}
```

**策略2：TokenController 验证时**
```java
// TokenController.getToken()
if (loginSessionId == null || loginSessionId.isBlank()) {
    log.warn("JWT 中没有 loginSessionId，跳过验证（向后兼容）");
    // 直接返回 token
    return Mono.just(ResponseEntity.ok(result));
}
```

**策略3：SessionRegistry 查询时**
```java
// SessionRegistry.getLoginSessionByLoginSessionId()
if (loginSessionId == null || loginSessionId.isBlank()) {
    return null; // 返回 null，不抛出异常
}
```

**关键点**：
- ✅ **跳过检查**：如果没有 `loginSessionId`，跳过相关检查
- ✅ **不拒绝访问**：向后兼容，不拒绝访问
- ✅ **记录日志**：记录警告日志，便于排查

#### 14.4.2 SessionRegistry 中找不到会话

**场景**：
- 旧 token 可能没有在 SessionRegistry 中注册
- 首次登录时，SessionRegistry 可能还没有数据
- 需要向后兼容

**处理策略**：

**策略1：JWT 校验时**
```java
// JwtDecoderConfig.checkSessionStatus()
LoginSessionInfo sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
if (sessionInfo == null) {
    log.warn("SessionRegistry 中找不到会话，跳过状态检查");
    return Mono.empty(); // 跳过，不拒绝
}
```

**策略2：TokenController 验证时**
```java
// TokenController.getToken()
var sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
if (sessionInfo == null) {
    log.warn("SessionRegistry 中找不到会话");
    // 继续返回 token（向后兼容）
}
```

**关键点**：
- ✅ **跳过检查**：如果找不到会话，跳过相关检查
- ✅ **不拒绝访问**：向后兼容，不拒绝访问
- ✅ **记录日志**：记录警告日志

#### 14.4.3 状态为 null 的处理

**场景**：
- 旧数据可能没有 `status` 字段
- 需要向后兼容，默认为 ACTIVE

**处理策略**：
```java
// SessionRegistry.getLoginSessionByLoginSessionId()
if (info != null && info.getStatus() == null) {
    info.setStatus(SessionStatus.ACTIVE); // 默认为 ACTIVE
}
```

**关键点**：
- ✅ **默认 ACTIVE**：如果状态为 null，默认为 ACTIVE
- ✅ **向后兼容**：旧数据可以正常使用
- ✅ **自动修复**：读取时自动设置默认值

#### 14.4.4 HTTP Session 中没有 loginSessionId

**场景**：
- 旧登录可能没有在 HTTP Session 中存储 `loginSessionId`
- 需要向后兼容

**处理策略**：
```java
// TokenController.getToken()
String sessionLoginSessionId = (String) session.getAttributes().get(SESSION_LOGIN_SESSION_ID_KEY);
if (sessionLoginSessionId == null || sessionLoginSessionId.isBlank()) {
    log.warn("HTTP Session 中没有 loginSessionId，跳过 Session 验证（向后兼容）");
    // 跳过验证，继续返回 token
}
```

**关键点**：
- ✅ **跳过验证**：如果 Session 中没有 `loginSessionId`，跳过验证
- ✅ **不拒绝访问**：向后兼容，不拒绝访问
- ✅ **记录日志**：记录警告日志

---

### 14.5 其他边界场景

#### 14.5.1 同一用户同时登录（竞态条件）

**场景**：
- 用户几乎同时在两个设备上登录
- 可能出现两个会话都是 ACTIVE 的情况

**处理**：
- ⚠️ **当前实现**：非原子操作，可能出现竞态条件
- ✅ **最终一致性**：通过后续的 JWT 校验和状态检查，确保最终一致性
- ✅ **改进建议**：可以使用 Redis 原子操作或分布式锁

#### 14.5.2 Token 过期但未刷新

**场景**：
- Token 过期，但前端未及时刷新
- 用户继续使用过期的 token

**处理**：
- ✅ **签名校验**：JWT 签名校验会检查过期时间（exp）
- ✅ **自动拒绝**：过期的 token 会被自动拒绝
- ✅ **前端处理**：前端应该自动刷新 token

#### 14.5.3 WebSocket 连接断开但未清理

**场景**：
- WebSocket 连接异常断开
- SessionRegistry 中的记录可能未及时清理

**处理**：
- ✅ **TTL 自动过期**：Redis 的 TTL 会自动清理过期记录
- ✅ **定期清理**：可以定期清理过期的 WebSocket 会话记录
- ✅ **连接断开事件**：正常断开时会触发 `SessionDisconnectEvent`，自动清理

---

### 14.6 本章总结

**边界场景**：
1. **同一浏览器多Tab**：共享 `loginSessionId`，新设备登录后所有 Tab 被踢下线
2. **Token刷新**：`loginSessionId` 保持不变，跳过同一 `loginSessionId` 的会话
3. **网络延迟/重试**：可能出现竞态条件，通过最终一致性保证
4. **向后兼容**：旧 token 没有 `loginSessionId`、找不到会话、状态为 null 等情况

**处理策略**：
- ✅ **跳过检查**：向后兼容，不拒绝访问
- ✅ **记录日志**：记录警告日志，便于排查
- ✅ **默认值处理**：状态为 null 时默认为 ACTIVE
- ✅ **最终一致性**：通过多层校验确保最终一致性

**关键代码**：
- `registerLoginSessionEnforceSingle()`：跳过同一 `loginSessionId` 的会话
- `checkSessionStatus()`：向后兼容处理
- `TokenController.getToken()`：向后兼容处理



---

## 十五、测试验证

> **本章目标**：掌握如何测试单点登录系统的各项功能，包括功能测试、边界场景测试、验证方法等。

---

### 15.1 功能测试场景

#### 15.1.1 单点登录测试

**测试目标**：验证新设备登录时，旧设备被自动踢下线。

**测试步骤**：

**步骤1：设备1登录**
```
1. 在设备1（浏览器1）访问 /oauth2/authorization/keycloak
2. 输入用户名密码，完成登录
3. 记录设备1的 loginSessionId（从日志或 Redis 中获取）
```

**步骤2：设备2登录**
```
1. 在设备2（浏览器2）访问 /oauth2/authorization/keycloak
2. 使用相同的用户名密码登录
3. 记录设备2的 loginSessionId
```

**步骤3：验证设备1被踢下线**
```
1. 在设备1尝试访问需要认证的接口（如创建房间）
2. 应该返回 401 Unauthorized
3. 检查日志，确认设备1的会话状态为 KICKED
```

**验证点**：
- ✅ 设备1的会话状态变为 KICKED
- ✅ 设备1的 token 被加入黑名单
- ✅ 设备1的请求被拒绝（401）
- ✅ 设备2可以正常使用

**日志检查**：
```bash
# Gateway 日志
grep "单点登录" gateway.log
# 应该看到：新登录会话已注册，踢掉旧会话数=1

# 检查 Redis
redis-cli
> GET session:login:loginSession:{设备1的loginSessionId}
# 应该看到 status: "KICKED"
```

#### 15.1.2 Token刷新测试

**测试目标**：验证 token 刷新时，`loginSessionId` 保持不变。

**测试步骤**：

**步骤1：登录并获取token**
```
1. 用户登录，获取 access_token 和 refresh_token
2. 记录 loginSessionId（从 JWT 的 sid claim 中提取）
```

**步骤2：刷新token**
```
1. 等待 access_token 过期（或手动刷新）
2. 使用 refresh_token 刷新 access_token
3. 获取新的 access_token
```

**步骤3：验证loginSessionId不变**
```
1. 解析新 token 的 JWT
2. 提取 sid claim
3. 验证 sid 与步骤1中的 loginSessionId 相同
```

**验证点**：
- ✅ 新 token 的 `sid` 与旧 token 的 `sid` 相同
- ✅ 新 token 可以正常使用
- ✅ 会话状态仍为 ACTIVE
- ✅ 不会被自己踢下线

**代码验证**：
```java
// 从新 token 中提取 sid
Jwt jwt = jwtDecoder.decode(newToken);
String sid = jwt.getClaim("sid").toString();
// 验证 sid 与登录时的 sid 相同
```

#### 15.1.3 WebSocket断连测试

**测试目标**：验证用户登出或新设备登录时，WebSocket 连接被断开。

**测试步骤**：

**步骤1：建立WebSocket连接**
```
1. 在设备1登录
2. 建立 WebSocket 连接（使用 JWT token）
3. 确认连接成功
```

**步骤2：触发断连**
```
方式1：用户登出
  1. 在设备1访问 /logout
  2. 观察 WebSocket 连接是否断开

方式2：新设备登录
  1. 在设备2登录（相同用户）
  2. 观察设备1的 WebSocket 连接是否断开
```

**步骤3：验证断连**
```
1. 检查 WebSocket 连接状态（应该已断开）
2. 检查是否收到踢人通知（/queue/system.kick）
3. 检查日志，确认断连操作已执行
```

**验证点**：
- ✅ WebSocket 连接被断开
- ✅ 收到踢人通知消息
- ✅ 日志中记录断连操作
- ✅ SessionRegistry 中的 WebSocket 会话被清理

**日志检查**：
```bash
# Game-Service 日志
grep "收到会话失效事件" game-service.log
# 应该看到：收到会话失效事件，开始断开用户 WebSocket 连接

grep "已断开用户" game-service.log
# 应该看到：已断开用户的 WebSocket 连接
```

#### 15.1.4 登出测试

**测试目标**：验证用户登出时，token 被加入黑名单，WebSocket 连接被断开。

**测试步骤**：

**步骤1：登录并建立连接**
```
1. 用户登录
2. 建立 WebSocket 连接
3. 记录 token 和 loginSessionId
```

**步骤2：登出**
```
1. 访问 /logout
2. 确认登出成功
```

**步骤3：验证登出效果**
```
1. 使用旧 token 访问接口 → 应该返回 401
2. 检查黑名单 → token 应该存在
3. 检查 WebSocket 连接 → 应该已断开
4. 检查会话状态 → 应该为 EXPIRED 或已删除
```

**验证点**：
- ✅ Token 被加入黑名单
- ✅ 使用旧 token 的请求被拒绝
- ✅ WebSocket 连接被断开
- ✅ 会话状态更新为 EXPIRED

**Redis检查**：
```bash
redis-cli
> EXISTS jwt:blacklist:{token的hash值}
# 应该返回 1（存在）
```

---

### 15.2 边界场景测试

#### 15.2.1 同一浏览器多Tab测试

**测试目标**：验证同一浏览器的多个 Tab 共享同一个 `loginSessionId`。

**测试步骤**：

**步骤1：Tab1登录**
```
1. 在浏览器 Tab1 中登录
2. 记录 loginSessionId
```

**步骤2：Tab2打开**
```
1. 在同一个浏览器打开新 Tab（Tab2）
2. 访问应用
3. 检查 loginSessionId（应该与 Tab1 相同）
```

**步骤3：新设备登录**
```
1. 在设备2登录（相同用户）
2. 观察 Tab1 和 Tab2 是否都被踢下线
```

**验证点**：
- ✅ Tab1 和 Tab2 共享同一个 `loginSessionId`
- ✅ 新设备登录后，Tab1 和 Tab2 都被踢下线
- ✅ 所有 Tab 的请求都被拒绝

#### 15.2.2 网络延迟测试

**测试目标**：验证网络延迟情况下，系统仍能正常工作。

**测试步骤**：

**步骤1：模拟网络延迟**
```
1. 使用网络延迟工具（如 tc）模拟延迟
2. 设备1登录
3. 设备2登录（几乎同时）
```

**步骤2：验证最终一致性**
```
1. 等待一段时间
2. 检查最终状态（应该只有一个 ACTIVE 会话）
3. 验证被踢掉的设备无法访问
```

**验证点**：
- ✅ 即使有网络延迟，最终也能达到一致状态
- ✅ 只有一个 ACTIVE 会话
- ✅ 被踢掉的设备无法访问

#### 15.2.3 并发登录测试

**测试目标**：验证并发登录时的处理。

**测试步骤**：

**步骤1：并发登录**
```
1. 使用压力测试工具（如 JMeter）模拟并发登录
2. 同一用户几乎同时在多个设备上登录
3. 观察系统行为
```

**步骤2：验证结果**
```
1. 检查最终状态（应该只有一个 ACTIVE 会话）
2. 检查日志，确认所有登录都被处理
3. 验证被踢掉的设备无法访问
```

**验证点**：
- ✅ 所有登录请求都被处理
- ✅ 最终只有一个 ACTIVE 会话
- ✅ 系统没有崩溃或异常

---

### 15.3 验证方法

#### 15.3.1 日志检查

**关键日志位置**：

**Gateway 日志**：
```bash
# 登录成功
grep "单点登录" gateway.log
# 应该看到：新登录会话已注册，踢掉旧会话数=X

# JWT 校验
grep "JWT 校验" gateway.log
# 应该看到：JWT 验证通过 或 会话状态非 ACTIVE

# Token 获取
grep "Token获取" gateway.log
# 应该看到：Token 验证通过 或 Token 已失效
```

**Game-Service 日志**：
```bash
# WebSocket 连接
grep "WebSocket 连接" game-service.log
# 应该看到：用户 WebSocket 连接注册完成

# 会话失效事件
grep "收到会话失效事件" game-service.log
# 应该看到：收到会话失效事件，开始断开用户 WebSocket 连接
```

**日志格式示例**：
```
【单点登录】新登录会话已注册: userId=user-123, sessionId=jti-001, loginSessionId=sid-xyz789, 踢掉旧会话数=1
【JWT 校验】✅ 会话状态检查通过: loginSessionId=sid-xyz789, status=ACTIVE
【Token获取】✅ Token 验证通过: loginSessionId=sid-xyz789, jti=jti-001
```

#### 15.3.2 Redis数据检查

**检查登录会话**：
```bash
redis-cli

# 按 userId 查询所有会话
> SMEMBERS session:login:user:user-123
# 返回：["jti-001", "jti-002"]

# 按 sessionId 查询会话详情
> GET session:login:token:jti-001
# 返回：LoginSessionInfo JSON（包含 status、loginSessionId 等）

# 按 loginSessionId 查询会话详情
> GET session:login:loginSession:sid-xyz789
# 返回：LoginSessionInfo JSON
```

**检查黑名单**：
```bash
# 检查 token 是否在黑名单中
> EXISTS jwt:blacklist:{token的hash值}
# 返回：1（存在）或 0（不存在）

# 查看黑名单 TTL
> TTL jwt:blacklist:{token的hash值}
# 返回：剩余秒数
```

**检查WebSocket会话**：
```bash
# 按 userId 查询 WebSocket 会话
> SMEMBERS session:ws:user:user-123
# 返回：["ws-session-001", "ws-session-002"]

# 按 sessionId 查询 WebSocket 会话详情
> GET session:ws:session:ws-session-001
# 返回：WebSocketSessionInfo JSON
```

#### 15.3.3 Kafka消息检查

**检查Kafka消息**：
```bash
# 使用 kafka-console-consumer 消费消息
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic session-invalidated \
  --from-beginning

# 应该看到类似以下消息：
{
  "userId": "user-123",
  "loginSessionId": "sid-xyz789",
  "eventType": "FORCE_LOGOUT",
  "timestamp": 1704067200000,
  "reason": "单点登录：被新登录踢下线"
}
```

**验证消息内容**：
- ✅ `userId` 正确
- ✅ `loginSessionId` 正确（如果提供）
- ✅ `eventType` 正确（LOGOUT、FORCE_LOGOUT 等）
- ✅ `timestamp` 正确
- ✅ `reason` 正确

---

### 15.4 测试工具

#### 15.4.1 浏览器开发者工具

**使用场景**：
- 查看 HTTP 请求和响应
- 查看 WebSocket 连接状态
- 查看 Console 日志

**关键检查点**：
- Network 标签：查看请求状态码（401、200 等）
- Console 标签：查看前端日志
- Application 标签：查看 Session Storage、Local Storage

#### 15.4.2 Redis客户端

**推荐工具**：
- RedisInsight（图形化界面）
- redis-cli（命令行工具）

**使用场景**：
- 查看会话数据
- 检查黑名单
- 验证数据一致性

#### 15.4.3 Kafka工具

**推荐工具**：
- Kafka Tool（图形化界面）
- kafka-console-consumer（命令行工具）

**使用场景**：
- 查看 Kafka 消息
- 验证事件发布
- 检查消息延迟

---

### 15.5 测试检查清单

#### 15.5.1 功能测试检查清单

- [ ] 单点登录：新设备登录，旧设备被踢下线
- [ ] Token刷新：刷新后 `loginSessionId` 不变
- [ ] WebSocket断连：登出或新登录时，WebSocket 连接断开
- [ ] 登出：token 被加入黑名单，WebSocket 断开

#### 15.5.2 边界场景测试检查清单

- [ ] 同一浏览器多Tab：共享 `loginSessionId`，同时被踢下线
- [ ] 网络延迟：最终一致性保证
- [ ] 并发登录：只有一个 ACTIVE 会话

#### 15.5.3 验证方法检查清单

- [ ] 日志检查：关键日志正常输出
- [ ] Redis数据检查：数据正确存储
- [ ] Kafka消息检查：消息正确发布

---

### 15.6 本章总结

**测试场景**：
1. **功能测试**：单点登录、Token刷新、WebSocket断连、登出
2. **边界场景测试**：同一浏览器多Tab、网络延迟、并发登录
3. **验证方法**：日志检查、Redis数据检查、Kafka消息检查

**关键验证点**：
- ✅ 会话状态正确（ACTIVE、KICKED、EXPIRED）
- ✅ Token 黑名单正确
- ✅ WebSocket 连接正确断开
- ✅ Kafka 消息正确发布

**测试工具**：
- 浏览器开发者工具
- Redis客户端
- Kafka工具



---

## 十六、常见问题与解决方案

> **本章目标**：掌握常见问题的排查方法和解决方案，能够快速定位和解决实际问题。

---

### 16.1 登录后旧会话仍然有效

#### 16.1.1 问题现象

**现象**：
- 设备1登录后，设备2再登录
- 设备1仍然可以访问需要认证的接口
- 设备1没有被踢下线

#### 16.1.2 原因分析

**可能原因**：

**原因1：黑名单未生效**
- 旧 token 没有被加入黑名单
- 黑名单检查逻辑有问题

**原因2：会话状态未更新**
- 旧会话状态没有被标记为 KICKED
- SessionRegistry 查询逻辑有问题

**原因3：JWT校验未执行**
- JWT 校验逻辑未正确执行
- 会话状态检查被跳过

**原因4：Token刷新绕过检查**
- 设备1在设备2登录前已刷新 token
- 新 token 不在黑名单中

#### 16.1.3 排查步骤

**步骤1：检查黑名单**
```bash
# 检查旧 token 是否在黑名单中
redis-cli
> EXISTS jwt:blacklist:{旧token的hash值}
# 如果返回 0，说明未加入黑名单
```

**步骤2：检查会话状态**
```bash
# 检查旧会话状态
> GET session:login:loginSession:{旧loginSessionId}
# 查看 status 字段，应该是 "KICKED"
```

**步骤3：检查日志**
```bash
# Gateway 日志
grep "单点登录" gateway.log
# 应该看到：新登录会话已注册，踢掉旧会话数=1

# JWT 校验日志
grep "JWT 校验" gateway.log
# 应该看到：会话状态非 ACTIVE，拒绝访问
```

**步骤4：检查TokenController验证**
```bash
# Token 获取日志
grep "Token获取" gateway.log
# 应该看到：Token 验证通过 或 Token 已失效
```

#### 16.1.4 解决方案

**方案1：确保删除会话并加入黑名单**
```java
// 检查 LoginSessionKickHandler.blacklistKickedSessions()
// 确保所有被踢掉的会话都被删除，token 都被加入黑名单
for (LoginSessionInfo kickedSession : kickedSessions) {
    // 1. 删除会话
    sessionRegistry.unregisterLoginSession(kickedSession.getSessionId());
    
    // 2. 加入黑名单
    if (kickedSession.getToken() != null) {
        blacklistService.addToBlacklist(kickedSession.getToken(), ttl);
    }
}
```

**方案2：确保会话状态更新**
```java
// 检查 SessionRegistry.registerLoginSessionEnforceSingle()
// 确保旧会话状态被标记为 KICKED
updateSessionStatus(oldSession.getSessionId(), SessionStatus.KICKED);
```

**方案3：确保JWT校验执行**
```java
// 检查 JwtDecoderConfig.checkSessionStatus()
// 确保会话状态检查逻辑正确执行
if (sessionInfo.getStatus() != SessionStatus.ACTIVE) {
    return Mono.error(new JwtException("Session is not active: " + status));
}
```

**方案4：处理Token刷新**
```java
// 在 TokenController 中，检查 token 的 loginSessionId
// 如果与 Session 中的不匹配，拒绝返回 token
if (!loginSessionId.equals(sessionLoginSessionId)) {
    return 401; // token 已被覆盖
}
```

---

### 16.2 Token获取返回其他用户的token

#### 16.2.1 问题现象

**现象**：
- 设备1调用 `/token` 接口
- 返回的 token 属于设备2（其他设备）
- 设备1可以使用这个 token 访问资源

#### 16.2.2 原因分析

**根本原因**：
- `OAuth2AuthorizedClientService` 按 `userId` 存储
- 同一用户的新登录会覆盖旧登录的 `OAuth2AuthorizedClient`
- 设备1调用 `/token` 时，获取到设备2的 token

**详细流程**：
```
设备1登录
  OAuth2AuthorizedClientService[userId="user-A"] = Client1

设备2登录
  OAuth2AuthorizedClientService[userId="user-A"] = Client2  ← 覆盖！

设备1调用 /token
  authorizedClientManager.authorize() 获取 Client2
  返回 Client2 的 token（设备2的token）
```

#### 16.2.3 排查步骤

**步骤1：检查TokenController日志**
```bash
# 查看 Token 获取日志
grep "Token获取" gateway.log
# 应该看到：Token 的 loginSessionId 与 HTTP Session 不匹配
```

**步骤2：检查HTTP Session**
```bash
# 检查设备1的 HTTP Session 中存储的 loginSessionId
# 应该与返回的 token 的 loginSessionId 不匹配
```

**步骤3：检查OAuth2AuthorizedClient**
```bash
# 检查 OAuth2AuthorizedClientService 中的数据
# 应该看到：userId="user-A" 对应的是设备2的 Client
```

#### 16.2.4 解决方案

**方案1：HTTP Session验证（已实现）**
```java
// TokenController.getToken()
String sessionLoginSessionId = (String) session.getAttributes().get(SESSION_LOGIN_SESSION_ID_KEY);
if (!loginSessionId.equals(sessionLoginSessionId)) {
    return 401; // token 已被覆盖
}
```

**方案2：Token用户验证（已实现）**
```java
// TokenController.getToken()
String tokenUserId = jwt.getSubject();
if (!tokenUserId.equals(currentUserId)) {
    return 401; // token 不属于当前用户
}
```

**方案3：SessionRegistry验证（已实现）**
```java
// TokenController.getToken()
var sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
if (sessionInfo.getStatus() != SessionStatus.ACTIVE) {
    return 401; // 会话状态非 ACTIVE
}
```

**关键点**：
- ✅ 登录时，将 `loginSessionId` 存储到 HTTP Session
- ✅ 获取 token 时，验证 token 的 `loginSessionId` 与 Session 中的是否匹配
- ✅ 如果不匹配，拒绝返回 token

---

### 16.3 WebSocket连接未断开

#### 16.3.1 问题现象

**现象**：
- 用户登出或新设备登录
- 旧设备的 WebSocket 连接仍然保持
- 旧设备仍然可以接收消息

#### 16.3.2 原因分析

**可能原因**：

**原因1：Kafka事件未发布**
- 登出或新登录时，未发布会话失效事件
- 事件发布失败

**原因2：Kafka事件未消费**
- 事件已发布，但 Game-Service 未消费
- Kafka 消费者未启动或配置错误

**原因3：WebSocket查询失败**
- 基于 `loginSessionId` 查询 WebSocket 会话失败
- 查询逻辑有问题

**原因4：断连操作失败**
- 发送踢人通知失败
- 强制断开连接失败

#### 16.3.3 排查步骤

**步骤1：检查Kafka事件发布**
```bash
# 检查 Gateway 日志
grep "会话失效事件发布" gateway.log
# 应该看到：会话失效事件发布成功

# 检查 Kafka 消息
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic session-invalidated \
  --from-beginning
# 应该看到会话失效事件消息
```

**步骤2：检查Kafka事件消费**
```bash
# 检查 Game-Service 日志
grep "收到会话失效事件" game-service.log
# 应该看到：收到会话失效事件，开始断开用户 WebSocket 连接
```

**步骤3：检查WebSocket会话查询**
```bash
# 检查 Redis 中的 WebSocket 会话
redis-cli
> GET session:ws:session:{wsSessionId}
# 应该能找到对应的 WebSocket 会话

# 检查按 loginSessionId 查询
> GET session:ws:loginSession:{loginSessionId}
# 应该能找到对应的 WebSocket 会话
```

**步骤4：检查断连操作**
```bash
# 检查 Game-Service 日志
grep "已断开用户" game-service.log
# 应该看到：已断开用户的 WebSocket 连接
```

#### 16.3.4 解决方案

**方案1：确保事件发布**
```java
// 检查 LoginSessionKickHandler.publishKickedEvent()
// 确保事件正确发布
SessionInvalidatedEvent event = SessionInvalidatedEvent.of(
    userId, loginSessionId, EventType.FORCE_LOGOUT, reason
);
sessionEventPublisher.publishSessionInvalidated(event);
```

**方案2：确保事件消费**
```java
// 检查 SessionEventConsumer.consumeSessionInvalidated()
// 确保事件正确消费
@KafkaListener(topics = "${session.kafka.topic:session-invalidated}")
public void consumeSessionInvalidated(String message, Acknowledgment ack) {
    // 处理事件
}
```

**方案3：确保WebSocket查询**
```java
// 检查 SessionInvalidatedListener.onSessionInvalidated()
// 确保基于 loginSessionId 查询
if (loginSessionId != null && !loginSessionId.isBlank()) {
    List<WebSocketSessionInfo> wsSessions = 
        sessionRegistry.getWebSocketSessionsByLoginSessionId(loginSessionId);
}
```

**方案4：确保断连操作**
```java
// 检查 WebSocketDisconnectHelper
// 确保发送踢人通知和强制断开连接
disconnectHelper.sendKickMessage(userId, sessionId, reason);
disconnectHelper.forceDisconnect(sessionId);
```

---

### 16.4 Kafka事件未收到

#### 16.4.1 问题现象

**现象**：
- 登出或新登录时，Kafka 事件未收到
- Game-Service 未执行断连操作
- WebSocket 连接未断开

#### 16.4.2 原因分析

**可能原因**：

**原因1：事件未发布**
- 发布逻辑未执行
- 发布失败（异常被捕获）

**原因2：Kafka配置错误**
- Topic 配置错误
- Bootstrap servers 配置错误

**原因3：消费者未启动**
- Kafka 消费者未启动
- 消费者配置错误

**原因4：消息序列化失败**
- 事件对象序列化失败
- 消息格式错误

#### 16.4.3 排查步骤

**步骤1：检查事件发布日志**
```bash
# Gateway 日志
grep "会话失效事件发布" gateway.log
# 应该看到：会话失效事件发布成功 或 发布失败
```

**步骤2：检查Kafka配置**
```yaml
# application.yml
session:
  kafka:
    bootstrap-servers: localhost:9092
    topic: session-invalidated
```

**步骤3：检查Kafka消息**
```bash
# 使用 kafka-console-consumer 消费消息
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic session-invalidated \
  --from-beginning
# 应该能看到消息
```

**步骤4：检查消费者日志**
```bash
# Game-Service 日志
grep "会话事件消费者初始化" game-service.log
# 应该看到：会话事件消费者初始化完成，发现 X 个监听器

grep "收到会话失效事件" game-service.log
# 应该看到：收到会话失效事件
```

#### 16.4.4 解决方案

**方案1：确保事件发布**
```java
// 检查 SessionEventPublisher.publishSessionInvalidated()
// 确保事件正确发布，记录错误日志
try {
    String message = JSON.toJSONString(event);
    kafkaTemplate.send(topic, event.getUserId(), message);
} catch (Exception e) {
    log.error("发布会话失效事件异常", e);
}
```

**方案2：检查Kafka配置**
```yaml
# 确保 Kafka 配置正确
session:
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    topic: ${SESSION_KAFKA_TOPIC:session-invalidated}
```

**方案3：检查消费者配置**
```java
// 确保消费者正确配置
@KafkaListener(
    topics = "${session.kafka.topic:session-invalidated}",
    containerFactory = "sessionKafkaListenerContainerFactory"
)
public void consumeSessionInvalidated(String message, Acknowledgment ack) {
    // 处理事件
}
```

**方案4：检查监听器注册**
```java
// 确保 SessionEventListener 实现类被正确注册
@Component
public class SessionInvalidatedListener implements SessionEventListener {
    // 实现 onSessionInvalidated()
}
```

---

### 16.5 其他常见问题

#### 16.5.1 问题：JWT中没有sid

**现象**：
- JWT 中没有 `sid` claim
- `loginSessionId` 为 null
- 会话状态检查被跳过

**解决方案**：
- ✅ 检查 Keycloak 配置，确保 `sid` claim 被包含在 JWT 中
- ✅ 向后兼容：如果没有 `sid`，尝试使用 `session_state`
- ✅ 记录警告日志，便于排查

#### 16.5.2 问题：SessionRegistry中找不到会话

**现象**：
- JWT 校验时，SessionRegistry 中找不到会话
- 会话状态检查被跳过

**解决方案**：
- ✅ 向后兼容：如果找不到会话，跳过状态检查
- ✅ 检查登录时是否正确注册会话
- ✅ 检查 Redis 连接和数据存储

#### 16.5.3 问题：Token刷新后loginSessionId变化

**现象**：
- Token 刷新后，`loginSessionId` 变化
- 无法关联到同一个登录会话

**解决方案**：
- ✅ 使用 `sid` 作为 `loginSessionId`（稳定不变）
- ✅ 不要使用 `session_state`（可能变化）
- ✅ 检查 Keycloak 配置，确保 `sid` 稳定

---

### 16.6 问题排查流程图

```
问题出现
  ↓
检查日志
  ├─ Gateway 日志 → 登录、JWT校验、Token获取
  ├─ Game-Service 日志 → WebSocket连接、事件处理
  └─ Kafka 日志 → 事件发布、消费
  ↓
检查Redis数据
  ├─ 会话数据 → 状态、loginSessionId
  ├─ 黑名单 → token是否存在
  └─ WebSocket会话 → 连接状态
  ↓
检查Kafka消息
  ├─ 事件是否发布
  ├─ 事件是否消费
  └─ 消息内容是否正确
  ↓
定位问题
  ├─ 黑名单未生效 → 检查发布逻辑
  ├─ 会话状态未更新 → 检查注册逻辑
  ├─ WebSocket未断开 → 检查事件处理
  └─ Kafka事件未收到 → 检查配置和消费
  ↓
解决问题
  ├─ 修复代码逻辑
  ├─ 修复配置
  └─ 修复数据
```

---

### 16.7 本章总结

**常见问题**：
1. **登录后旧会话仍然有效**：黑名单未生效、会话状态未更新、JWT校验未执行
2. **Token获取返回其他用户的token**：OAuth2AuthorizedClientService 覆盖问题
3. **WebSocket连接未断开**：Kafka事件未发布/消费、查询失败、断连操作失败
4. **Kafka事件未收到**：事件未发布、配置错误、消费者未启动

**排查方法**：
- ✅ 日志检查：Gateway、Game-Service、Kafka
- ✅ Redis数据检查：会话数据、黑名单、WebSocket会话
- ✅ Kafka消息检查：事件发布、消费、消息内容

**解决方案**：
- ✅ 确保黑名单生效
- ✅ 确保会话状态更新
- ✅ 确保JWT校验执行
- ✅ 确保HTTP Session验证
- ✅ 确保Kafka事件发布和消费

**下一步**：理解了常见问题与解决方案后，我们可以继续学习性能优化建议，了解如何优化系统性能。

---

## 十七、性能优化建议

> **本章目标**：了解如何优化系统性能，包括 Redis 查询优化、Kafka 消息优化、日志优化等。

---

### 17.1 Redis查询优化

#### 17.1.1 索引设计

**当前设计**：
- ✅ **双索引**：同时按 `sessionId` 和 `loginSessionId` 建立索引
- ✅ **O(1) 查询**：两种查询都是 O(1) 时间复杂度

**优化建议**：

**建议1：使用Hash结构存储会话信息**
```java
// 当前实现：String 存储 JSON
redis.opsForValue().set(key, json, ttl);

// 优化建议：Hash 存储（如果只需要查询部分字段）
redis.opsForHash().putAll(key, map);
redis.expire(key, ttl);
```

**优势**：
- ✅ 可以只查询需要的字段（减少网络传输）
- ✅ 可以部分更新（不需要序列化整个对象）

**建议2：使用Sorted Set存储用户会话列表**
```java
// 当前实现：Set 存储 sessionId 列表
redis.opsForSet().add(userKey, sessionId);

// 优化建议：Sorted Set 存储（按时间排序）
redis.opsForZSet().add(userKey, sessionId, timestamp);
```

**优势**：
- ✅ 可以按时间排序查询
- ✅ 可以方便地清理过期会话

#### 17.1.2 批量查询

**当前实现**：
```java
// 逐个查询会话
for (String sessionId : sessionIds) {
    LoginSessionInfo info = getLoginSession(sessionId);
}
```

**优化建议**：
```java
// 使用 Pipeline 批量查询
List<Object> results = redis.executePipelined((RedisCallback<Object>) connection -> {
    for (String sessionId : sessionIds) {
        connection.get((LOGIN_SESSION_KEY_PREFIX + sessionId).getBytes());
    }
    return null;
});
```

**优势**：
- ✅ 减少网络往返次数
- ✅ 提高查询性能（特别是在高并发场景）

#### 17.1.3 缓存策略

**建议1：本地缓存热点数据**
```java
// 使用 Caffeine 或 Guava Cache 缓存热点会话
Cache<String, LoginSessionInfo> cache = Caffeine.newBuilder()
    .maximumSize(10000)
    .expireAfterWrite(5, TimeUnit.MINUTES)
    .build();

// 查询时先查本地缓存
LoginSessionInfo info = cache.get(loginSessionId, key -> {
    return sessionRegistry.getLoginSessionByLoginSessionId(key);
});
```

**优势**：
- ✅ 减少 Redis 查询
- ✅ 提高响应速度

**建议2：异步更新缓存**
```java
// 查询时异步更新缓存
LoginSessionInfo info = getLoginSessionByLoginSessionId(loginSessionId);
CompletableFuture.runAsync(() -> {
    cache.put(loginSessionId, info);
});
```

**优势**：
- ✅ 不阻塞主流程
- ✅ 提高并发性能

---

### 17.2 Kafka消息优化

#### 17.2.1 批量发送

**当前实现**：
```java
// 逐个发送消息
for (LoginSessionInfo kickedSession : kickedSessions) {
    SessionInvalidatedEvent event = ...;
    sessionEventPublisher.publishSessionInvalidated(event);
}
```

**优化建议**：
```java
// 批量发送消息
List<ProducerRecord<String, String>> records = new ArrayList<>();
for (LoginSessionInfo kickedSession : kickedSessions) {
    SessionInvalidatedEvent event = ...;
    String message = JSON.toJSONString(event);
    records.add(new ProducerRecord<>(topic, event.getUserId(), message));
}
kafkaTemplate.send(records);
```

**优势**：
- ✅ 减少网络往返次数
- ✅ 提高发送性能

#### 17.2.2 异步处理

**当前实现**：
```java
// 同步发送（阻塞）
CompletableFuture<SendResult<String, String>> future = 
    kafkaTemplate.send(topic, key, message);
future.whenComplete((result, ex) -> {
    // 处理结果
});
```

**优化建议**：
```java
// 使用线程池异步处理
ExecutorService executor = Executors.newFixedThreadPool(10);
for (LoginSessionInfo kickedSession : kickedSessions) {
    executor.submit(() -> {
        SessionInvalidatedEvent event = ...;
        sessionEventPublisher.publishSessionInvalidated(event);
    });
}
```

**优势**：
- ✅ 不阻塞主流程
- ✅ 提高并发性能

#### 17.2.3 错误重试

**当前实现**：
```java
// 简单的错误处理
try {
    kafkaTemplate.send(topic, key, message);
} catch (Exception e) {
    log.error("发布会话失效事件异常", e);
}
```

**优化建议**：
```java
// 使用重试机制
@Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
public void publishSessionInvalidated(SessionInvalidatedEvent event) {
    try {
        kafkaTemplate.send(topic, key, message);
    } catch (Exception e) {
        log.error("发布会话失效事件异常", e);
        throw e; // 抛出异常，触发重试
    }
}
```

**优势**：
- ✅ 自动重试失败的消息
- ✅ 提高消息可靠性

---

### 17.3 日志优化

#### 17.3.1 日志级别

**当前实现**：
```java
// 大量使用 INFO 级别日志
log.info("【单点登录】新登录会话已注册: userId={}, sessionId={}, loginSessionId={}", ...);
log.info("【JWT 校验】开始检查会话状态: sub={}, loginSessionId={}", ...);
```

**优化建议**：
```java
// 使用 DEBUG 级别记录详细日志
log.debug("【单点登录】新登录会话已注册: userId={}, sessionId={}, loginSessionId={}", ...);
log.debug("【JWT 校验】开始检查会话状态: sub={}, loginSessionId={}", ...);

// 使用 INFO 级别记录关键事件
log.info("【单点登录】用户 {} 登录，踢掉 {} 个旧会话", userId, kickedCount);
log.info("【JWT 校验】会话状态检查失败: loginSessionId={}, status={}", loginSessionId, status);
```

**优势**：
- ✅ 减少日志量
- ✅ 提高日志可读性

#### 17.3.2 日志格式

**当前实现**：
```java
// 简单的日志格式
log.info("【单点登录】新登录会话已注册: userId={}, sessionId={}, loginSessionId={}", ...);
```

**优化建议**：
```java
// 结构化日志格式（JSON）
log.info("{\"event\":\"login\",\"userId\":\"{}\",\"sessionId\":\"{}\",\"loginSessionId\":\"{}\"}", ...);
```

**优势**：
- ✅ 便于日志分析工具处理
- ✅ 便于查询和统计

#### 17.3.3 日志量控制

**建议1：条件日志**
```java
// 只在需要时记录日志
if (log.isDebugEnabled()) {
    log.debug("详细日志: {}", expensiveOperation());
}
```

**建议2：采样日志**
```java
// 采样记录日志（如每100次记录1次）
private int logCounter = 0;
if (++logCounter % 100 == 0) {
    log.info("采样日志: {}", data);
}
```

**建议3：异步日志**
```java
// 使用异步日志框架（如 Logback AsyncAppender）
// 不阻塞主线程
```

---

### 17.4 JWT校验优化

#### 17.4.1 黑名单检查优化

**当前实现**：
```java
// 每次请求都查询 Redis
jwtBlacklistService.isBlacklisted(token)
    .flatMap(blacklisted -> {
        // 处理结果
    });
```

**优化建议**：
```java
// 使用本地缓存（Bloom Filter）
BloomFilter<String> blacklistFilter = BloomFilter.create(
    Funnels.stringFunnel(Charset.defaultCharset()),
    1000000, // 预期元素数量
    0.01     // 误判率
);

// 查询时先查 Bloom Filter
if (blacklistFilter.mightContain(token)) {
    // 再查 Redis 确认
    return jwtBlacklistService.isBlacklisted(token);
} else {
    // 不在黑名单中
    return Mono.just(false);
}
```

**优势**：
- ✅ 减少 Redis 查询（大部分请求不需要查询 Redis）
- ✅ 提高性能

#### 17.4.2 会话状态检查优化

**当前实现**：
```java
// 每次请求都查询 Redis
LoginSessionInfo sessionInfo = sessionRegistry.getLoginSessionByLoginSessionId(loginSessionId);
```

**优化建议**：
```java
// 使用本地缓存
Cache<String, LoginSessionInfo> cache = Caffeine.newBuilder()
    .maximumSize(10000)
    .expireAfterWrite(1, TimeUnit.MINUTES)
    .build();

// 查询时先查本地缓存
LoginSessionInfo sessionInfo = cache.get(loginSessionId, key -> {
    return sessionRegistry.getLoginSessionByLoginSessionId(key);
});
```

**优势**：
- ✅ 减少 Redis 查询
- ✅ 提高响应速度

---

### 17.5 数据库优化

#### 17.5.1 Redis连接池优化

**建议**：
```yaml
# application.yml
spring:
  redis:
    lettuce:
      pool:
        max-active: 20    # 最大连接数
        max-idle: 10      # 最大空闲连接数
        min-idle: 5       # 最小空闲连接数
        max-wait: 1000    # 最大等待时间（毫秒）
```

#### 17.5.2 Redis集群优化

**建议**：
- ✅ 使用 Redis 集群提高可用性和性能
- ✅ 使用 Redis Sentinel 实现高可用
- ✅ 合理设置分片策略

---

### 17.6 本章总结

**优化方向**：
1. **Redis查询优化**：索引设计、批量查询、缓存策略
2. **Kafka消息优化**：批量发送、异步处理、错误重试
3. **日志优化**：日志级别、日志格式、日志量控制
4. **JWT校验优化**：黑名单检查优化、会话状态检查优化

**关键优化点**：
- ✅ 使用本地缓存减少 Redis 查询
- ✅ 使用批量操作减少网络往返
- ✅ 使用异步处理提高并发性能
- ✅ 合理设置日志级别减少日志量



---

## 十八、监控与运维

> **本章目标**：了解如何监控系统运行状态，包括关键指标、日志审计、告警规则等。

---

### 18.1 关键指标

#### 18.1.1 ACTIVE会话数

**指标说明**：
- 当前系统中 ACTIVE 状态的登录会话数量
- 反映系统的在线用户数

**监控方法**：
```bash
# 使用 Redis 命令统计
redis-cli
> EVAL "
local count = 0
local keys = redis.call('KEYS', 'session:login:user:*')
for _, key in ipairs(keys) do
    local sessionIds = redis.call('SMEMBERS', key)
    for _, sessionId in ipairs(sessionIds) do
        local session = redis.call('GET', 'session:login:token:' .. sessionId)
        if session then
            local info = cjson.decode(session)
            if info.status == 'ACTIVE' then
                count = count + 1
            end
        end
    end
end
return count
" 0
```

**监控工具**：
- Prometheus + Grafana
- 自定义监控脚本

**告警阈值**：
- 超过预期值：可能异常（如大量机器人登录）
- 低于预期值：可能系统异常

#### 18.1.2 被踢次数

**指标说明**：
- 单位时间内被踢下线的会话数量
- 反映单点登录的活跃度

**监控方法**：
```bash
# 统计 KICKED 状态的会话数
redis-cli
> EVAL "
local count = 0
local keys = redis.call('KEYS', 'session:login:user:*')
for _, key in ipairs(keys) do
    local sessionIds = redis.call('SMEMBERS', key)
    for _, sessionId in ipairs(sessionIds) do
        local session = redis.call('GET', 'session:login:token:' .. sessionId)
        if session then
            local info = cjson.decode(session)
            if info.status == 'KICKED' then
                count = count + 1
            end
        end
    end
end
return count
" 0
```

**监控工具**：
- 日志分析工具（如 ELK）
- 自定义监控脚本

**告警阈值**：
- 短时间内大量被踢：可能异常（如账号被盗用）

#### 18.1.3 黑名单命中率

**指标说明**：
- JWT 校验时，黑名单检查的命中率
- 反映黑名单的有效性

**监控方法**：
```java
// 在 JwtDecoderConfig 中统计
private AtomicLong blacklistHits = new AtomicLong(0);
private AtomicLong blacklistChecks = new AtomicLong(0);

public Mono<Jwt> jwtDecoder(String token) {
    blacklistChecks.incrementAndGet();
    return jwtBlacklistService.isBlacklisted(token)
        .flatMap(blacklisted -> {
            if (Boolean.TRUE.equals(blacklisted)) {
                blacklistHits.incrementAndGet();
                return Mono.error(new JwtException("Token has been revoked"));
            }
            // 继续处理
        });
}

// 计算命中率
public double getBlacklistHitRate() {
    long checks = blacklistChecks.get();
    if (checks == 0) {
        return 0.0;
    }
    return (double) blacklistHits.get() / checks;
}
```

**监控工具**：
- Prometheus + Grafana
- 自定义监控接口

**告警阈值**：
- 命中率过高：可能异常（如大量 token 被加入黑名单）

#### 18.1.4 Kafka消息延迟

**指标说明**：
- 从事件发布到消费的时间差
- 反映 Kafka 消息处理的延迟

**监控方法**：
```java
// 在 SessionInvalidatedEvent 中记录时间戳
public class SessionInvalidatedEvent {
    private Long timestamp; // 事件发布时间
    
    // 消费时计算延迟
    public long getDelay() {
        return System.currentTimeMillis() - timestamp;
    }
}
```

**监控工具**：
- Kafka 监控工具（如 Kafka Manager）
- 自定义监控脚本

**告警阈值**：
- 延迟超过阈值（如 5 秒）：可能 Kafka 消费异常

---

### 18.2 日志审计

#### 18.2.1 登录日志

**关键日志**：
```java
// LoginSessionKickHandler
log.info("【单点登录】新登录会话已注册: userId={}, sessionId={}, loginSessionId={}, 踢掉旧会话数={}", 
    userId, sessionId, loginSessionId, kickedCount);
```

**审计内容**：
- 用户 ID
- 登录时间
- 登录 IP
- User-Agent
- 被踢掉的旧会话数

**存储建议**：
- 存储到数据库（便于查询和分析）
- 保留一定时间（如 90 天）

#### 18.2.2 登出日志

**关键日志**：
```java
// SecurityConfig
log.info("用户登出: userId={}, loginSessionId={}", userId, loginSessionId);
```

**审计内容**：
- 用户 ID
- 登出时间
- 登出 IP
- 登出原因（主动登出、超时等）

**存储建议**：
- 存储到数据库
- 与登录日志关联

#### 18.2.3 会话状态变更日志

**关键日志**：
```java
// SessionRegistry
log.info("【会话状态更新】更新会话状态: sessionId={}, loginSessionId={}, status={}", 
    sessionId, loginSessionId, status);
```

**审计内容**：
- 会话 ID
- 状态变更时间
- 变更前状态
- 变更后状态
- 变更原因

**存储建议**：
- 存储到数据库
- 保留完整的状态变更历史

---

### 18.3 告警规则

#### 18.3.1 异常登录检测

**告警条件**：
- 短时间内同一用户多次登录
- 同一 IP 短时间内多个用户登录
- 异常地理位置登录

**实现方法**：
```java
// 在 LoginSessionKickHandler 中检测
public void detectAbnormalLogin(String userId, String ip) {
    // 检查短时间内登录次数
    String key = "login:count:" + userId;
    Long count = redis.opsForValue().increment(key);
    redis.expire(key, 1, TimeUnit.HOURS);
    
    if (count > 10) { // 1小时内登录超过10次
        log.warn("【异常登录】用户 {} 在1小时内登录 {} 次", userId, count);
        // 发送告警
        alertService.sendAlert("异常登录", userId, count);
    }
}
```

**告警方式**：
- 邮件通知
- 短信通知
- 企业微信/钉钉通知

#### 18.3.2 大量被踢告警

**告警条件**：
- 短时间内大量会话被踢下线
- 单个用户短时间内多次被踢

**实现方法**：
```java
// 在 LoginSessionKickHandler 中统计
private AtomicLong kickedCount = new AtomicLong(0);

public void onAuthenticationSuccess(...) {
    List<LoginSessionInfo> kicked = ...;
    long count = kickedCount.addAndGet(kicked.size());
    
    // 每分钟重置计数器
    if (count > 100) { // 1分钟内被踢超过100次
        log.warn("【大量被踢】1分钟内被踢 {} 次", count);
        alertService.sendAlert("大量被踢", count);
    }
}
```

**告警方式**：
- 邮件通知
- 短信通知

#### 18.3.3 Kafka消费延迟告警

**告警条件**：
- Kafka 消费延迟超过阈值（如 5 秒）
- Kafka 消费失败率过高

**实现方法**：
```java
// 在 SessionEventConsumer 中监控
public void consumeSessionInvalidated(String message, Acknowledgment ack) {
    SessionInvalidatedEvent event = JSON.parseObject(message, SessionInvalidatedEvent.class);
    long delay = System.currentTimeMillis() - event.getTimestamp();
    
    if (delay > 5000) { // 延迟超过5秒
        log.warn("【Kafka延迟】消息延迟 {} 毫秒", delay);
        alertService.sendAlert("Kafka消费延迟", delay);
    }
}
```

**告警方式**：
- 邮件通知
- 短信通知

---

### 18.4 监控工具

#### 18.4.1 Prometheus + Grafana

**配置示例**：
```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'gateway'
    static_configs:
      - targets: ['localhost:8080']
```

**监控指标**：
- ACTIVE 会话数
- 被踢次数
- 黑名单命中率
- JWT 校验延迟

#### 18.4.2 ELK（Elasticsearch + Logstash + Kibana）

**配置示例**：
```yaml
# logstash.conf
input {
  file {
    path => "/var/log/gateway.log"
    codec => json
  }
}

filter {
  if [message] =~ /单点登录/ {
    mutate {
      add_field => { "event_type" => "login" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "sso-logs-%{+YYYY.MM.dd}"
  }
}
```

**使用场景**：
- 日志查询和分析
- 异常日志告警
- 日志可视化

---

### 18.5 运维检查清单

#### 18.5.1 日常检查

- [ ] 检查 ACTIVE 会话数是否正常
- [ ] 检查被踢次数是否正常
- [ ] 检查黑名单命中率是否正常
- [ ] 检查 Kafka 消息延迟是否正常
- [ ] 检查 Redis 连接是否正常
- [ ] 检查 Kafka 连接是否正常

#### 18.5.2 定期检查

- [ ] 清理过期的会话数据
- [ ] 清理过期的黑名单数据
- [ ] 检查日志文件大小
- [ ] 检查系统资源使用情况

#### 18.5.3 故障处理

- [ ] 检查日志定位问题
- [ ] 检查 Redis 数据
- [ ] 检查 Kafka 消息
- [ ] 检查系统配置

---

### 18.6 本章总结

**关键指标**：
1. **ACTIVE会话数**：反映在线用户数
2. **被踢次数**：反映单点登录活跃度
3. **黑名单命中率**：反映黑名单有效性
4. **Kafka消息延迟**：反映消息处理延迟

**日志审计**：
- ✅ 登录日志：记录登录信息
- ✅ 登出日志：记录登出信息
- ✅ 会话状态变更日志：记录状态变更历史

**告警规则**：
- ✅ 异常登录检测：检测异常登录行为
- ✅ 大量被踢告警：检测异常被踢情况
- ✅ Kafka消费延迟告警：检测消息处理异常

**监控工具**：
- Prometheus + Grafana：指标监控
- ELK：日志分析

**下一步**：理解了监控与运维后，我们已经完成了实践与运维的学习。接下来可以查看附录部分，了解关键代码文件清单、配置说明、术语表等。

---

## 附录

> **本章目标**：提供关键代码文件清单、配置说明、术语表、参考资料等，便于快速查找和理解。

---

### A. 关键代码文件清单

#### A.1 Gateway服务

**核心文件**：

**登录处理**：
- `apps/gateway/src/main/java/com/gamehub/gateway/handler/LoginSessionKickHandler.java`
  - 登录成功处理器
  - 实现单点登录逻辑
  - 黑名单处理
  - 事件发布

**JWT校验**：
- `apps/gateway/src/main/java/com/gamehub/gateway/config/JwtDecoderConfig.java`
  - 自定义 JWT 解码器
  - 三层校验（黑名单、签名、状态）
  - 会话状态检查

**Token获取**：
- `apps/gateway/src/main/java/com/gamehub/gateway/controller/TokenController.java`
  - `/token` 接口实现
  - 多层验证（Session、SessionRegistry、状态）
  - 防止 token 被覆盖

**安全配置**：
- `apps/gateway/src/main/java/com/gamehub/gateway/config/SecurityConfig.java`
  - Spring Security 配置
  - OAuth2 登录配置
  - 登出处理
  - 事件发布

**黑名单服务**：
- `apps/gateway/src/main/java/com/gamehub/gateway/service/JwtBlacklistService.java`
  - JWT 黑名单管理
  - Redis 存储

**配置文件**：
- `apps/gateway/src/main/resources/application.yml`
  - Spring Security 配置
  - Redis 配置
  - Kafka 配置
  - Session 配置

#### A.2 Game-Service服务

**核心文件**：

**WebSocket管理**：
- `apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/WebSocketSessionManager.java`
  - WebSocket 连接管理
  - 会话注册
  - 单点登录处理

**事件监听**：
- `apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/SessionInvalidatedListener.java`
  - Kafka 事件监听
  - WebSocket 断连处理

**断连工具**：
- `apps/game-service/src/main/java/com/gamehub/gameservice/platform/ws/WebSocketDisconnectHelper.java`
  - 发送踢人通知
  - 强制断开连接

**配置文件**：
- `apps/game-service/src/main/resources/application.yml`
  - Redis 配置
  - Kafka 配置
  - Session 配置

#### A.3 Session-Common库

**核心文件**：

**会话注册表**：
- `libs/session-common/src/main/java/com/gamehub/session/SessionRegistry.java`
  - 登录会话管理
  - WebSocket 会话管理
  - 单点登录实现

**数据模型**：
- `libs/session-common/src/main/java/com/gamehub/session/model/LoginSessionInfo.java`
  - 登录会话信息
- `libs/session-common/src/main/java/com/gamehub/session/model/WebSocketSessionInfo.java`
  - WebSocket 会话信息
- `libs/session-common/src/main/java/com/gamehub/session/model/SessionStatus.java`
  - 会话状态枚举

**配置类**：
- `libs/session-common/src/main/java/com/gamehub/session/config/SessionRedisConfig.java`
  - Redis 配置
- `libs/session-common/src/main/java/com/gamehub/session/config/SessionCommonAutoConfiguration.java`
  - 自动配置

#### A.4 Session-Kafka-Notifier库

**核心文件**：

**事件发布**：
- `libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/publisher/SessionEventPublisher.java`
  - 会话失效事件发布
  - Kafka 消息发送

**事件消费**：
- `libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/listener/SessionEventConsumer.java`
  - Kafka 消息消费
  - 监听器调用

**事件模型**：
- `libs/session-common/src/main/java/com/gamehub/session/event/SessionInvalidatedEvent.java`
  - 会话失效事件
- `libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/listener/SessionEventListener.java`
  - 事件监听器接口

**配置类**：
- `libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/config/SessionKafkaConfig.java`
  - Kafka 配置
- `libs/session-kafka-notifier/src/main/java/com/gamehub/sessionkafkanotifier/config/SessionKafkaNotifierAutoConfiguration.java`
  - 自动配置

---

### B. 配置说明

#### B.1 Spring Security配置

**Gateway服务配置**：

**文件位置**：`apps/gateway/src/main/resources/application.yml`

**关键配置**：
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          keycloak:
            client-id: ${KEYCLOAK_CLIENT_ID:game-hub-client}
            client-secret: ${KEYCLOAK_CLIENT_SECRET:your-secret}
            scope: openid,profile,email
            authorization-grant-type: authorization_code
            redirect-uri: ${KEYCLOAK_REDIRECT_URI:http://localhost:8080/login/oauth2/code/keycloak}
        provider:
          keycloak:
            issuer-uri: ${KEYCLOAK_ISSUER_URI:http://localhost:8180/realms/my-realm}
            user-name-attribute: preferred_username
      resourceserver:
        jwt:
          issuer-uri: ${KEYCLOAK_ISSUER_URI:http://localhost:8180/realms/my-realm}
```

**说明**：
- `client-id`：OAuth2 客户端 ID
- `client-secret`：OAuth2 客户端密钥
- `issuer-uri`：Keycloak 颁发者 URI
- `scope`：请求的权限范围

#### B.2 Redis配置

**Session-Common配置**：

**文件位置**：`apps/gateway/src/main/resources/application.yml`、`apps/game-service/src/main/resources/application.yml`

**关键配置**：
```yaml
# session 会话管理配置
session:
  redis:
    host: ${SESSION_REDIS_HOST:127.0.0.1}
    port: ${SESSION_REDIS_PORT:6379}
    database: ${SESSION_REDIS_DATABASE:0}
    password: ${SESSION_REDIS_PASSWORD:zaqxsw}
```

**重要说明**：
- ✅ **统一 Redis 库**：所有服务（Gateway、game-service、system-service 等）必须使用相同的 Redis database（默认 database 0）
- ✅ **会话数据共享**：通过统一 Redis 库，各服务可以共享会话状态，实现跨服务的会话管理
- ✅ **配置方式**：通过环境变量 `SESSION_REDIS_DATABASE` 统一配置，确保所有服务使用相同的 database
- ✅ **与业务 Redis 分离**：每个服务还有自己的业务 Redis 配置（`spring.data.redis.database`），用于存储业务数据，与会话 Redis 分离

**业务 Redis 配置示例**（各服务不同）：
```yaml
spring:
  data:
    redis:
      database: 1  # Gateway 使用 database 1
      # database: 2  # game-service 使用 database 2
      # database: 3  # system-service 使用 database 3
```

**会话 Redis 配置**（所有服务相同）：
```yaml
session:
  redis:
    database: 0  # 所有服务统一使用 database 0
```

**说明**：
- `host`：Redis 主机地址
- `port`：Redis 端口
- `database`：Redis 数据库编号
- `password`：Redis 密码

**Redis键空间**：
```
session:login:user:{userId}                    → Set<sessionId>
session:login:token:{sessionId}                → LoginSessionInfo JSON
session:login:loginSession:{loginSessionId}    → LoginSessionInfo JSON
session:ws:user:{userId}                       → Set<sessionId>
session:ws:session:{sessionId}                 → WebSocketSessionInfo JSON
jwt:blacklist:{tokenHash}                      → "1" (TTL)
```

#### B.3 Kafka配置

**Session-Kafka-Notifier配置**：

**文件位置**：`apps/gateway/src/main/resources/application.yml`、`apps/game-service/src/main/resources/application.yml`

**关键配置**：
```yaml
session:
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    topic: ${SESSION_KAFKA_TOPIC:session-invalidated}
    consumer:
      group-id: ${SESSION_KAFKA_GROUP_ID:game-service-session-group}
```

**说明**：
- `bootstrap-servers`：Kafka 服务器地址
- `topic`：事件主题名称
- `group-id`：消费者组 ID

#### B.4 Keycloak配置

**关键配置**：

**Realm配置**：
- Realm 名称：`my-realm`
- 客户端 ID：`game-hub-client`
- 客户端类型：`public` 或 `confidential`

**Token配置**：
- Access Token 有效期：15 分钟（默认）
- Refresh Token 有效期：30 天（默认）
- 确保 JWT 中包含 `sid` claim

**Mapper配置**（如果需要）：
- 添加 `sid` claim 到 access_token
- 或使用 Keycloak 默认的 `sid` claim

---

### C. 术语表

#### C.1 loginSessionId（登录会话ID）

**定义**：整个登录生命周期内稳定不变的标识符。

**来源**：
- **推荐**：Keycloak 的 `sid`（Session ID）claim
- **备选**：Keycloak 的 `session_state` claim（向后兼容）

**特性**：
- ✅ 在一次登录内稳定不变
- ✅ token 刷新时保持不变
- ✅ 新登录会产生新的 `loginSessionId`

**用途**：
- 单点登录（后连踢前）
- 会话管理
- WebSocket 连接管理

#### C.2 sessionId（会话ID）

**定义**：JWT token 的 `jti`（JWT ID）claim，用于标识单个 token。

**特性**：
- ⚠️ token 刷新时可能变化
- ⚠️ 每个 token 都有自己的 `jti`
- ✅ 用于向后兼容

**用途**：
- token 标识
- 向后兼容查询

#### C.3 jti（JWT ID）

**定义**：JWT 标准中的 `jti`（JWT ID）claim，用于唯一标识 JWT token。

**特性**：
- ⚠️ token 刷新时可能变化（取决于 Keycloak 配置）
- ⚠️ 只标识单个 token
- ✅ 符合 JWT 标准

**用途**：
- token 标识
- 向后兼容

#### C.4 sid（Session ID）

**定义**：Keycloak 的 `sid`（Session ID）claim，用于标识 Keycloak 会话。

**特性**：
- ✅ 在整个登录生命周期内稳定不变
- ✅ token 刷新时保持不变
- ✅ 符合 OIDC 规范

**用途**：
- 作为 `loginSessionId` 使用
- 单点登录核心标识

#### C.5 session_state

**定义**：Keycloak 的 `session_state` claim，用于标识 Keycloak 会话状态。

**特性**：
- ⚠️ 可能不稳定或不总是可用
- ⚠️ 某些 Keycloak 版本可能不在 JWT claim 中
- ✅ 作为 `sid` 的备选

**用途**：
- 向后兼容
- `sid` 不可用时的备选

#### C.6 SessionStatus（会话状态）

**定义**：用于标识登录会话的当前状态。

**状态枚举**：
- `ACTIVE`：当前有效
- `KICKED`：被后续登录踢下线
- `EXPIRED`：正常超时或注销

#### C.7 LoginSessionInfo（登录会话信息）

**定义**：登录会话的完整信息。

**关键字段**：
- `sessionId`：JWT 的 `jti`
- `loginSessionId`：Keycloak 的 `sid`
- `userId`：用户 ID
- `status`：会话状态
- `token`：access_token
- `issuedAt`：签发时间
- `expiresAt`：过期时间

#### C.8 WebSocketSessionInfo（WebSocket会话信息）

**定义**：WebSocket 连接的完整信息。

**关键字段**：
- `sessionId`：WebSocket 会话 ID
- `userId`：用户 ID
- `loginSessionId`：登录会话 ID
- `service`：服务名称（如 "game-service"）

---

### D. 参考资料

#### D.1 Spring Security OAuth2文档

**官方文档**：
- Spring Security OAuth2 Client：https://docs.spring.io/spring-security/reference/servlet/oauth2/client/index.html
- Spring Security OAuth2 Resource Server：https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html

**关键概念**：
- OAuth2 Client
- OAuth2 Resource Server
- JWT 解码器
- OAuth2AuthorizedClient

#### D.2 Keycloak文档

**官方文档**：
- Keycloak 官方文档：https://www.keycloak.org/documentation
- Keycloak Server Administration Guide：https://www.keycloak.org/docs/latest/server_admin/

**关键概念**：
- Realm
- Client
- User Session
- Session ID (sid)
- Token Claims

#### D.3 Redis文档

**官方文档**：
- Redis 官方文档：https://redis.io/docs/
- Redis 命令参考：https://redis.io/commands/

**关键概念**：
- String
- Set
- Sorted Set
- Hash
- TTL
- Pipeline

#### D.4 Kafka文档

**官方文档**：
- Kafka 官方文档：https://kafka.apache.org/documentation/
- Spring Kafka 文档：https://docs.spring.io/spring-kafka/reference/html/

**关键概念**：
- Topic
- Partition
- Consumer Group
- Offset
- Producer
- Consumer

#### D.5 Spring WebSocket文档

**官方文档**：
- Spring WebSocket 文档：https://docs.spring.io/spring-framework/reference/web/websocket.html
- STOMP 协议：https://stomp.github.io/

**关键概念**：
- WebSocket
- STOMP
- Session
- Message Channel

---

### E. 快速参考

#### E.1 关键常量

**SessionRegistry 键前缀**：
```java
LOGIN_USER_KEY_PREFIX = "session:login:user:"
LOGIN_SESSION_KEY_PREFIX = "session:login:token:"
LOGIN_SESSION_BY_LOGIN_SESSION_ID_PREFIX = "session:login:loginSession:"
WS_USER_KEY_PREFIX = "session:ws:user:"
WS_SESSION_KEY_PREFIX = "session:ws:session:"
```

**HTTP Session 键**：
```java
SESSION_LOGIN_SESSION_ID_KEY = "LOGIN_SESSION_ID"
```

**黑名单键前缀**：
```java
BLACKLIST_KEY_PREFIX = "jwt:blacklist:"
```

#### E.2 关键方法

**SessionRegistry**：
- `registerLoginSessionEnforceSingle()`：注册登录会话（单点登录）
- `getLoginSessionByLoginSessionId()`：按 loginSessionId 查询
- `updateSessionStatus()`：更新会话状态
- `registerWebSocketSessionEnforceSingle()`：注册 WebSocket 会话（单点登录）

**JwtBlacklistService**：
- `addToBlacklist()`：加入黑名单
- `isBlacklisted()`：检查是否在黑名单中

**SessionEventPublisher**：
- `publishSessionInvalidated()`：发布会话失效事件

#### E.3 关键日志标识

**日志标识**：
- `【单点登录】`：登录相关日志
- `【JWT 校验】`：JWT 校验相关日志
- `【Token获取】`：Token 获取相关日志
- `【会话状态更新】`：会话状态更新日志

---

### F. 完整文档导航

**文档结构**：
1. **背景与问题分析**：理解功能需求和技术挑战
2. **核心设计思想**：理解设计原则和解决方案
3. **关键概念定义**：理解核心概念和术语
4. **登录流程完整实现**：理解登录流程和代码实现
5. **JWT校验流程完整实现**：理解 JWT 校验和三层校验
6. **Token获取接口实现**：理解 Token 获取和验证
7. **登出流程完整实现**：理解登出流程和事件发布
8. **WebSocket连接管理**：理解 WebSocket 连接管理
9. **Kafka事件通知机制**：理解事件发布和消费
10. **SessionRegistry核心实现**：理解会话注册表实现
11. **JWT黑名单机制**：理解黑名单实现
12. **完整数据流图**：理解完整数据流
13. **关键设计决策**：理解设计决策原因
14. **边界场景处理**：理解边界场景处理
15. **测试验证**：理解测试方法
16. **常见问题与解决方案**：理解问题排查方法
17. **性能优化建议**：理解性能优化方法
18. **监控与运维**：理解监控和运维方法

---

### G. 本章总结

**附录内容**：
1. **关键代码文件清单**：Gateway、Game-Service、Session-Common、Session-Kafka-Notifier
2. **配置说明**：Spring Security、Redis、Kafka、Keycloak
3. **术语表**：loginSessionId、sessionId、jti、sid、session_state 等
4. **参考资料**：Spring Security、Keycloak、Redis、Kafka 官方文档
5. **快速参考**：关键常量、方法、日志标识

**使用建议**：
- ✅ 作为快速参考手册
- ✅ 查找关键代码文件位置
- ✅ 理解配置项含义
- ✅ 理解术语定义

**文档完成**：至此，我们已经完成了单点登录系统完整实现详解文档的所有内容。希望这份文档能够帮助你深入理解整个系统的实现原理和细节。

