# 已读未读消息完整逻辑说明

## 一、数据库字段

在 `chat_session_member` 表中，有两个关键字段用于跟踪已读状态：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `last_read_message_id` | UUID | 最后已读的消息ID |
| `last_read_time` | OffsetDateTime | 最后已读时间 |

## 二、未读消息数计算逻辑

### 2.1 后端计算流程（`ChatSessionServiceImpl.countUnreadMessages()`）

**步骤1：获取成员记录**
```java
ChatSessionMember member = memberRepository.findBySessionIdAndUserId(sessionId, userId)
```

**步骤2：判断成员是否存在**
- 如果成员不存在 → 返回所有未撤回的消息数（认为全部未读）

**步骤3：判断是否打开过会话**
- 如果 `last_read_time` 为 null → 返回所有未撤回的消息数（用户从未打开过会话）

**步骤4：计算未读消息数**
1. **优先使用最后已读消息的 `created_at`**：
   - 如果 `last_read_message_id` 不为 null，查询该消息的 `created_at`
   - 使用这个时间戳作为 `lastReadTime`

2. **兜底方案**：
   - 如果查询不到最后已读消息（可能被删除了），使用 `last_read_time` 作为兜底
   - 如果 `last_read_message_id` 为 null，也使用 `last_read_time` 作为兜底

3. **查询未读消息数**：
   ```sql
   SELECT COUNT(*) FROM chat_message m 
   WHERE m.session_id = :sessionId 
   AND m.is_recalled = false 
   AND m.created_at > :lastReadTime
   ```

### 2.2 计算逻辑总结

```
未读数 = 会话中 created_at > lastReadTime 且 is_recalled = false 的消息数量

其中 lastReadTime 的优先级：
1. 最后已读消息的 created_at（如果 last_read_message_id 存在且消息存在）
2. last_read_time（作为兜底）
```

## 三、未读变已读的逻辑

### 3.1 触发时机

已读标记在以下情况下触发：

#### 情况1：用户打开会话（从"最近聊天"列表）
- **前端**：`handleOpenThread(threadId)`
- **流程**：
  1. 设置 `activeThreadId = threadId`
  2. 前端立即将未读数设为 0（乐观更新）
  3. 加载历史消息（如果还没有加载过）
  4. 调用 `markSessionAsRead(threadId, friendId)`

#### 情况2：用户点击好友（从"好友列表"）
- **前端**：`handleFriendClick(friend)`
- **流程**：
  1. 创建或切换到该好友的会话
  2. 设置 `activeThreadId = threadId`
  3. 加载历史消息（如果还没有加载过）
  4. 调用 `markSessionAsRead(threadId, friendId)`

#### 情况3：对话框一直开着，收到新消息（WebSocket）
- **前端**：WebSocket 收到新消息时
- **流程**：
  1. 收到新消息，调用 `addMessage()` 添加到界面
  2. 检查 `activeThreadIdRef.current === threadId`（是否是当前活动会话）
  3. 如果是，自动调用 `markSessionAsRead(threadId, senderId)`

### 3.2 后端标记已读流程（`ChatSessionServiceImpl.markAsRead()`）

**步骤1：获取成员记录**
```java
ChatSessionMember member = memberRepository.findBySessionIdAndUserId(sessionId, userId)
```

**步骤2：确定已读消息ID和时间**
- 如果请求中提供了 `messageId`：
  - 使用该 `messageId`
  - 查询该消息的 `created_at` 作为 `readTime`
- 如果没有提供 `messageId`：
  - 查询会话的最后一条消息
  - 使用最后一条消息的 `id` 作为 `readMessageId`
  - 使用最后一条消息的 `created_at` 作为 `readTime`
- 如果会话没有消息：
  - `readMessageId = null`
  - `readTime = null`（会使用 `OffsetDateTime.now()` 作为兜底）

**步骤3：更新数据库**
```java
member.setLastReadMessageId(readMessageId);
member.setLastReadTime(readTime != null ? readTime : OffsetDateTime.now());
memberRepository.save(member);
```

### 3.3 关键点

1. **使用消息的 `created_at` 而不是当前时间**：
   - 如果最后一条消息的 `created_at` 是 `18:29:59.800`
   - `last_read_time` 也会被设置为 `18:29:59.800`（而不是当前时间）
   - 这样可以确保时间戳准确，避免时间差导致的未读数计算错误

2. **即使没有消息，也更新 `last_read_time`**：
   - 如果会话还没有消息（`readMessageId = null`）
   - 也会更新 `last_read_time = OffsetDateTime.now()`
   - 这样在计算未读数时，如果 `last_read_time` 不为 null，即使 `last_read_message_id` 为 null，也能正确判断

## 四、完整流程图

### 4.1 未读消息数计算流程

```
用户请求会话列表
    ↓
后端调用 countUnreadMessages(sessionId, userId)
    ↓
查询 chat_session_member 表
    ├─ 成员不存在 → 返回所有未撤回消息数
    ├─ last_read_time 为 null → 返回所有未撤回消息数
    └─ last_read_time 不为 null → 继续
        ↓
确定 lastReadTime
    ├─ 优先：last_read_message_id 对应的消息的 created_at
    └─ 兜底：last_read_time
        ↓
查询 created_at > lastReadTime 且 is_recalled = false 的消息数
    ↓
返回未读数
```

### 4.2 未读变已读流程

```
用户打开会话 / 收到新消息（对话框开着）
    ↓
前端调用 markSessionAsRead(threadId, friendId)
    ↓
获取 sessionId（从缓存或查询）
    ↓
调用 POST /chat-service/api/sessions/{sessionId}/read
    ↓
后端 markAsRead(sessionId, userId, messageId)
    ↓
确定已读消息ID和时间
    ├─ 如果提供了 messageId → 查询该消息的 created_at
    ├─ 如果没有提供 → 查询最后一条消息的 created_at
    └─ 如果没有消息 → 使用当前时间
        ↓
更新 chat_session_member 表
    - last_read_message_id = readMessageId
    - last_read_time = readTime（消息的 created_at 或当前时间）
    ↓
完成标记已读
```

## 五、已读的判断标准

一条消息被认为是"已读"的条件：

1. **用户打开过会话**：`last_read_time` 不为 null
2. **消息时间在已读时间之前或等于**：
   - 如果 `last_read_message_id` 存在：消息的 `created_at <= 最后已读消息的 created_at`
   - 如果 `last_read_message_id` 不存在：消息的 `created_at <= last_read_time`

**未读消息的判断**：
```
未读消息 = created_at > lastReadTime 且 is_recalled = false 的消息
```

## 六、特殊情况处理

### 6.1 会话还没有消息
- `last_read_message_id = null`
- `last_read_time = OffsetDateTime.now()`（标记已读时的时间）
- 未读数 = 0（因为 `last_read_time` 不为 null，且没有消息）

### 6.2 最后已读消息被删除
- `last_read_message_id` 存在，但查询不到对应的消息
- 使用 `last_read_time` 作为兜底时间戳
- 查询 `created_at > last_read_time` 的消息

### 6.3 对话框一直开着
- WebSocket 收到新消息时，如果 `activeThreadId === threadId`
- 自动调用 `markSessionAsRead` 标记为已读
- 确保新消息立即被标记为已读

### 6.4 历史消息加载
- 加载历史消息时，传递 `isHistory: true`
- 历史消息不会增加未读数
- 只有新收到的实时消息才会增加未读数

## 七、时间戳比较的重要性

**为什么使用时间戳而不是 UUID 比较**：
- UUID 不是时间有序的，不能用于比较消息的先后顺序
- 使用 `created_at` 时间戳可以准确判断消息的先后顺序

**为什么使用消息的 `created_at` 而不是当前时间**：
- 如果使用 `OffsetDateTime.now()` 作为 `last_read_time`
- 而最后一条消息的 `created_at` 可能比当前时间早
- 会导致时间差，影响未读数计算的准确性

**正确的做法**：
- 使用最后已读消息的 `created_at` 作为 `last_read_time`
- 确保时间戳准确，避免时间差导致的未读数计算错误

## 八、API 端点

### 8.1 查询会话列表（包含未读数）
```
GET /chat-service/api/sessions
返回：[
  {
    "sessionId": "...",
    "unreadCount": 3,  // 未读消息数
    ...
  }
]
```

### 8.2 标记消息为已读
```
POST /chat-service/api/sessions/{sessionId}/read
Query参数: messageId (可选，如果不提供则标记为最后一条消息)
```

### 8.3 查询私聊会话ID（仅查询，不创建）
```
GET /chat-service/api/sessions/private/{otherUserId}
返回: { sessionId: "..." }
如果会话不存在，返回 404
```

## 九、总结

### 9.1 未读消息数计算
- 基于时间戳比较：`created_at > lastReadTime`
- `lastReadTime` 优先使用最后已读消息的 `created_at`，如果没有则使用 `last_read_time`

### 9.2 未读变已读
- 触发时机：打开会话、点击好友、对话框开着时收到新消息
- 更新数据库：`last_read_message_id` 和 `last_read_time`
- 使用消息的 `created_at` 作为 `last_read_time`，确保时间戳准确

### 9.3 关键原则
1. **时间戳优先**：使用消息的 `created_at` 而不是当前时间
2. **兜底机制**：如果消息不存在，使用 `last_read_time` 作为兜底
3. **实时同步**：对话框开着时，新消息自动标记为已读
4. **历史消息不计数**：加载历史消息时不增加未读数


