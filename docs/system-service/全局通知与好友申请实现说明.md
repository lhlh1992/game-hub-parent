# 全局通知与好友申请实现说明

> 当前实现概述：好友申请写入 system-service，通知落 `sys_notification` 并通过 chat-service 推送；前端铃铛展示/操作好友申请，支持同意/拒绝。

## 后端实现（system-service）

### 数据表
- `sys_notification`：全局通知表，仅记录通知及读状态，不承载业务状态；未读/已读，未读优先排序。

### 核心流程
1) **发起好友申请**
   - `POST /api/friends/apply`
   - 写 `friend_request`（PENDING），并给接收方发送 `FRIEND_REQUEST` 通知（落库+WS，payload 带 `friendRequestId`，actions=`["ACCEPT","REJECT"]`）。

2) **处理好友申请（接收方）**
   - `POST /api/friends/requests/{id}/accept`
   - `POST /api/friends/requests/{id}/reject`
   - 校验：当前登录用户必须是接收方；状态必须 PENDING。
   - 同意：更新 `friend_request` 为 ACCEPTED，并创建双向 `user_friend` 关系。
   - 拒绝：更新 `friend_request` 为 REJECTED。
   - 无论同意/拒绝，给申请人发送 `FRIEND_RESULT` 通知（落库+WS）。

3) **通知查询与状态**
   - `GET /api/notifications?status=&limit=10`：status 可选，空则“未读优先 + 时间倒序”取最近 10 条。
   - `GET /api/notifications/unread-count`：未读角标。
   - `POST /api/notifications/{id}/read`、`/read-all`：仅改通知读状态。
   - `GET /api/notifications/metadata`：返回支持的通知类型元数据（FRIEND_REQUEST 可操作，FRIEND_RESULT/SYSTEM_ALERT 不可操作）。

### 代码位置
- 控制器：`controller/friend/FriendController.java`，`controller/notification/NotificationController.java`
- 服务：`service/friend/impl/FriendServiceImpl.java`，`service/notification/impl/NotificationServiceImpl.java`
- 通知查询排序：`repository/notification/NotificationRepository.java`

### 关键注意点
- 通知不改变业务状态，业务状态在 `friend_request`/`user_friend` 中维护。
- WS 推送失败不回滚主事务（仅记录 warn）。
- 错误码：BusinessException 映射 400/403/404/409，便于前端提示。

## 前端实现（game-hub-web）

### 铃铛行为
- 初始化：拉取 `notifications(null,10)`（含已读未读，未读优先）+ `unread-count`。
- WS 推送：追加去重，未读优先排序，截断 10；未读计数对未读新消息 +1。
- 点击通知：默认仅标记已读；调用 `markNotificationRead`。
- 好友申请（type=FRIEND_REQUEST，actions 包含 ACCEPT/REJECT）：
  - 渲染【同意】【拒绝】按钮。
  - 调用后端 accept/reject，成功后标记已读、移除动作，未读数减 1。
  - `friendRequestId` 优先从 payload 取，缺省用通知 id。
- 排序：本地二次排序（未读优先、时间倒序）确保操作后无需刷新。

### 前端代码位置
- 铃铛组件：`src/components/layout/Header.jsx`
- API：`src/services/api/notificationApi.js`，`src/services/api/friendApi.js`

## 已知风险与改进建议
1) **API 前缀硬编码**：前端 accept/reject 仅尝试 `/system-service/api/...`、`/api/...` 两条，若部署前缀不同需改为可配置。
2) **分页/历史缺失**：通知仅取最新 10 条，无分页/加载更多，历史不可见。
3) **未读计数一致性**：本地未读数更新与后端可能短暂不一致（处理失败时）；可在处理成功后重新拉 `unread-count` 兜底。
4) **推送去重依赖 id**：WS 需带 `notificationId`；若缺失可能重复显示。
5) **安全**：内部推送接口仅 JWT，无额外签名/白名单，需确保只经网关受控暴露。

## 当前结论
- 业务分层与微服务边界基本合理：system-service 负责业务与通知落库，chat-service 负责推送。
- 功能可用，但建议后续做配置化前缀、分页与历史、兜底未读数刷新，以提升稳健性。

